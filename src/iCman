#!/usr/bin/perl
use strict;
########################################################################
#	iCman developed from
#--------------------------------------------------------------
# perlman: man page viewer in Perl
#--------------------------------------------------------------
# in "Advanced Perl Programming"
#     by Sriram Srinivasan
#
#	modified by John E. Wulff to act as a HELP viewer
#	for iC Project widgets and all other man pages
#--------------------------------------------------------------
#	Changes from perlman:
# 1	Make Text window READ-ONLY
# 2	Use the search algorithm developed for iClive which moves
#	the text to 'see' the text that has been found.
# 3	Implement a history with previous and next buttons [<=] [=>]
# 4	Handle apropos topics with '-k <key>'
# 5	Dynamic change of font size with Alt- Alt+ and [-] [+] buttons
# 6	Handle whatis with '-f <page>'
# 7	Introduce paleblue hyper-links which double-click to that page
# 8	Change man menu to hold history and manage <= and => buttons
########################################################################
use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use Tk::Dialog;
use warnings;

my $named = $0; $named =~ s#.*[/\\]##;
use vars qw($opt_c $opt_n $opt_k $opt_f $opt_F $opt_l $opt_w $opt_g $opt_r $opt_T $opt_M $opt_X $opt_h);
my $ofh = select(STDERR);	# save old file handle
$= = 100;			# stop page overflow (default 60 lines)
select($ofh);			# retore old file handle

format STDERR =
Usage:
@<<<< [ -cnrTh][ -k <key>][ -f <page>][ -F <font>][ -l <num>][ -w <num>]
 $named
      [ -g <geometry>][ -M <file>][ [<section>] <manpage> ...] ...
    -k key  display the output of man -k <key> (apropos) which provides
            man page links to the topic described by <key>.
    -f page display the output of man -f <page> (whatis)
    -F font font or font size to use in Text window (default '18')
    -l num  height of the Text window (default @<<)
					$opt_l
    -w num  width  of the Text window (default @<<) -w0 is terminal width
					$opt_w
    -g geom geometry for main window
    -c      build a new cache of section names (default: use cache)
    -n      no fork of initial window (used in internal fork call)
            (default is to fork the initial window)
    -r      restore last session with manpage and search history
    -T      trace output static debug messages
    -M file store output of man command in file for debugging
            warn about unusual ANSI ESC codes
    -h      help, ouput this Usage text only

    Manpage arguments may be of the form <section> <manpage>, which is
    the classical call for 'man'. <manpage>(<section>) may be used as
    an alternative, but this form must be quoted for the shell.  In
    either case <section> must be a valid section name.

    One or more manpage arguments may be used - these are placed in
    the history. If no manpage arguments are specified or if the -r
    option is used, the last session is restored with all its manpage
    and search history. The first manpage in the history is opened.
    This is either the first manpage argument or the first manpage
    in the previous session history.

 Menu buttons:                   Action                      Accelerator

    [man] ----- tear-off - menu can be moved and left open
       Show     a new manpage - in this window                   RETURN
                (followed by an optional section in parentheses)
                Alternatively show a list of topics matching a key
                with '-k <key>' or 'apropos <key>' entered in the
                show window or '-f <page>' or 'whatis <page>'
                Double-clicking on a hyper-link (pale blue) in
                the main text will also open that page
       Open     a new window - to show selected manpage         Alt-RET
       Reload   the current manpage (usually modified externally)   r
       Quit     the program                                         q
       -------- this is followed by a history of previous pages,
                which can be selected randomly

    [ <= ]      Load the previous manpage in the history            p
    [ => ]      Load the next manpage in the history                n

    [Headings]  Skip to one of the headings in the manpage
    [Sections]  Load the index for one of the manpage sections

    [ / ]       Put focus in Search Entry window if cleared.        /
                    (simulates vi)                            or  Alt-/
                Else start or continue a search of text in
                the Search Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options
       Search down      or                                       RETURN
                displays a new group of hits
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits
       Clear            or double-click Search Entry window or Ctrl-RET
                clears hits and the Search Entry window
     <>Go to line       or                                      Alt-RET
                goes to the line entered in the Search Entry window
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Rgexp+ignore case
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display the @<<<< man page.                         h
			    $named

Copyright (C) 2000-2013  John E. Wulff          <immediateC@gmail.com>
							  '@'
The core of this program is from 'perlman' by Sriram Srinivasan
published in 'Advanced Perl Programming' - gratefully acknowledged.
$Id: iCman 1.26 $ uses Tk-@<<<<<<<<<
						    $Tk::VERSION
.

########################################################################
#	Global variables
########################################################################

my $ignore_case;	# 1 if check-button on in Search menu
my $match_type;		# '-regexp' or '-exact'.
my $text;		# Main text widget
my $page;		# currently showing man page
my $height;		# current height of a character
my %sections;		# Maps section ('1', '3' ,'3n' etc.)
my $info = '';		# info messages in status bar
my $pickFlag = 0;
my $opt = '';
my $searchText = '';
my @tagArray =	(
		    [ '' ],			# $tag = 0
		    [ 'bd' ],			# $tag = 1
		    [ '' ],			# $tag = 2
		    [ '', 'bd' ],		# $tag = 3
		    [ 'ul' ],			# $tag = 4
		    [ 'bd', 'ul' ],		# $tag = 5
		    [ '', 'ul' ],		# $tag = 6
		    [ '', 'bd', 'ul' ],		# $tag = 7
		);
# has to be global, 'our' not portable yet
my (@hits, @groups, $gi, $centre);
my $lineCnt = 0;
my $gl = 0;
my $prevText = '';
my $prevMatch = '';

########################################################################
#
#	Handle signals
#
#	Perl-Tk applications cannot catch a HUP or TERM signal sent by the
#	Linux system at LOGOUT or SHUTDOWN, because the underlying X-Server
#	is already brought down by the HUP and seems to halt all Tk applications
#	at that point in time
#
#	The following is an extract from the XSERVER(1) man page:
#
#	The X server attaches special meaning to the following signals:
#
#	SIGHUP
#	    This signal causes the server to close all existing connections,
#	    free all resources, and restore all defaults. It is sent by
#	    the display manager whenever the main user's main application
#	    (usually an xterm or window manager) exits to force the server
#	    to clean up and prepare for the next user.
#	SIGTERM
#	    This signal causes the server to exit cleanly.
#
########################################################################

$SIG{HUP}  = \&quit_program;	# catch signal from signal 1
$SIG{TERM} = \&quit_program;	# catch signal from signal 15

$SIG{PIPE} = \&catch_sig;	# catch signal in pipe from man

########################################################################
#	Command line options
########################################################################

use Getopt::Std;		# replace require "getopts.pl";
getopts('cnk:f:F:l:w:g:rTM:Xh');	# sets $opt_h if -h etc

exit(-1) if $opt_X;		# $named -X called in forked process if first exec fails

my $size = `stty size`;
chomp $size;
my @sizes = $size ? split ' ', $size : (35, 85);
print "size = '$size'\n" if $opt_T;
$opt_l = $sizes[0] unless $opt_l;	# if any higher than 35 on 768 pixel high screen, status bar is hidden
$opt_w = $sizes[1] if defined $opt_w and $opt_w == 0;	# adjust to terminal width
					# @sizes made the same as terminal size because on Debian systems 'man'
					# generates man pages the full width of the terminal (jw 20130829)
$opt_w = 85 unless $opt_w;		# 85 just allows all buttons to fit in the top menu bar (this wide anyway)
					# also gives a bit more room for oversize texts
print "opt_l = '$opt_l' opt_w = '$opt_w'\n" if $opt_T;
if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my ($fontSize, $font_t, $boldfont_t, $font, $boldfont);
if (defined $opt_F) {
    if ($opt_F =~ /^\d+$/) {
	$fontSize = $opt_F;
    } else {
	$font_t = $opt_F;
	$fontSize = 18;
    }
}
unless ($font_t) {
    if ($ENV{COMSPEC}) {	# defined on Windows 98 and Windows XP
	$fontSize = 12 unless $fontSize;
	$font_t = "{Lucida Console} fontSize normal";
    } else {			# Linux
	$fontSize = 18 unless $fontSize;
	$font_t = "-adobe-courier-medium-r-normal--fontSize-100-100-100-m-90-iso8859-1";
    }
}
if ($font_t =~ /medium/) {
    $boldfont_t = $font_t;
    $boldfont_t =~ s/medium/bold/;
} else {
    $boldfont_t = "-adobe-courier-bold-r-normal--fontSize-100-100-100-m-90-iso8859-1";
}
change_font(0, 0);		# set initial font size to $fontSize

no warnings;
print "fontSize = '$fontSize'\nfont     = '$font'\nboldfont = '$boldfont'\n" if $opt_T;
use warnings;

scout_man_dirs();
to_background() unless $opt_n;	# run window as a  forked process

########################################################################
#
#	Create main window and menus
#
#	NOTE: parameters in -command => [ ] closures are taken from the
#	      time the command was executed - not when event takes place.
#	      Use references to variables instead of value variables to
#	      pass information at run-time.
#
########################################################################

my $mainWindow = MainWindow->new();
my $arg = $ARGV[0];
if ($arg and $arg =~ /^\d+x\d+(\+\d+\+\d+)?$/) {
    $opt_g = $arg;		# iCman restored after logout and restore
    shift @ARGV;		# first ARGV was a geometry
}
if ($opt_g) {
    if ($opt_g =~ /^(\d+x\d+)?([+-]\d+[+-]\d+)?$/) {
	$mainWindow->geometry($opt_g);
    } else {
	warn "WARNING: bad geometry '$opt_g' - ignored\n";
	$opt_g = '';
    }
}
$mainWindow->title("$named");
$mainWindow->protocol('WM_DELETE_WINDOW', \&quit_program);	# Windows (X) pressed

########################################################################
#	Create and display an icon bitmap
########################################################################

my $icon = pack("b48" x 48,
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    ".................11111.................11111....",
    ".................11111.................11111....",
    ".....111.........111111...............111111....",
    "....11111........111111...............111111....",
    "...1111111.......1111111.............1111111....",
    "...1111111.......1111111.............1111111....",
    "...1111111.......11111111...........11111111....",
    "....11111........11111111...........11111111....",
    ".....111.........111111111.........111111111....",
    ".................111111111.........111111111....",
    ".................1111111111.......1111111111....",
    ".................11111.1111.......1111.11111....",
    ".................11111.11111.....11111.11111....",
    ".................11111..1111.....1111..11111....",
    "...111111........11111..11111...11111..11111....",
    "...111111........11111...1111...1111...11111....",
    "...111111........11111...11111.11111...11111....",
    "....11111........11111....111111111....11111....",
    "....11111........11111....111111111....11111....",
    "....11111........11111.....1111111.....11111....",
    "....11111........11111.....1111111.....11111....",
    "....11111........11111......11111......11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "....11111........11111.................11111....",
    "...1111111......1111111...............1111111...",
    "...1111111......1111111...............1111111...",
    "...1111111......1111111...............1111111...",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
);
$mainWindow->DefineBitmap('icon' => 48, 48, $icon);
$mainWindow->iconbitmap("icon");	# could use built in bitmap like "Tk" instead

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	Man Button
########################################################################
my $manMenu = $menuBar->Menubutton(-text               => 'man',
				   -relief             => 'raised',
				   -borderwidth        => 2,
				   -takefocus          => 1,
				   -highlightthickness => 1,
				   -tearoff            => 1,	# tear off line 0
				  )->pack(-side => 'left', -padx => 2);

$manMenu->command(-label       => 'Show in this window',		# 1
		   -accelerator => 'Return',
		   -command     => [ \&show_man, 0, undef, 0        ]); # overlay
$manMenu->command(-label       => 'Open a new window',			# 2
		   -accelerator => 'Alt-Ret',
		   -command     => [ \&show_man, 0, undef, 1        ]); # fork
$manMenu->command(-label       => 'Reload current page',		# 3
		   -accelerator => 'r',
		   -command     => [ \&show_man, 0, 2,     0        ]); # reload
$manMenu->command(-label       => 'Quit',				# 4
		   -accelerator => 'q',
		   -command     => [ \&quit_program                 ]);	# quit
$manMenu->separator();							# 5
my %manMenuEntries  = ();		# current valid menu entries
my $manMenuStart    = 6;		# first dynamic entry:		# 6
my $manMenuIndex    = 0;		# index of current menu entry
my $manMenuLen      = 0;		# current length of dynamic entries
my $manMenuLim      = 22;		# maximum number of dynamic entries
my $manMenuAge      = 0;		# allows deletion of oldest entry
my $manMenuInc      = -1;		# age direction (initially -1)

my %lastPageEntries = ();		# save last open man page
my $lastPageLim     = 1;		# maximum number of dynamic entries
my $lastPageAge     = 0;		# allows deletion of oldest entry
my $lastPageInc     = 1;		# age direction

########################################################################
#	Man entry window
########################################################################
my $entryMan = $menuBar->Entry(-width       => 16,
			       )->pack(-side => 'left', -padx => 2);

####### Man entry bindings #############################################
$entryMan->bind('<Key-Return>',		[ \&show_man, undef, 0        ]); # overlay
$entryMan->bind('<Alt-Key-Return>',	[ \&show_man, undef, 1        ]); # fork
$entryMan->bind('<Alt-Key-plus>',	[ \&change_font, 2            ]); # increase font
$entryMan->bind('<Alt-Key-minus>',	[ \&change_font, -2           ]); # decrease font
$entryMan->bind('<Alt-Key-r>',		[ \&show_man, 2, 0            ]); # Reload current manpage
$entryMan->bind('<Alt-Key-q>',		[ \&quit_program              ]);

########################################################################
#	Previous man page button
########################################################################
my $prevButton = $menuBar->Button(-text        => '<=',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -state       => 'disabled',
				  -command     => [ \&show_man, '', -1 ],	# Release-1
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Next man page button
########################################################################
my $nextButton = $menuBar->Button(-text        => '=>',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -state       => 'disabled',
				  -command     => [ \&show_man, '', 1 ],	# Release-1
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Headings menu
########################################################################
my $menu_headings = $menuBar->Menubutton(-text => 'Headings',
					 -relief => 'raised',
					 -borderwidth => 2,
					 -takefocus   => 1,
					 -highlightthickness => 1,
					)->pack(-side => 'left', -padx => 2);

########################################################################
#	Sections menu
########################################################################
my $menu_sections = $menuBar->Menubutton(-text => 'Sections',
					 -relief => 'raised',
					 -borderwidth => 2,
					 -takefocus   => 1,
					 -highlightthickness => 1,
					)->pack(-side => 'left', -padx => 2);
# Populate sections menu with keys of % sections
my $section_name;
foreach $section_name (sort keys %sections) {
    $menu_sections->command (
	     -label => "($section_name)",
	     -command => [\&show_section_contents, $section_name]);
}

########################################################################
#	Search button
########################################################################
my $searchButton = $menuBar->Button(-text        => '/',
				    -relief      => 'raised',
				    -borderwidth => 2,
				    -command     => [ \&search_text, 0, undef, 0 ],	# Release-1
				   )->pack(-side => 'left', -padx => 2);
$searchButton->bind('<ButtonPress-1>',	[ \&search_menu, \$searchButton, ]);		# Press-1

########################################################################
#	Search menu
########################################################################

my $searchMenu = $mainWindow->Menu();	# filled dynamically
my $searchTimer;
my $matchType = "-exact";		# default, alternatives 'g' -nocase -regexp or both ('ri')

$searchMenu->command(-label       => 'Search down',			# 1
		     -accelerator => 'Return',
		     -command     => [ \&search_text, 2, undef, 0 ]);
$searchMenu->command(-label       => 'Search up',			# 2
		     -accelerator => 'Shift-Ret',
		     -command     => [ \&search_text, 2, undef, 1 ]);
$searchMenu->command(-label       => 'Clear',				# 3
		     -accelerator => 'Ctrl-Ret',
		     -command     => [ \&search_text, 2, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$searchMenu->radiobutton(-label    => 'Go to line',			# 4
			 -accelerator => 'Alt-Ret',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 2 ]);
########################################################################
#	Exact match
########################################################################
$searchMenu->radiobutton(-label    => 'Exact match',			# 5
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Ignore case',			# 6
			 -value    => '-nocase',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp match',			# 7
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match - Ignore case
########################################################################
$searchMenu->radiobutton(-label    => 'Regexp Ignore case',		# 8
			 -value    => 'ri',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
$searchMenu->separator();						# 9
my %searchMenuEntries = ();		# current valid menu entries
my $searchMenuStart   = 10;		# first dynamic entry:		#10
my $searchMenuIndex   = 0;		# index of current menu entry
my $searchMenuLen     = 0;		# current length of dynamic entries
my $searchMenuLim     = 10;		# maximum number of dynamic entries
my $searchMenuAge     = 0;		# allows deletion of oldest entry
my $searchMenuInc     = -1;		# age direction (initially -1)

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 16,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom in button
########################################################################
$menuBar->Button(-text        => '-',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', -2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom out button
########################################################################
$menuBar->Button(-text        => '+',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', 2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Help button
########################################################################
$menuBar->Button(-text        => 'Help',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => \&show_help,
		)->pack(-side => 'right', -padx => 2);

########################################################################
#	Ini data for man and search menu lists
########################################################################
my %iniMenuData = (
    pages	=> [
	$manMenu->menu,		# menuRef,	man menu
	\%manMenuEntries,	# menuEntries,	current valid menu entries
	$manMenuStart,		# menuStart,	first dynamic entry
	\$manMenuIndex,		# menuIndex,	index of current menu entry
	\$manMenuLen,		# menuLen,	current length of dynamic entries
	$manMenuLim,		# menuLim,	maximum number of dynamic entries
	\$manMenuAge,		# menuAge,	age of current entry
	\$manMenuInc,		# menuInc,	age direction (initially -1)
	\&show_man,		# commandRef,	call back for history pages
    ],
    'last open page' => [
	0,			# menuRef,	no menu
	\%lastPageEntries,	# menuEntries,	save last open man page, value is line #
	0,
	0,
	0,
	$lastPageLim,		# menuLim,	maximum number of dynamic entries
	\$lastPageAge,		# menuAge,	age of current entry
	\$lastPageInc,		# menuInc,	age direction (initially -1)
	0,
    ],
    searches	=> [
	$searchMenu,		# menuRef,	search menu
	\%searchMenuEntries,	# menuEntries,	current valid menu entries
	$searchMenuStart,	# menuStart,	first dynamic entry
	\$searchMenuIndex,	# menuIndex,	index of current menu entry
	\$searchMenuLen,	# menuLen,	current length of dynamic entries
	$searchMenuLim,		# menuLim,	maximum number of dynamic entries
	\$searchMenuAge,	# menuAge,	age of current entry
	\$searchMenuInc,	# menuInc,	age direction (initially -1)
	\&search_text,		# commandRef,	call back for search text
    ],
);

my %matchExtensions = (
    -exact	=> '',
    -nocase	=> '	i',
    -regexp	=> '	r',
    ri		=> '	ri',
    g		=> '	g',
);
my %matchRestores = (
    e		=> '-exact',
    i		=> '-nocase',
    r		=> '-regexp',
    ri		=> 'ri',
    g		=> 'g',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom', -fill => 'x');

########################################################################
#	Text window
########################################################################
$text = $mainWindow->Scrolled('Text',
			      -scrollbars    => 'osoe',
			      -setgrid       => 2,
			      -background    => 'cornsilk1',
			      -wrap          => 'none',
			      -font          => $font,
			      -insertofftime => 0,
			     )->pack(-fill => 'both', -expand => 1);
unless ($opt_g) {
    $text->configure (-width  => $opt_w);	# will be ~85 if less because of $menuBar
    $text->configure (-height => $opt_l);
}

my $yScrollbar = $text->Subwidget('yscrollbar');
my $xScrollbar = $text->Subwidget('xscrollbar');

$text->configure (-cursor => 'left_ptr');
# Use xterm-color settings for attributes if available
my $colorUL = $text->cget (-foreground);
my $colorBD = $colorUL;
# foreach my $xrdb (`xrdb -q`) {
#     $xrdb =~ m/\*(colorBD|colorUL)\s*:\s*(\S+)/ || next;
#     $1 eq "colorBD" ? $colorBD : $colorUL = $2;
# }
$text->tagConfigure('heading', -font  => $boldfont,   -foreground => $colorBD);
$text->tagConfigure('bd',      -font  => $boldfont);
$text->tagConfigure('ul', -underline  => 1,           -foreground => $colorUL);
$text->tagConfigure('hy', -background => 'lightblue', -foreground => $colorUL);

####### Key and Mouse button bindings ##################################
####### Search entry bindings ##########################################
$entrySearch->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$entrySearch->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$entrySearch->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Double-1>',		[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$entrySearch->bind('<Key-Down>',		[ \&scroll_text, 1        ]); # scroll down
$entrySearch->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$entrySearch->bind('<Key-Next>',		[ \&scroll_text, $opt_l-2 ]); # next page
$entrySearch->bind('<Key-Prior>',		[ \&scroll_text,-$opt_l+2 ]); # prior page
$entrySearch->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$entrySearch->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$entrySearch->bind('<Alt-Key-r>',		[ \&show_man, 2, 0        ]); # Reload current manpage
$entrySearch->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$entrySearch->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
####### Text window bindings ###########################################
$text      ->bind('<Key-r>',			[ \&show_man, 2, 0        ]); # Reload current manpage
$text      ->bind('<Alt-Key-r>',		[ \&show_man, 2, 0        ]); # Reload current manpage
$text      ->bind('<Key-q>',			[ \&quit_program          ]);
$text      ->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$text      ->bind('<Button-1>',			[ \&report_cursor         ]); # report cursor position
$text      ->bind('<Double-1>',			[ \&pick_word, 0,         ]); # select a search word
$text      ->bind('<Control-Double-1>',		[ \&pick_word, 1,         ]); # follow a hyper-link
$text   ->tagBind('hy', '<Double-1>',		[ \&pick_word, 1,         ]); # follow a hyper-link
####### Y-Scrollbar bindings ###########################################
$yScrollbar->bind('<Key-p>',			[ \&show_man, -1, 0       ]); # previous history entry
$yScrollbar->bind('<Key-n>',			[ \&show_man, 1, 0        ]); # next history entry
$yScrollbar->bind('<Key-r>',			[ \&show_man, 2, 0        ]); # Reload current manpage
$yScrollbar->bind('<Key-h>',			[ \&show_help             ]);
$yScrollbar->bind('<Key-q>',			[ \&quit_program          ]);
$yScrollbar->bind('<Alt-Key-q>',		[ \&quit_program          ]);
$yScrollbar->bind('<Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Key-Right>',		[ \&scroll_x_text, 1      ]); # scroll right
$yScrollbar->bind('<Key-Left>',			[ \&scroll_x_text, -1     ]); # scroll left
$yScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$yScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
####### Search entry bindings ##########################################
$yScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$yScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$yScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$yScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$yScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$yScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### X-Scrollbar bindings ###########################################
$xScrollbar->bind('<Key-Down>',			[ \&scroll_text, 1        ]); # scroll down
$xScrollbar->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$xScrollbar->bind('<Key-Next>',			[ \&scroll_text, $opt_l-2 ]); # next page
$xScrollbar->bind('<Key-Prior>',		[ \&scroll_text, -$opt_l+2]); # prior page
$xScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$xScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
####### Search entry bindings ##########################################
$xScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$xScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$xScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear
$xScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$xScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$xScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### Useful line to determine Key binding symbols ###################
# $yScrollbar->bind('<KeyPress>' => sub { my $k =$Tk::event->K ; my $n = $Tk::event->N; info_display('black', "KeySym=$k, numeric=$n"); });
my $section = '';
my $sectionFlag = 0;
my $initialPage = '';
my $tail = '';

########################################################################
#	Analyse command line ARGV first unless $opt_r
########################################################################
unless ($opt_r) {
    if ($opt_k) {
	check_menu("-k $opt_k", 'pages');	# apropos: man -k <key>
	$initialPage = "-k $opt_k" unless $initialPage;
    }
    if ($opt_f) {
	check_menu("-f $opt_f", 'pages');	# whatis:  man -f <page>
	$initialPage = "-f $opt_f" unless $initialPage;
    }
    print "$named: \@ARGV '@ARGV'\n" if $opt_T;
  Arg:
    while (@ARGV) {
	my $man = shift @ARGV;
	while (1) {
	    if (is_valid_section($man)) {
		$section = $man;			# argumments: 1 man (classical man call)
		$sectionFlag = 1;
		next Arg;
	    }
	    elsif ($sectionFlag) {			# allows section 0
		check_menu("$man($section)", 'pages');
		$initialPage = "$man($section)" unless $initialPage;
		$sectionFlag = 0;
		$section     = '';
		next Arg;
	    }
	    elsif ($man =~ /^(\w+)\s+(\w[\w:+.-]*)(.*)$/) {
		$section = $1;
		$man     = $2;
		$tail    = $3;
		if (is_valid_section($section)) {
		    check_menu("$man($section)", 'pages');
		    $initialPage = "$man($section)" unless $initialPage;
		    $man = $tail;
		    next Arg unless $man;		# repeat with $tail
		} else {
		    check_menu($section, 'pages');
		    $initialPage = $section unless $initialPage;
		    $man .= $tail;
		    $tail = '';
		    next Arg unless $man;		# repeat with $tail
		}
	    }
	    else {
		$man =~ s/\s//g;			# remove all spaces
		check_menu($man, 'pages');
		$initialPage = $man unless $initialPage;
		next Arg;
	    }
	}
    }
    if ($sectionFlag) {
	info_display('red', "ERROR: last argument '$section' is a section");
	warn "ERROR: last argument '$section' is a section";
    }
}

########################################################################
#	Initialise program
#	set MAN_KEEP_FORMATTING to make 'man' output bold and underline codes
########################################################################
$ENV{MAN_KEEP_FORMATTING} = 1;	# set for duration of this execution
$ENV{MANWIDTH} = $opt_w;

ini_program();					# restore last session

if ($manMenuLen > 1 - $sectionFlag) {
    $nextButton->configure(-state => 'normal');
}

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################
$mainWindow->repeat(1000, sub {});	# do a few perl ops every second to catch signals
MainLoop();
exit(0);

####### End of main program ############################################

########################################################################
#	Catch miscellaneous signals
########################################################################

sub catch_sig {
    my $signame = shift;
    die "$named: Somebody sent me a SIG$signame: $!";
} # catch_sig

########################################################################
#
#	Display information on the info bar
#	(make sure all displays to info bar go via this routine)
#	Parameter 1:	colour (change if $message ne '')
#	Parameter 2:	message text
#
########################################################################

sub info_display {
    my ($colour, $message) = @_;
    $infoBar->configure(-foreground => $colour) if $message ne '';
    $info = $message;	# display now
} # info_display

########################################################################
#
#	Report the cursor position in the info bar
#
########################################################################

sub report_cursor {
    my $cursor = $text->index('insert');		# '27.0'
    $cursor =~ m/(\d+)\.(\d+)/;
    my $x = $2 + 1;
    print "report_cursor: cursor = $cursor line = '$1' char = '$x'\n" if $opt_T;
    info_display('black', "line $1, char $x");		# 'line 27 char 1'
} # report_cursor

########################################################################
#
#	Position window so that index is at its centre if possible
#	Parameter 1:	index into $text
#
########################################################################

sub seeCentre {
    my ($index) = @_;
    ########################################################################
    # re-compute window details in case text and/or window has changed
    ########################################################################
    $text->yview('moveto', 0);		# window to top left of text so bbox works
    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
    print "seeCentre: bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
    my $h = $text->height;		# current height of display window in pixels
    $height = int($h/$lineHeight);	# current height of display window in lines
    $index =~ /(\d+)\.(\d+)/;
    $y = int ($1 - ($height / 2));
    $y = 0 if $y < 0;
    $text->yview('moveto', $y / $lineCnt);
    $text->markSet('insert', $index);
    print "seeCentre: insert = $index moveto @{[$y/$lineCnt]}\n" if $opt_T;
} # seeCentre

########################################################################
#
#	Show a new manual page
#	parameter 1:	dummy for key bindings
#	parameter 2:	hFlag if not true use showEntry text
#			elsif 1  get next/previous history entry
#			elsif -1 get next/previous history entry
#			elsif 2  Reload current entry
#			else     entry is parameter 2
#	parameter 3:	forkFlag if true Shift-RETURN from show->bind (fork)
#
########################################################################

sub show_man {
    my ($dummy, $hFlag, $forkFlag) = @_;
    my ($entry, $man, $section, $cmdLine, $i, $s, $idx, $position);
    $lineCnt = 0;
no warnings;
    if ($opt_T) {
	my ($label, $n);
	my @menuItems = ();
	$n = 0;
	print "show_man:$lineCnt:\n";
	while ($n < $manMenuLen) {
	    $label = $manMenu->menu->entrycget($manMenuStart+$n, '-label');
	    push(@menuItems, $label);
	    print "$n	$label	age '$manMenuEntries{$label}[0]'	pos '$manMenuEntries{$label}[1]'\n";
	    $n++;
	}
    }
use warnings;
    if ($page) {
	$manMenu->menu->entryconfigure($page, -state, 'normal');
	$idx = $text->index('insert');
    }
    if ($hFlag) {
	if ($hFlag eq '1') {
	    if ($manMenuIndex >= $manMenuLen - 1) {
		info_display('red', "History exhausted");			# happens with 'n' key
		return;
	    }
	    $entry = $manMenu->menu->entrycget($manMenuStart+ ++$manMenuIndex, '-label');	# next history entry
	} elsif ($hFlag eq '-1') {
	    if ($manMenuIndex < 1) {
		info_display('red', "History exhausted");			# happens with 'p' key
		return;
	    }
	    $entry = $manMenu->menu->entrycget($manMenuStart+ --$manMenuIndex, '-label');	# previous history entry
	} elsif ($hFlag eq '2') {
	    $entry = $manMenu->menu->entrycget($manMenuStart+$manMenuIndex, '-label');	# reload history entry
	} else {
	    $entry = $hFlag;			# named menu command
	}
	print "show_man:$lineCnt: history entry: '$entry'\n" if $opt_T;
	$entryMan->delete('0', 'end');
	$entryMan->insert('end', $entry);
    } else {
	$entry = $entryMan->get();		# get entry from $entryMan
	print "show_man:$lineCnt: show entry: '$entry'\n" if $opt_T;
    }
    if ($entry =~ /^(-[fk]|\w+)\s+(\w[\w:+.-]*)/) {
	if ($1 eq '-k' or $1 eq 'apropos') {
	    ($opt, $man, $section) = ('-k ', $2, '');
	} elsif ($1 eq '-f' or $1 eq 'whatis') {
	    ($opt, $man, $section) = ('-f ', $2, '');
	} elsif (is_valid_section($1)) {
	    ($opt, $man, $section) = ('', $2, $1);
	} else {
	    ($opt, $man, $section) = ('', $2, '');
	}
    } elsif ($entry =~ /^(\w[\w:+.-]*)\s*(\((\w+)\))?/) {
	($opt, $man, $section) = ('', $1, $3);
    }
    if ($opt or not $section or not is_valid_section($section)) {
        $section = '';
    }
no warnings;
    if ($section) {
	$entry = "$opt$man($section)";
    } else {
	$entry = "$opt$man";
    }
    print "$entry: kopt = '$opt' man = '$man' section = '$section' forkFlag = '$forkFlag'\n" if $opt_T;
use warnings;
    if ($forkFlag) {			# hFlag cannot be set
	my @call = ($0, '-n', $man);
	$section = $opt if $opt;
	splice @call, 2, 0, $section if $section ne '';
	print "fork_and_exec(@call)\n" if $opt_T;
	fork_and_exec(@call);		# open the page in a new iCman window
	return;
    }
    # UI is clean now. Open the file
    ($s = $section) =~ s/[()]//g;	# remove parens (will pass '' unchanged)
    $cmdLine = $opt ? "man $opt $man 2>/dev/null | sort -u"	# output of apropos or whatis
		    : "man $s $man 2>/dev/null";
    my $encoding = ($Tk::VERSION >= 803) ? ":encoding(UTF-8)"
    					 : "";	# no UTF-8 for old version
    print "open (FH, \"-|$encoding\", $cmdLine)\n" if $opt_T;
    if (open (FH, "-|$encoding", $cmdLine)) {	# open pipe from man command
	if ($opt_M) {
	    open(MH, ">$opt_M") or die "Can't create debugging man file '$opt_M': $!";
	}
	my $lineFlag = 0;
	my ($line, $mark, $prev, $tag, $pos, $ppos, %atoms, $atom, $more, %tags, $len, @seq);
	while ($line = <FH>) {
	    print MH $line if $opt_M;
	    if ($lineFlag == 0) {
		########################################################################
		# First line - if open has error it reads a null file and never gets here
		# Erase everything to do with current page (contents, menus, marks)
		########################################################################
		$lineFlag = 1;
		$text->configure (-state  => 'normal');
		$text->configure (-cursor => 'watch' );
		$text->update();
		$menu_headings->menu()->delete(0,'end'); # Delete current headings
		foreach $mark ($text->markNames) {  # remove all marks
		    $text->markUnset($mark);
		}
		if ($searchText) {		# keep searchText
		    search_now(0, '', 1);	# clear search structures immediately
		}
		$text->delete('1.0', 'end');	# erase current page
		$prev = '';
		foreach $i (2, 3, 6, 7) {
		    $tagArray[$i]->[0] = '';	# no hyper-link in line 1
		}
	    }
	    if ($lineCnt == 1 or $lineCnt == 0 and $opt) {
		foreach $i (2, 3, 6, 7) {
		    $tagArray[$i]->[0] = 'hy';	# hyper-links if not line 1 or -k or -l
		}
	    } elsif (not $opt and eof(FH)) {
		foreach $i (2, 3, 6, 7) {
		    $tagArray[$i]->[0] = '';	# no hyper-link in last line unless -k or -l
		}
	    }
	    $mark = $line;
	    chomp $mark;
	    ########################################################################
	    # Squeeze multiple blank lines producing only one blank line.
	    ########################################################################
	    if ($mark eq '' and $prev eq '') {
		next;
	    }
	    $prev = $mark;
	    ########################################################################
	    # If first character is a capital letter, it's likely a Heading
	    # unless it is the first line (standard man heading)
	    ########################################################################
	    if ($lineCnt++ and not $opt and $line =~ s/^(\e\[(\d+)m)?([A-Z][\w :]*)(\e\[(\d+)m)?$/$3/) {
		# Likely a section heading
		print "show_man:$lineCnt: Heading: '$line'\n" if $opt_T;
		$mark = $line;			# $mark has section title
		$mark =~ s/.//g;		# take out possible bold and underline repeats
		chomp $mark;
		my $index = $text->index('end');	# note current end location
		# Give 'heading' tag to the Heading
		$text->insert('end', "$mark\n", 'heading');
		########################################################################
		# Create a menu entry. Have callback invoke text widget's
		# 'see' method to go to the index noted above (pass index in 1st parameter)
		########################################################################
		$menu_headings->command(-label   => $mark,
					-command => [ sub { seeCentre($_[0]) }, $index ],
				       );
	    } else {				# -k or -l or first line or not section heading
		########################################################################
		# State machine to convert Boldfacing, Underliningg with ^H to
		# ESC sequences
		########################################################################
		$ppos = -1;
		$more = 0;
		%atoms = ();
		$line =~ s/(.)(\1)*/$1/g;	# replace more than one .^H by one .^H
		while ($line =~ m/(.)(.)/g) {
		    $atoms{ length $` } = $1;	# each element has length 3
		}
		foreach $pos (sort { $a <=> $b } keys %atoms) {
		    $atom = $atoms{ $pos };	# process atoms in sequence
		    if ($pos != $ppos) {
			if ($ppos != -1) {
			    substr($line, $ppos + $more, 0) = "\e\[0m";	# stop Underline or Bold
			    $more += 4;
			}
			if ($atom eq "_") {
			    substr($line, $pos + $more, 2) = "\e\[4m";	# start Underline
			} else {
			    substr($line, $pos + $more, 2) = "\e\[1m";	# start Bold
			}
			$more += 2;
		    } else {
			substr($line, $pos + $more, 2) = "";
			$more -= 2;
		    }
		    $ppos = $pos + 3;
		}
		if ($ppos != -1) {
		    substr($line, $ppos + $more, 0) = "\e\[0m";		# stop final Underline or Bold
		    $more += 4;
		}
		########################################################################
		# Underlining, Boldfacing with ESC sequences
		#
		# ESC [ 1 m	start Bold
		# ESC [ 4 m	start Underline
		# ESC [ 0 m	stop Bold or underline or any other code
		# ESC [ 2 2 m	stop Bold in middle of line
		# ESC [ 2 4 m	stop Underline
		# 
		# Some man pages put the start Underline before a stop for a preceding
		# Bold resizefs(8):7. Allow any order.
		# Bolds and Underlines may be for any string lvextend(8):26. This is
		# difficult with a regex - another state machine is called for.
		########################################################################
		$ppos = -1;
		$more = 0;
		%atoms = ();
		%tags = ();
		@seq = ();
		$tag = 0;
		while ($line =~ m/(\e\[(\d+)m)/g) {
		    $atoms{ length $` } = [ length $1, $2 ];	# all ANSI SGR ESC sequences
		}
		########################################################################
		# remove ESC seqences from $line and mark in %tags with |= or &=
		# 1  ==> |= 1	start Bold
		# 4  ==> |= 4	start Underline
		# hy ==> |= 2	start hyper-link
		# 22 ==> &= ~1	stop Bold (may come after start Underline - so do not stop Underline)
		# 24 ==> &= ~4	stop Underline (ergo)
		# 0  ==> &= ~5	stop Bold and Underline
		# hy ==> &= ~2	stop hyper-link
		########################################################################
		$tags{ 0 } = 0;					# start line at $pos = 0 with no Bold/Undeline/hyper-link tag
		$tags{ length $line } = 0;			# finish at end of line with no Bold/Undeline/hyper-link tag
		foreach $pos (sort { $a <=> $b } keys %atoms) {
		    ($len, $atom) = @{ $atoms{ $pos } };	# process atoms in sequence
		    substr($line, $pos + $more, $len) = "";	# remove all ESC sequences
		    if ($atom == 0) {
			$tag = 0;				# no hyper-link yet - stop all ANSI ESC actions
		    } elsif ($atom <= 4) {
			$tag |= $atom;				# start Bold or Underline
		    } elsif ($atom == 22) {
			$tag &= ~1;				# stop Bold only
		    } elsif ($atom == 24) {
			$tag &= ~4;				# stop Underline only
		    } elsif ($opt_M) {				# 30-37 are colours - used in smb.conf(5)
			warn "WARNING: $lineCnt: bad ANSI ESC sequence 'ESC [ $atom m' for man page - ignored\n";
		    }
		    $tags{ $pos + $more } = $tag;		# maintains independent Bold and Underline tags
		    push(@seq, $pos + $more);			# allows retrieval of previous tag in position
		    $more -= $len;
		}
		print "HYPER-LINK LEN: @{[length $line]} '$line'\n" if $opt_T;
		push(@seq, length $line);			# have at least one entry higer than any hyper-link position
		########################################################################
		# Generate hyper-links in plain text and text with now removed ESCs
		# do not check for valid sections - whatis and apropos sometimes provide
		# invalid section names eg Tk::Text(3pm) which is really Tk::Text(3)
		#
		# interpolate hyper-links in %tags with previously generated ESC tags
		########################################################################
		$ppos = $pos = 0;
		while($line=~m/([A-Za-z][\w:+.-]*\s*\(\s*[pmn\d]*\s*\))/g) {
		    $len = length $`;
		    while ($pos <= $len) {
			$tags{ $pos } &= ~2 if $pos < $len; # update previous Bold/Underline tag with stop hyper-link
			$ppos = $pos;
			$pos = shift(@seq);		# first in first out
		    }
		    $tag = $tags{ $ppos };		# previous Bold/Underline tag
		    $tags{ $len } = $tag | 2;		# start hyper-link maintaining previous tag
		    print "HYPER-LINK ON : $lineCnt:\t\$len = $len\t\$tag = $tag ==> $tags{ $len }\t '$1'\t$ppos, $pos @seq\n" if $opt_T;
		    $len += length $1;
		    while ($pos <= $len) {
			$tags{ $pos } |= 2 if $pos < $len; # update previous Bold/Underline tag with start hyper-link
			$ppos = $pos;
			$pos = shift(@seq);		# first in first out
		    }
		    $tag = $tags{ $ppos };		# previous Bold/Underline tag
		    $tags{ $len } = $tag & ~2;		# stop hyper-link maintaining previous tag
		    print "HYPER-LINK OFF: $lineCnt:\t\$len = $len\t\$tag = $tag ==> $tags{ $len }\t '$1'\t$ppos, $pos @seq\n" if $opt_T;
		}
		########################################################################
		# Analyse %tags and output whole of man text with correct tags applied
		########################################################################
		foreach $pos (sort { $a <=> $b } keys %tags) {
		    if ($pos > 0) {
			$text->insert("end", substr($line, $ppos, $pos - $ppos), $tagArray[$tag]); # text with appropriate tag
			print "TEXT OUT      : $lineCnt:\t\$tagArray[$tag] = '@{$tagArray[$tag]}'\t $ppos $pos\t'@{[substr($line, $ppos, $pos - $ppos)]}'\n" if $opt_T;
		    }
		    $ppos = $pos;
		    $tag = $tags{ $pos };		# process atoms in sequence starting at $pos = 0
		}
	    }
	}
	close(MH) if $opt_M;
	close(FH);					# fails with $?/256 == 16 - page does not exist
	if ($lineFlag) {
	    $mainWindow->title("$named: $entry");
	    $text->configure (-cursor => 'left_ptr');
	    $text->update();
	    if (defined $manMenuEntries{$entry}) {
		$position = $manMenuEntries{$entry}[1];	# retrieve old postion
		if (defined $position and $position ne '' and $position ne '1.0') {
		    $text->see($position);		# Tk has segmentation fault if $position eq ''
		} else {
		    $position = '1.0';
		}
	    } else {
		$position = '1.0';			# or show top of page
	    }
	    $text->markSet('insert', $position);
	    $manMenuEntries{$page}[1] = $idx if $page;	# save postion for page just overwritten
	    check_menu($entry, 'pages');		# also enter into menu if new; adjust age for repeat
	    $page = $entry;
no warnings;
	    if ($section) {
		info_display('blue', "Loaded $opt $man($section) $lineCnt lines");
	    } else {
		info_display('blue', "Loaded $opt $man $lineCnt lines");
	    }
use warnings;
	} else {
	    check_menu($entry, 'pages', 1);		# delete menu $entry
	    $entry = $page;				# restore current entry after not finding new entry
	    if ($section) {
		info_display('red', "No manual entry for $opt $man($section)");
	    } else {
		info_display('red', "No manual entry for $opt $man");
	    }
	}
	if ($entry) {
	    $manMenu->menu->entryconfigure($entry, -state, 'disabled');
	    $manMenuIndex = $manMenu->menu->index($entry) - $manMenuStart;
	    print "show_man:$lineCnt: showing '$entry' index $manMenuIndex length = $manMenuLen\n" if $opt_T;
	}
	if ($manMenuIndex < $manMenuLen - 1) {
	    $nextButton->configure(-state => 'normal');
	} else {
	    $nextButton->configure(-state => 'disabled');
	}
	if ($manMenuIndex > 0) {
	    $prevButton->configure(-state => 'normal');
	} else {
	    $prevButton->configure(-state => 'disabled');
	}
	$entryMan->delete('0', 'end');
	$entryMan->insert('end', $entry);
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
    } else {
	info_display('red', "open (FH, \"-|$encoding\", $cmdLine) failed ($?)");
    }
} # show_man

########################################################################
#
#	Check for a valid section
#
########################################################################

sub is_valid_section {
    my $section = $_[0];
    my $s;
    foreach $s (keys %sections) {
	if (lc($s) eq lc($section)) {
	    return 1;
	}
    }
    return 0;
} # is_valid_section

########################################################################
#
#	Pick a word for starting a search or following a hyper-link
#	parameter 1:	dummy for key bindings
#	Parameter 2:	0 start a search
#			1 use word as a hyper-link to open a new page
#
########################################################################

sub pick_word {
    my ($dummy, $flag) = @_;
    my $cursor = $text->index('insert');		# '27.0'
    my $start_index = $text->index('insert wordstart');
    my $end_index = $text->index('insert lineend');
    my $line = $text->get($start_index, $end_index);
    print "pick_word: flag = $flag start_index = $start_index end_index = $end_index line = '$line'\n" if $opt_T;
    if ($flag == 0) {				# mouse double-click 1
	if ($pickFlag) {
	    $pickFlag = 0;
	    return;
	}
	$line =~ m/^([\w.]+)/;
	if (defined $1) {
	    print "pick_word: word = '$1'\n" if $opt_T;
	    $entrySearch->focus();		# initiate search entry
	    search_now(2, $1, 0);		# search for first word only
	}
    } else {					# mouse control-double-click 1
	my ($manPage, $dummy, $section) = ($line =~ /^(\w[\w:+.-]*)(\s*\(\s*(\w+)\s*\))?/);
no warnings;
	print "pick_word: page = '$manPage' section = '$section'\n" if $opt_T;
use warnings;
	if ($manPage) {
	    $entryMan->delete('0', 'end');
	    if ($section) {
		$entryMan->insert('end', "$manPage($section)");
	    } else {
		$entryMan->insert('end', $manPage);
	    }
	    show_man();
	    $pickFlag = 1;
	}
    }
} # pick_word

########################################################################
#
#	Show section contents
#
########################################################################

sub show_section_contents {
    my $current_section = $_[0];
    if (exists $sections{$current_section}) {
	$text->configure(-state => 'normal');
	$text->delete('1.0', 'end');
	$menu_headings->menu()->delete(0,'end');
	my $spaces = " " x 40;
	my $words_in_line = 0;  # New line when this goes to three
	my ($man, $l);
	foreach $man (@{$sections{$current_section}}) {
	    $text->insert('end', $man, 'hy');	# hyper-link can be selected by Button-1
	    if (++$words_in_line  < 3) {
		$text->insert('end', substr($spaces,0, (($l = length($man)) < 24) ? 24 - $l : 1));
	    } else {
		$text->insert('end', "\n");
		$words_in_line = 0;
	    }
	}
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
    }
} # show_section_contents

########################################################################
#
#	Scout the man directories for section names
#
#	Since this may take some time, particularly if the system is busy,
#	the result of the scan is cached in ~/.iC/iCman.sec.
#	A full scan is carried out each new day. This should be sufficient
#	to catch any new man entries. Alternetively 'iCman -c' may be used
#	to build a new cache after new software has been installed.
#
########################################################################

use Cwd;
sub scout_man_dirs {
    my (@man_dirs, $man_dir, $section, $home);
    my @date = split ' ', `date`;	# get current system date
    my $newDate = join ' ', @date[0..2];# keep date part only
    if (($home = $ENV{HOME}) ne '' and	# restore section lists from ~/.iC/iCman.sec
	not $opt_c and			# $home must be set before $opt_c is tested
	(-d "$home/.iC" or mkdir "$home/.iC") and
	open(INI, "$home/.iC/$named.sec")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$section = $1;			# section found
		if ($section =~ /DATE (.*)/) {
		    my $oldDate = $1;
		    $section = '';
		    if ($newDate ne $oldDate) {
			close(INI);
			goto NewCache;
		    }
		}
	    } elsif ($section and /^\t/) {	# ini starts with <tab>
		my @new_list = split;		# all sections in one line
		$sections{$section} = \@new_list;
	    }
	}
	close(INI);
	return;				# use cache values
    }					# ignore if ~/.iC/iCman.sec cannot be opened or found or -c
  NewCache:
    %sections = ();			# start filling cache
    print STDERR "Scouting man directories\n";
    if ($ENV{MANPATH}) {
        @man_dirs = split (/:/, $ENV{MANPATH});
    } elsif (-x '/usr/bin/manpath') {
	$man_dir = `/usr/bin/manpath -q`;
	chomp $man_dir;
	print "/usr/bin/manpath -q returns '$man_dir'\n" if $opt_T;
        @man_dirs = split (/:/, $man_dir);
    } else {
        push (@man_dirs, "/usr/local/man");
    }
    print "\@man_dirs = '@man_dirs'\n" if $opt_T;
    # Convert all relative man paths to fully qualified ones, by
    # prepending with $cwd
    my $cwd = cwd();
    foreach $man_dir (@man_dirs) {
        next if ($man_dir =~ m|^/|);
        $man_dir = "$cwd/$man_dir"; # Modifies entry in man_dirs
    }
    foreach $man_dir (@man_dirs) {
	print "\$man_dir = '$man_dir'\n" if $opt_T;
        chdir $man_dir || next;
        # Now, in /usr/man, say. Get all the directories
        my @section_dirs = grep {-d $_} <man*>;
        my $section_dir;
        # @section_dirs has man1, man2, man3s etc.
        foreach $section_dir (@section_dirs) {
            chdir $section_dir || next;
            ($section = $section_dir) =~ s/^man//;
            push (@{$sections{$section}}, <*.$section*>);
            chdir "..";
        }
        chdir "..";
    }
    # All sections in all man pages have been slurped in. Remove duplicates
    foreach $section (keys %sections) {
        my @new_list;
        my %seen;
        @new_list = sort (grep (!$seen{$_}++, @{$sections{$section}}));
        # Change all entries like cc.1 to cc(1)
        foreach (@new_list) {
            $_ =~ s/[.](.*)/($section)/;
        }
        $sections{$section} = \@new_list;
    }
    ## save section lists to ~/.iC/iCman.sec
    if ($home ne '') {
	if (open(INI, ">$home/.iC/$named.sec")) {
	    print INI "[DATE $newDate]\n";	# date stamp in section file
	    foreach $section (sort keys %sections) {
		my @new_list = @{$sections{$section}};
		print INI "[$section]\n\t@new_list\n";
	    }
	    close(INI);
	} else {
	    warn "ERROR: Can't open ~/.iC/$named.sec: $!\n";
	}
    }
    print STDERR "Starting UI ...\n";
} # scout_man_dirs

########################################################################
#
#	Pop up search menu from search button after 200 ms
#
########################################################################

sub search_menu {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	my $xWin = $mainWindow->rootx;
	my $yWin = $mainWindow->rooty;
	print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	$searchTimer = $mainWindow->after(200,
	    sub { $searchMenu->post($xWin + 412, $yWin +  32); });
    }
    print "Raise search menu in 200 ms '$buttonText' '$buttonState'\n" if $opt_T;
} # search_menu

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from
#		eg: bind('<KeyPress-Return>', [ \&search_text, undef, 0 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first parameter when called directly.
#	Use this is buttonFlag.
#
#		parameter 1:	buttonFlag - false (0) when [/] release else true
#		    "		if 1 matchType is provided by call
#		    "		if 2 or higher matchType is exact if new searchText
#		parameter 2:	newSearchText
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up	(save searchText when clearing)
#		    "		2  Go to line
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
########################################################################

sub search_text {
    my ($buttonFlag, $newSearchText, $direction) = @_;
no warnings;
    print "search_text: \$buttonFlag = '$buttonFlag' \$searchText = '$searchText'\n" if $opt_T;
use warnings;
    unless ($buttonFlag) {
	########################################################################
	#   Cancel search menu from search button if released before 200 ms
	#   are up or mouse pointer has not moved off [/] button
	########################################################################
	$searchMenu->unpost();			# do this first - no delays yet
	$searchTimer->cancel() if defined $searchTimer;
	print "Cancel raising search menu\n" if $opt_T;
	if (not defined $searchText or $searchText eq '') {
	    $entrySearch->focus();		# initiate search entry (simulates vi)
	    return;
	}
    }
    $text->after(0, [ \&search_now, @_ ]);	# allow pop up to go away
} # search_text

sub search_now {
    my ($buttonFlag, $newSearchText, $direction) = @_;
    my ($saveText, $saveMatch, $option, $match, $auxiliary, $current, $hl, $length, $tmpText);
    if (defined $newSearchText) {
	if ($newSearchText eq '' and $direction) {	# save search text when clearing with change of page
	    ($saveText, $saveMatch) = ($searchText, $matchType);
	}
	($searchText, $option) = split(/\t/, $newSearchText);
	$searchText = '' if not defined $searchText;	# $searchText comes from Entry widget
	$match = $option ? $matchRestores{$option} : '-exact';
    } else {
	$match = ($buttonFlag eq '1')		       ? $matchType :
		 ($searchText eq $prevText)	       ? $prevMatch :
		 ($searchText =~ /(^\^|\\[^0aefnrt])/) ? '-regexp'  : '-exact';	# change of text
	$matchType = $match;				# restore radio button
    }
    $text->tagDelete('gotoTag');
    while ($direction == 2 or $match eq 'g') {	# really if() {.. last; ..}
	########################################################################
	##	Go to line $searchText (do exact match search if not numeric)
	########################################################################
	if ($searchText eq '') {
	    $searchText = $current = "1.0";
	} elsif ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    $match = '-exact';	# try exact match - most likely
	    last;
	}
	print "goto: '$searchText' '$current' '$match $direction\n" if $opt_T;
	$match = 'g';
	$text->see($current);
	$text->tagConfigure('gotoTag',
			    -background => 'grey',
			    -foreground => 'black',
			   );		# must be called again after tagDelete
	$text->tagAdd('gotoTag', "$current linestart", "$current lineend");
	$text->markSet('insert', $current);
	$text->tagLower('gotoTag');	# put any search results in foreground
	report_cursor();
	$tmpText = "$searchText$matchExtensions{$match}";
	check_menu($tmpText, 'searches');
	$prevText = $searchText;
	$prevMatch = $match;
	return;
    }
    if ($prevText ne $searchText or $prevMatch ne $match) {
	########################################################################
	#	Start of a new search
	########################################################################
	print "pattern: '$searchText' '$match'\n" if $opt_T;
	@hits = ();
	@groups = ();
	$gl = 0;
	$text->tagDelete('searchTag') if $prevText;	# also for clear search
	$text->tagConfigure('searchTag',
			    -background => 'black',	# same as 'less'
			    -foreground => 'white',
			   );		# must be called again after tagDelete
	if ($match eq 'ri') {
	    $match = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';

	########################################################################
	#	Actual searches storing results in @hits
	#	for every hit set a tag
	########################################################################
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,
					 $match,
					 $auxiliary,
					 '--',
					 $searchText,
					 $current,	# start index
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display('red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;		# ends with length 0 for clear search
	    if ($opt_T) {
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length $current\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    $current =~ /(\d+)\.(\d+)/;
	    push @hits, [ $current, $1, $2, $length, ];
	    $current = $text->index("$current + $length char");	# point bejond hit
	}
	$matchType = 'ri' if $auxiliary eq '-nocase';	# otherwise radio button skips
	if (($hl = scalar @hits) > 0) {
	    ########################################################################
	    # re-compute window details in case text and/or window has changed
	    ########################################################################
	    $text->yview('moveto', 0);		# window to top left of text so bbox works
	    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
	    print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
	    my $h = $text->height;		# current height of display window in pixels
	    $height = int($h/$lineHeight);	# current height of display window in lines
	    $tmpText = "$searchText$matchExtensions{$match}";
	    check_menu($tmpText, 'searches');
	    ########################################################################
	    #	Analyse hits and group them into display groups.
	    #   Pseudo_code for new algorithm (August 2009).
	    #
	    #	The previous 2 algorithms were much longer.
	    #	They actually missed showing some hits under some circumstances.
	    ########################################################################
	    my $endm = $text->index('end');
	    $endm =~ m/(\d+)\.(\d+)/;
	    $lineCnt = $1 - 1;			# current length of text in lines
	    my $groupFirst = undef;
	    my $prevGroupHeight = 0;
	    my ($groupHeight, $groupTop, $aRef);
	    while (($aRef = shift @hits)) {
		($current, $y, $x, $length) = @$aRef;
		if (defined $groupFirst) {
		    if (($groupHeight = $y - $groupFirst) >= $height) {
			$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
			$groupTop = 0 if $groupTop < 0;
			push @groups, $groupTop / $lineCnt;
			$groupFirst = $y;	# start of new group
			$prevGroupHeight = 0;
		    } else {
			$prevGroupHeight = $groupHeight;
		    }
		} else {
		    $groupFirst = $y;		# first item in search
		}
	    }
	    if (defined $groupFirst) {
		$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
		$groupTop = 0 if $groupTop < 0;
		push @groups, $groupTop / $lineCnt;
	    }

	    $gi = -1;				# see index
	    $gl = scalar @groups;
	    my $plural = $gl > 1 ? 's' : '';
	    info_display('dark green', "/$searchText/ found $hl times in $gl group$plural");
	}
	$prevText = $searchText;
	$prevMatch = $match;
	$entrySearch->focus();
    }
    ########################################################################
    #	Use @groups to scroll over the groups forwards or backwards.
    #	Initial group index is $gi = -1. Used to determine scroll start for
    #	immediate backward scroll.
    #	Even for a single group, re-position group every time RETURN is pressed,
    #	because the hits could have been moved by manual scrolling.
    ########################################################################
    if ($gl > 0) {
	my $infoFlag = ($gi < 0 or $gl < 2) ? 0 : 1;	# allows search statistics info to stay
	if (not $direction) {
	    $gi++;			# forward scroll
	    if ($gi >= $gl) {
		$gi = 0;
		if ($infoFlag) {
		    info_display('dark red', "search hit BOTTOM, continuing at TOP");
		    $infoFlag = 0;
		}
	    }
	} else {
	    $gi--;			# backward scroll
	    if ($gi < 0) {
		if ($infoFlag and $gi == -1) {	# -2 is first time backwards
		    info_display('dark red', "search hit TOP, continuing at BOTTOM");
		    $infoFlag = 0;
		}
		$gi = $gl - 1;
	    }
	}
	if ($infoFlag) {
	    info_display('black', '');	# clears display_info
	}
	$text->yview('moveto', $groups[$gi]);	# move forward or backward to next group
	$current = int($lineCnt * $groups[$gi] + ($height / 2) + 1);
	$text->markSet('insert', "$current.0");
	print("moveto line $current.1\n") if $opt_T;
    } elsif ($gl == 0 and not $@) {	# do not overwrite search eval error message
	if ($searchText ne '') {
	    info_display('red', "/$searchText/ not found");	# report every time
	} else {
	    info_display('dark red', "search cleared");
	    $yScrollbar->focus();
	}
    }
    if ($saveText) {
	($searchText, $matchType) = ($saveText, $saveMatch);
    }
} # search_now

########################################################################
#
#	Start a new search with / or ALT-/ to simulate vi
#
########################################################################

sub new_search {
    print "new_search\n" if $opt_T;
    $searchText = '';		# clears search entry window
    search_text(0, '', 0);	# puts focus in search entry window
} # new_search

########################################################################
#
#	Scroll text left or right with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_x_text {
    my ($dummy, $increment) = @_;
    print "scroll_x increment = '$increment'\n" if $opt_T;
    $text->xview('scroll', $increment, 'units');
} # scroll_x_text

########################################################################
#
#	Scroll text up or down with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_text {
    my ($dummy, $increment) = @_;
    print "scroll increment = '$increment'\n" if $opt_T;
    $text->yview('scroll', $increment, 'units');
    $text->markSet('insert', "insert + $increment lines");
    report_cursor();
} # scroll_text

########################################################################
#
#	Position text Home or End
#
########################################################################

sub position_text {
    my ($dummy, $pos) = @_;
    print "scroll position = '$pos'\n" if $opt_T;
    $text->see($pos);
    $text->markSet('insert', $pos);
} # position_text

########################################################################
#
#	Increase or decrease font size
#
#	change normal text font (includes underline text)
#	change 'heading' text which is bold
#	change 'bd' tagged words which are bold
#	do not change miscellanous button text fonts
#
########################################################################

sub change_font {
    my ($dummy, $increment) = @_;
    $fontSize += $increment;			# initial or new fontSize
    if ($fontSize < 8 || $fontSize > 22) {
	$fontSize -= $increment;		# keep fontSize within limits
    } else {
	print "font increment = '$increment' size = '$fontSize'\n" if $opt_T;
	$font       = $font_t;
	$boldfont   = $boldfont_t;
	$font       =~ s/fontSize/$fontSize/;	# no change if -F was a specified font
	$boldfont   =~ s/fontSize/$fontSize/;
	if ($increment) {
	    $text->configure(-font => $font);	# re-configure only for changed fonts
	    $text->tagConfigure('heading', -font => $boldfont, -foreground => $colorBD);
	    $text->tagConfigure('bd',  -font => $boldfont);
	    info_display('black', "font size $fontSize");
	}
    }
} # change_font

########################################################################
#
#	Help man page
#
########################################################################

sub show_help {
    show_man(0, "$named(1)", 0);
} # show_help

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Fork initial window to background
#
########################################################################

sub to_background {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid = fork;
    if ($pid < 0) {
	warn "Unable to run in the background, cannot fork: $!\n";
	exit $?;
    }
    exit 0 if $pid;	# exit foreground which started the program
} # to_background

########################################################################
#
#	check_menu (newEntry, menuKey[, delete])
#	Enter a new value into a particular menu
#	    iniMenuData{menuKey} ==> [
#		menuRef,	# [0]	menu reference
#		menuEntries,	# [1]	current valid menu entries
#		menuStart,	# [2]	first dynamic entry
#		menuIndex,	# [3]	index of current menu entry
#		menuLen,	# [4]	current length of dynamic entries
#		menuLim,	# [5]	maximum number of dynamic entries
#		menuAge,	# [6]	age of current entry
#		commandRef,	# [7]	call back for menu entries
#	    ]
#	'newEntry' is entered unto the 'menuKey' menu and %$menuEntries, which
#	stores the $menuAge, which is incremented every time check_menu is called.
#	The fact that %$menuEntries holds an entry also signifies that it is
#	a valid menu entry. There is a limit to the number of entries in a menu
#	held in $menuLim. When this number of entries is exceeded the 'oldest'
#	entry is deleted using the age in %$menuEntries.
#
#	when 'delete' is set, 'newEntry' in the menu is deleted
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey, $delete) = @_;
    my $menuData = $iniMenuData{$menuKey};
    my ($menuRef, $menuEntries, $menuStart, $menuIndex, $menuLen, $menuLim,
	$menuAge, $menuInc, $commandRef) = @$menuData;
    $$menuAge += $$menuInc;				# initial age direction is -1, later +1
    print "check_menu: *** [$menuKey] '$newEntry' age = $$menuAge\n" if $opt_T;
    if (defined $$menuEntries{$newEntry}) {
	if ($delete) {
	    print "check_menu: [$menuKey] '$newEntry' deleted in '$menuEntries'\n" if $opt_T;
	    delete $$menuEntries{$newEntry};		# hash entry deleted
	    $menuRef->delete($newEntry);		# menu entry deleted (no regex - only delete pages)
	    $$menuLen--;				# decrease menu length (must be at least 1)
	} else {
	    $$menuEntries{$newEntry}[0] = $$menuAge;	# entry and age recorded for repeat
	    print "check_menu: [$menuKey] $newEntry	age = '$$menuAge'	pos = '$$menuEntries{$newEntry}[1]'\n" if $opt_T;
	}
    } elsif (not $delete) {
	$$menuEntries{$newEntry} = [$$menuAge, '1.0'];	# entry, age and pos recorded for new
	if ($menuRef and $commandRef) {			# menu for 'file' and 'searches' not 'last open file'
	    print "check_menu: \$menuRef=$menuRef ->insert($menuStart + @{[$$menuIndex+1]}, 'command',
		-label=>'$newEntry',-command=>['$commandRef',2,'$newEntry',0]) age = $$menuAge\n" if $opt_T;
	    $menuRef->insert($menuStart + ($$menuInc < 0 || $menuKey ne 'searches' ? ++$$menuIndex : 0),
			     'command',
			     -label   => "$newEntry",	# must use local $newEntry below
			     -command => [ $commandRef, 2, $newEntry, 0 ]); # define 0 (down for search)
	    if ($$menuLen < $menuLim) {
		$$menuLen++;				# increase menu length
	    } else {
		########################################################################
		#   delete oldest menu entry
		########################################################################
		my ($keyEntry, $keyAge, $entry, $age);
		$age = 0x7fffffff;			# LARGE
		foreach $keyEntry (keys %$menuEntries) { # no need to sort
		    $keyAge = $$menuEntries{$keyEntry}[0];
		    if ($keyAge < $age) {
			$age    = $keyAge;
			$entry  = $keyEntry;
		    }
		}
		print "check_menu: \$menuRef=$menuRef ->delete($entry) age = $age\n" if $opt_T;
		delete $$menuEntries{$entry};		# hash entry deleted
		if ($entry =~ m/\tri?$/) {
		    $entry =~ s/([\^\\|()\[\]{}\$*+?.])/\\$1/g;	# regex matched against -label
		}
		$menuRef->delete($entry);		# menu entry deleted
	    }
	}
    }
} # check_menu

########################################################################
#
#	Initialise the program by reading ~/.iC/iCman.ini if it exists
#	and initialising pages list and search list in menus
#	If there are no man arguments, open the last open man page
#	ELSE	open the first man page in the argument list
#		add any others to the man menu list
#
#	structure of ~/.iC/iCman.ini
#	[last open page]
#		iCserver	27.4	# last_open_file<tab>line #
#	[pages]
#		iCserver
#		immcc
#		-k immediate
#	[searches]
#		pip			# default match type is -exact
#		[files]			# a curious -exact match
#		timer		i	# match type -nocase (<tab>i)
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		ix[\d+]\.[\d+]	ri	# resolved to -regexp -nocase (<tab>ri)
#
#	since tabs cannot be entered in the search entry box (skips to Text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($menuData, $menuKey, $laterPage, $pos, $home, $n);
    ########################################################################
    #   restore file and search menu lists from ~/.iC/iCman.ini
    ########################################################################
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC") and
	open(INI, "$home/.iC/$named.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniMenuData{$menuKey};
		print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
		$n = $menuData ? $$menuData[5] : 0;
		if ($menuKey eq 'pages') {
		    $n -= scalar @ARGV;		# $manMenuLim - argument count
		}
	    } elsif ($n-- > 0 and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		check_menu($_, $menuKey);	# insert dynamic entries from ini file
	    }
	}
	close(INI);
    }	# ignore if ~/.iC/iCman.ini cannot be opened or found
    if ($initialPage eq '') {
	($laterPage) = keys %lastPageEntries;	# may be empty
	if (defined $laterPage) {
	    print "ini_program: \$laterPage = '$laterPage' keys \%lastPageEntries = '@{[keys %lastPageEntries]}'\n" if $opt_T;
	    $laterPage =~ s/([^\t]+)(\t(.*))?/$1/;
	    $initialPage = $laterPage;
	    $pos = $3;
	    if (defined $pos and $pos !~ /^\d+\.\d+$/) {
		$pos = undef;
	    }
	}
    }
    foreach $laterPage (@ARGV) {
	check_menu($laterPage, 'pages');	# stuff the rest in the pages menu list
    }
    $manMenuIndex    = 0;			# enter new menu entry at the top
    $manMenuAge      = $manMenuLim;		# allows deletion of oldest entry from now on
    $manMenuInc      = 1;			# age direction now +1
    print "ini_program: manMenuIndex = '$manMenuIndex' manMenuAge = '$manMenuAge' manMenuInc = '$manMenuInc'\n" if $opt_T;
    $searchMenuIndex = 0;			# enter new menu entries at the top
    $searchMenuAge   = $searchMenuLim;		# allows deletion of oldest entry from now on
    $searchMenuInc   = 1;			# age direction now +1
    print "ini_program: searchMenuIndex = '$searchMenuIndex' searchMenuAge = '$searchMenuAge' searchMenuInc = '$searchMenuInc'\n" if $opt_T;
    if ($initialPage ne '') {
no warnings;
	print "ini_program: initialPage = '$initialPage' position = '$pos'\n" if $opt_T;
use warnings;
	show_man(0, $initialPage, 0);
	if (defined $pos and $pos ne '' and $pos ne '1.0') {
	    $text->see($pos);			# Tk has segmentation fault if $pos eq ''
	} else {
	    $pos = '1.0';
	}
	$text->markSet('insert', $pos);
    }
} # ini_program

########################################################################
#
#	Quit program after checking if file needs saving
#	and current history and search menu lists have been written
#
########################################################################

sub quit_program {
    my $dialog = $text->Dialog (-title   => 'Quit',
				-bitmap  => 'question',
				-text    => 'Really quit?',
				-default_button => 'No',
				-buttons => [qw(Yes No)],
			       );
    my $answer = $dialog->Show(
	    -popover => $mainWindow,
	    -overanchor => 'c',
	    -popanchor => 'nw',
	    -takefocus => 1);
    print "$named: answer is '$answer'\n" if $opt_T;
    if ($answer ne 'Yes') {
	return;				# cancel operation
    }
    my ($menuKey, $menuData, $entry, $home);
    my ($menuRef, $menuEntries, $menuStart, $menuIndex, $menuLen, $menuLim,
	$menuAge, $menuInc, $commandRef);
    %lastPageEntries = ();		# in case not fully shifted in ini_program
    if (defined $page and $page ne '') {
	my $insert = $text->index('insert');
	$lastPageEntries{"$page\t$insert"}++;
    }
    print "$named: quit_program: page = '$page' lastPageEntries = '@{[keys %lastPageEntries]}'\n" if $opt_T;
    ########################################################################
    #   Save all menu lists to ~/.iC/iCman.ini
    ########################################################################
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC" or mkdir "$home/.iC") and
	open(INI, ">$home/.iC/$named.ini")) {
	foreach $menuKey (sort keys %iniMenuData) {
	    print INI "[$menuKey]\n";
	    print "$named: quit_program: INI: [$menuKey]\n" if $opt_T;
	    ########################################################################
	    #   Output current menu entries to INI file in age order youngest first
	    ########################################################################
	    $menuData = $iniMenuData{$menuKey};
	    ($menuRef, $menuEntries, $menuStart, $menuIndex, $menuLen, $menuLim,
		$menuAge, $menuInc, $commandRef) = @$menuData;
	    foreach $entry (sort {$$menuEntries{$b}[0] <=> $$menuEntries{$a}[0]} keys %$menuEntries) {
		print INI "\t$entry\n";
		print "$named: quit_program: INI:	$entry\n" if $opt_T;
	    }
	}
	close(INI);
    } else {
	warn "ERROR: Can't open ~/.iC/$named.ini: $!\n";
    }
    print "$named: quit\n" if $opt_T;
    $mainWindow->destroy();
    exit(0);
} # quit_program
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCman - an interface to the on-line reference manuals

=head1 SYNOPSIS

 iCman[ -cnrTh][ -k <key>][ -f <page>][ -F <font>][ -l <num>][ -w <num>]
      [ -g <geometry>][ -M <file>][ [<section>] <manpage> ...] ...
    -k key  display the output of man -k <key> (apropos) which provides
            man page links to the topic described by <key>.
    -f page display the output of man -f <page> (whatis)
    -F font font or font size to use in Text window (default '18')
    -l num  height of the Text window (default 35)
    -w num  width  of the Text window (default 85) -w0 is terminal width
    -g geom geometry for main window
    -c      build a new cache of section names (default: use cache)
    -n      no fork of initial window (used in internal fork call)
            (default is to fork the initial window)
    -r      restore last session with manpage and search history
    -T      trace output static debug messages
    -M file store output of man command in file for debugging
            warn about unusual ANSI ESC codes
    -h      help, ouput this Usage text only

    Manpage arguments may be of the form <section> <manpage>, which is
    the classical call for 'man'. <manpage>(<section>) may be used as
    an alternative, but this form must be quoted for the shell.  In
    either case <section> must be a valid section name.

    One or more manpage arguments may be used - these are placed in
    the history. If no manpage arguments are specified or if the -r
    option is used, the last session is restored with all its manpage
    and search history. The first manpage in the history is opened.
    This is either the first manpage argument or the first manpage
    in the previous session history.

 Menu buttons:                   Action                      Accelerator

    [man] ----- tear-off - menu can be moved and left open
       Show     a new manpage - in this window                   RETURN
                (followed by an optional section in parentheses)
                Alternatively show a list of topics matching a key
                with '-k <key>' or 'apropos <key>' entered in the
                show window or '-f <page>' or 'whatis <page>'
                Double-clicking on a hyper-link (pale blue) in
                the main text will also open that page
       Open     a new window - to show selected manpage         Alt-RET
       Reload   the current manpage (usually modified externally)   r
       Quit     the program                                         q
       -------- this is followed by a history of previous pages,
                which can be selected randomly

    [ <= ]      Load the previous manpage in the history            p
    [ => ]      Load the next manpage in the history                n

    [Headings]  Skip to one of the headings in the manpage
    [Sections]  Load the index for one of the manpage sections

    [ / ]       Put focus in Search Entry window if cleared.        /
                    (simulates vi)                            or  Alt-/
                Else start or continue a search of text in
                the Search Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options
       Search down      or                                       RETURN
                displays a new group of hits
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits
       Clear            or double-click Search Entry window or Ctrl-RET
                clears hits and the Search Entry window
     <>Go to line       or                                      Alt-RET
                goes to the line entered in the Search Entry window
     <>Exact match
     <>Ignore case
     <>Regexp match
     <>Rgexp+ignore case
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Help]      Display this man page.                              h

=head1 DESCRIPTION

B<iCman> provides a read-only window in which man pages can be
displayed. Each page argument given to B<man> is normally the name of a
program, utility or function. The manual page associated with each of
these arguments is then found and displayed. A section, if provided,
will direct B<iCman> to look only in that section of the manual. The
default action is to search in all of the available sections, following
a pre-defined order in the underlying 'man' call and to show only
the first page found, even if pages exist in several sections.

Other manual pages may be opened either by entering the name of a
manual page optionally followed by a section in parentheses in the
Man-Entry window and pressing RETURN.  Using ALT-RETURN will open the
new manual page in a new instance of B<iCman>. Alternatively a manual
page can be opened by double-clicking on a manual page hyper-link
(pale blue) - usually under the B<SEE ALSO> heading or in a Section
Index. A hyper-link is characterized by being followed by a valid
section in parentheses.  Sometimes a manual page reference is not
followed by a section in parentheses. Such a reference can still be
opened by double-clicking the reference with the Control key pressed.

Alternatively 'B<-k> <key>' or 'B<apropos> <key>' may be used in the
Man-Entry window to search the manual page names and descriptions for
key words. This provides man page hyper-links for pages mentioning
<key>.  The default 'regex' behaviour of B<apropos> (man -k) is
used. No wildcard or exact option is provided. The text provided by
'man -k' is piped through 'sort -u' to delete duplicate entries.
A sorted list with no duplicate entries is easier to analyze.

Also 'B<-f> <page>' or 'B<whatis> <page>' in the Man-Entry window will
display a short description of each page in each section containing
a page by that name as well as a hyper-link to each page.

Holding down the [man] button shows extra man page options including a
history of previously opened man pages. The 'man menu' can be detached
with the tear line ---------.

With the previous and next buttons [<=] and [=>] it is possible to
scroll through the history like a browser.

The displayed text is read-only. It's position may be manipulated
by the scroll bar(s) or the usual up/down/prior/next/home/end keys.
A useful feature is the use of the middle mouse button to fast scroll
in all 4 directions through the text.

Other shortcuts are the 'p' and 'n' key to load the previous or next
entry in the history.  The 'r' key reloads the current manpage,
which is useful if the manpage is being developed and has been
re-made externally.  'h' displays the B<iCman> manual page and 'q'
quits the program.

The search facility is much more powerful than that of 'less',
the usual man page viewer. Activate the search by keying '/' or
pressing the [/] button briefly.  Enter or paste a word into the
Search Entry window and key RETURN or press the [/] button again.
Searches may be for an exact match or for a full Perl-type regular
expression. The \bword\b feature to find only whole words is
particularly useful. Searches are normally case sensitive, but
a case-insensitive search may be selectd. Once a search has been
carried out, all the hits are highlighted. A first group of hits is
displayed in the Text window. The text is moved to display as many
hits as possible. When the user has analysed the first group of hits,
hitting RETURN will display the next group of hits in the text and
so on until the end of the text is reached. Another RETURN will start
by displaying the first group at the top again. Hitting SHIFT-RETURN
will reverse the direction of displaying the groups.

Double-clicking with mouse button 1 transfers the word under the
mouse to the Search Entry window and immediately starts a search for
that word. This is the quickest and best way to start a search.

Double-clicking with mouse button 1 with the cursor in the Search Entry
window or by pressing ctrl-RETURN will clear the search completely.

Holding down the search key [/] will show the different search options
for 'Exact match' or 'Regexp match' either case sensitive or not.
This is followed by a history of previous searches - most recent at
the end, which can be selected for a repeat search. This search menu
can be detached with the tear line ---------.

Tk::Text will open a dialog box when clicking the right mouse button
in the text window. The features provided are self explanatory. It
also has a search feature, which did not seem to be available when
I started.  The only useful feature is changing the wrap mode.

When B<iCman> is started the first time, the names of all manual pages
of every section in all directories of $MANPATH or the execution
of /usr/bin/manpath are obtained.  Since this may take some time,
particularly if the system is busy, the result of the scan is cached in
~/.iC/iCman.sec.  A full scan is carried out each new day. This should
be sufficient to catch any new man entries. Alternetively 'iCman -c'
may be used to build a new cache after new software has been installed.

=head1 AUTHOR

Copyright 2003-2013, John E. Wulff (immediateC@gmail.com)

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

Acknowledgments to Sriram Srinivasan (see below)

=head1 BUGS

B<iCman> could not display Unicode characters used in SuSE Linux 9.3.
This is a problem with Tk::Text version Tk-800.024.

Proper UTF-8 translation has been introduced for Tk::VERSION >= 803 with
open (FH, "-|:encoding(UTF-8)", "man $section $man 2>/dev/null");

There was a bug in B<pod2man>, which replaced all non ASCII-7
characters with rubbish.

This has now been fixed for UTF-8 sources if an early line in the pod
source is C<=encoding utf8> and B<pod2man> is called with the -u or
--utf8 option.  B<iCman> then shows UTF-8 characters correctly.

Example: German Umlaut characters       , which should be
A O U a o u with Diaresis plus a sharp s.

Email bug reports to B<immediateC@gmail.com> with L<iC man page reader>
in the subject field.

=head1 SEE ALSO

man(1), apropos(1), whatis(1), iClive(1), pod2man(1), perlpod(7)

=head1 ACKNOWLEDGEMENTS

This program is a major extension of B<perlman>, the man page viewer
from the O'Reilly Book "Advanced Perl Programming" by Sriram Srinivasan.
The work of Sriram Srinivasan is gratefully acknowledged.  Some ideas
were also used from the version of B<perlman> extended by H.Merijn Brand.
