#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2012  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCserver
#
#	The full specification is in the POD documentation at the end
#
#	For measuring reaction times the Module Time::HiRes is used.
#	Time::HiRes is also used to delay the Autovivify action.
#	Time::HiRes is activated by the -m and the -a options.
#	Make sure you have installed Time::HiRes (provided in this distribution)
#
########################################################################

use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use strict;
use warnings;

my %Clients = ();	# indexed by $name - existence of named client (duplicate clients)
my %Channels = ();	# indexed by $name - points to correct channel (duplicate channels)
my %Equivalences = ();	# indexed by $name - points to names with same channel
my %EquivChannels = ();	# indexed by $name - points to channel of equivalent names
my %ClientNames = ();	# indexed by $conn - points to client name for a connection
my @Senders = ();	# indexed by $channel ... stores send connection, name and current value
			# [ 0: conn, 1: name, 2: value ]
my @Receivers = ();	# indexed by $channel ... stores receive connections and names
			# [ [ 0: conn1, 1: name1 ], [ 2: conn2, 3: name2 ] ... ]
my %ReceiverData = ();	# indexed by $conn - holds $conn, channel:value data pairs
my $numberOfConnections = 0;
my $maxChannel = 0;
my $regFlag = 0;
my $ackString = '';
my $iniString = '';
my $ioName = '';
my $AutoDelay = 1000;	# 1 ms for normal autovivify delay
my %AutoVivify = ();
my $AutoDebug = '';
my %sortOrder = (	# determines in which order iCboxes ar autovivified
    IX => 0, QX => 1,
    IB => 2, QB => 3,
    IW => 4, QW => 5,
    IL => 6, QL => 7,
    IH => 8, QH => 9,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
format STDERR =
Usage:
    @<<<<<<< [-agrktmh][ -s <host>][ -p <port>][ -f <file>][ -A <cmd>]
	$named
	     [ -G <dbg>][ <list of equivalences>][ <list of client calls>]
	-s host	address of server - clients must specify the same address
		unless (default '0.0.0.0' which accepts any client)
	-p port	service port of server for all clients  (default '8778')
	-f file	read options, equivalences and client calls from this file
	-a	autovivify I/O clients for missing I/O's with cmd
	-A cmd	use <cmd> to autovivify I/O clients (default 'iCbox')
	-g      autovivify debugger when an iC control application registers
	-G dbg	use <dbg> to autovivify debugger (default 'iClive')
	-r	reset registered receivers when sender disconnects
	-k	kill previous client, when a new client with the same
		name registers (default: do not accept the new client)
	-t	trace messages for debugging
	-m	display elapsed time in seconds and microseconds
	<list of equivalences>
		eg: IX8=IX8-0=IX8-1 IX9=IX9-0=IX9-1
	<list of client calls>
		eg: 'iCbox X0-X3' 'iCbox X10' sort
		if a client call has arguments, the call must be quoted
	-h	help, ouput this Usage text only
Copyright (C) 2000-2012  John E. Wulff		<immediateC@gmail.com>
							  '@'
$Id: iCserver,v 1.41 2012/03/27 03:49:32 jw Exp $
.

use vars qw($opt_a $opt_g $opt_k $opt_r $opt_t $opt_T $opt_m $opt_s $opt_p $opt_f $opt_A $opt_G $opt_h);
require "getopts.pl";
&Getopts('agkrtTms:p:f:A:G:h');	# sets $opt_h if -h etc
$| = 1 if $opt_t or $opt_m;	# otherwise STDOUT is not flushed if piped

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

if (defined $opt_A) {
    $opt_a = 1;
} else {
    $opt_A = 'perl -S iCbox';
}
if (defined $opt_G) {
    $opt_g = 1;
} else {
    $opt_G = 'perl -S iClive';
}

########################################################################
#
#	Analyse equivalences and client call parameters
#
#	Equivalences consist of two or more identifiers separated by an
#	equal sign (=).
#
#	Client calls consist of an identifier optionally followed by a
#	spaced separated list of parameters.
#
#	Identifiers match /[\.\d\w_]+/
#
#	Individual equivalences and client calls must be written without
#	spaces in the command line unless they are quoted. In the optional
#	INI file which can be read with the -f option, each equivalence
#	and client call must be placed in one line. White spaces may be
#	used in equivalence lines and must be used to separate a client
#	call from its parameters. Client calls need not be quoted in the
#	INI file. If quoted it is stripped before pushing on @ARGV.
#
#	Comments are started with any other character than .\d\w_
#
########################################################################

if ($opt_f) {
    open IN, $opt_f or die "can't open ID file $opt_f! $!";
    while (<IN>) {		# read next entry from ID file into $_
	print "$opt_f: $_" if $opt_t;
	chomp;			# $_
	if (/^\s*(["']?)([.\d\w_][^"']*)/) {
	    push(@ARGV, $2);	# put next ID on end of @ARGV
	}
	## any garbage in the file is skipped - treated as comments
    }
    close IN;
}
print "ARGV:", join(':', @ARGV), ":\n" if $opt_t and @ARGV;

my ($t0, $t1);
if ($opt_a or $opt_m) {
    use Time::HiRes qw(ualarm gettimeofday);
    $t0 = [gettimeofday] if $opt_m;	# start time of program
}

$SIG{PIPE} = \&catch_zap;		# signal 13
$SIG{ALRM} = \&autoVivify;		# signal 14 - Timer signal from ualarm()
if ($opt_t) {
    $SIG{HUP}  = \&catch_zap;	# signal 1
##    $SIG{USR1} = \&catch_zap;	# signal 10	(stop -10 iCserver)
##    $SIG{USR2} = \&catch_zap;	# signal 12	(stop -12 iCserver)
##} else {
##    $SIG{USR1} = 'IGNORE';	# signal 10	(stop -10 iCserver)
##    $SIG{USR2} = 'IGNORE';	# signal 12	(stop -12 iCserver)
}

########################################################################
#
#	Server
#
########################################################################

my $host = defined $opt_s ? $opt_s : '0.0.0.0';
my $port = defined $opt_p ? $opt_p : 8778;

Msg->new_server($host, $port, \&login_proc);
print "$named created. Waiting for events\n";

########################################################################
#
#	Allocate equivalences and start clients named in argument list
#
#	start each argument as a separate process after splicing in
#	optional global switches -p <port> -t -m
#
########################################################################

my ($argv, $pid);

if (scalar @ARGV > 1) {
    $AutoDelay = 2_000_000;		# 2 seconds for autovivify delay with more than 1 process
}
while ($argv = shift @ARGV) {
    if ($argv =~ /^\s*([\.\d\w_][-\.\d\w_]*)\s*=/) {	# recognise equivalence
	my ($nm, $nn, $ch);
	$nm = $1;
	print "equivalence '$argv'\n" if $opt_t;
	$ch = allocate_channel($nm);		# allocate new channel for first identifier
	push @{$Equivalences{$nm}}, $ch;	# channel
	$EquivChannels{$nm} = $nm;		# used in AutoVivify
	while ($argv =~ /=\s*([\.\d\w_][-\.\d\w_]*)/g) {
	    $nn = $1;
	    allocate_channel($nn, $ch);		# allocate same channel for next identifier
	    push @{$Equivalences{$nm}}, $nn;	# equivalent name
	    $EquivChannels{$nn} = $nm;		# used in AutoVivify
	}
	$AutoDelay = 2_000_000;		# 2 seconds for autovivify delay with equivalences
    } else {
	exec_process($argv);
    }
}

Msg->event_loop();

########################################################################
#
#	Fork and exec another process
#
########################################################################

sub exec_process {
    my ($argv) = @_;
    print "exec_process '$argv'\n" if $opt_t;
    FORK: {
	sleep 1 if defined $pid;
	return if ($pid = fork);
	if (defined $pid) {	# $pid is zero if defined
	    ## dispatch child process
	    my @call = split " ", $argv;
	    my $n = 1;
	    if ($call[0] eq "perl") {	# only needed for WIN32
		 1 while $call[$n++] =~ /^-/;
	    }				# end of code for WIN32
	    splice @call, $n, 0, '-p', $opt_p if defined $opt_p;
	    splice @call, $n, 0, '-t' if defined $opt_t;
	    splice @call, $n, 0, '-m' if defined $opt_m;
	    print "@call\n";
	    exec @call;
	    exit;		# child process cannot be executed
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    sleep 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "$named: Can't fork: $!\n";
	}
    }
} # exec_process

########################################################################
#
#	Catch and report stray signals
#
########################################################################

sub catch_zap {
    my $signame = shift;
    if ($signame =~ /^USR1/) {
	print_tables();
    } else {
	die "$named: Caught SIG$signame: $!";
    }
} # catch_zap

########################################################################
#
#	Login procedure
#
########################################################################

sub login_proc {
    my ($conn, $host, $port) = @_;
    print "Connection $host:$port at server\n";
    return \&rcvd_msg_from_client;
} # login_proc

########################################################################
#
#	Disconnect a client
#
#	undef $Senders[$channel][0] for all channels at this $conn
#	splice out all @{$Receivers[$channel]} entries with this $conn
#
########################################################################

sub disconnect {
    my ($conn, $sender) = @_;
    my ($channel, $con, $receiver, $rflag);
    $sender = $ClientNames{$conn} unless defined $sender;
    if (defined $sender) {
	print "$sender: client no. $numberOfConnections unregistering now\n" if $opt_t;
	%ReceiverData = ();		# clear all keys and entries
	for ($channel = 0; $channel <= $maxChannel; $channel++) {
	    $rflag = 0;
	    if (defined ($con = $Senders[$channel][0]) and $con eq $conn) {
		$Senders[$channel][0] = undef;	# no need to splice out only array entry
		if ($opt_r and $Senders[$channel][2] != 0) {
		    $rflag = 1;
		    $Senders[$channel][2] = 0;			# reset sender
		}
		print "$sender: S $channel undef\n" if $opt_t;
	    }
	    if ($rflag) {
		# scan once before slicing out any array elements
		foreach $receiver (@{$Receivers[$channel]}) {
		    $con = $$receiver[0];
		    if ($con ne $conn) {
			pushReceiverData($con, "$channel:0");	# reset receiver
		    }
		}
	    }
	    my $i = 0;
	    foreach $receiver (@{$Receivers[$channel]}) {
		if ($$receiver[0] eq $conn) {
		    splice @{$Receivers[$channel]}, $i, 1;
		    print "$sender: R $channel spliced out\n" if $opt_t;
		    ############################################################
		    ## checked that there are no multiple Receiver entries
		    ## with the same $conn when registering
		    ############################################################
		    last;
		}
		$i++;		# index of next entry to be spliced out
	    }
	}
	delete $ClientNames{$conn};
	delete $Clients{$sender};
	$numberOfConnections--;
	if ($numberOfConnections <= 0) {
	    ############################################################
	    ## This was last connection - clear all arrays and hashes
	    ## this prevents channel numbers getting higher and higher
	    ############################################################
	    %Clients = ();
	    %Channels = ();
	    %ClientNames = ();
	    @Senders = ();
	    @Receivers = ();
	    $maxChannel = 0;
	    ############################################################
	    ## Re-constitute equivalences obtainened from initial ARGV
	    ############################################################
	    if (scalar keys %Equivalences) {
		my ($nm, $nn, $ch, $others);
		foreach $nm (sort { $Equivalences{$a}[0] <=> $Equivalences{$b}[0] } keys %Equivalences) {
		    $ch = allocate_channel($nm);	# allocate new channel for first identifier
		    if ($ch != $Equivalences{$nm}[0]) {
			warnD("$named: ch: $ch != $Equivalences{$nm}[0] - System error\n");
		    }
		    foreach $nn (@{$Equivalences{$nm}}[1 .. $#{$Equivalences{$nm}}]) {
			allocate_channel($nn, $ch);	# allocate same channel for next identifier
		    }
		}
	    }
	    print "$named: last client has unregistered\n" if $opt_t;
	}
    } else {
	warnD("the connection $conn is not currently registered - system error");
    }
    $conn->disconnect();
} # disconnect

########################################################################
#
#	Warning sent to Debug (iClive) registered on channel 0
#
########################################################################

sub warnD {
    my ($warnMsg) = @_;
    my ($name, $channel, $aref, $receiver, $rconn);
    warn $warnMsg;		# normal terminal warning
    chomp $warnMsg;
    if ($aref = $Receivers[0]) {	# channel 0 for error messages
	foreach $receiver (@$aref) {
	    $rconn = $$receiver[0];
	    print "$named: sent warning => $ClientNames{$rconn}\n" if $opt_t;
	    $rconn->send_now("0:1;$warnMsg");
	}
    }
} # warnD

############################################################
#
#	Allocate a channel to a name
#
#	This gives each Sender and Receiver pair an index called
#	$channel in the working arrays @Senders and @Receivers.
#	Each data transmission starts with this channel number.
#	Some differing names may use the same channel (equivalences).
#
############################################################

sub allocate_channel {
    my ($name, $channel) = @_;
    my $ch;
    unless (defined ($ch = $Channels{$name}) and defined $channel) {
	$channel = $ch unless defined $channel;
	$channel = ++$maxChannel unless defined $channel;
	$Channels{$name} = $channel;
    } else {
	warnD("$named: attempting to allocate channel for $name twice\n");
    }
no warnings;
    print "$named: allocate_channel $name, $channel\n" if $opt_t;
use warnings;
    return $channel;
} # allocate_channel

############################################################
#
#	Print tables of ClientNames and registered Senders and Receivers
#	Also print table of equivalences if any are defined
#
############################################################

sub print_tables {
    my ($con, $channel, $receiver);
    print "$named: Table of ClientNames and registered Senders and Receivers\n";
    foreach $con (sort { $ClientNames{$a} cmp $ClientNames{$b} } keys %ClientNames) {
	print "$ClientNames{$con}	$con\n";
    }
    if (scalar keys %Equivalences) {
	my ($nm, $nn, $others);
	print "ch:	Equivalences\n";
	foreach $nm (sort { $Equivalences{$a}[0] <=> $Equivalences{$b}[0] } keys %Equivalences) {
	    $others = join "\t", @{$Equivalences{$nm}}[1 .. $#{$Equivalences{$nm}}];
	    print "$Equivalences{$nm}[0]:	$nm	$others\n";
	}
    }
    print "ch:	Sender	name	value	Recv[0]	name[0]	Recv[1]	name[1]	...\n";
    for ($channel = 0; $channel <= $maxChannel; $channel++) {
	my ($chName, $name, $value, $rcon, $rName, @rCons) = ();
	if (not defined ($con = $Senders[$channel][0]) or
	    not defined ($chName = $ClientNames{$con})) {
	    $chName = "<undef>";
	}
	unless (defined ($name = $Senders[$channel][1])) {
	    $name = "<undef>";
	}
	unless (defined ($value = $Senders[$channel][2])) {
	    $value = "<undef>";
	} elsif (length $value > 7) {
	    $value =~ s/(......).*/$1>/;
	}
	foreach $receiver (@{$Receivers[$channel]}) {
	    if ($rcon = $$receiver[0]) {
		unless (defined ($rName = $ClientNames{$rcon})) {
		    $rName = "<undef>";
		}
		push @rCons, $rName, $$receiver[1];
	    }
	}
	$rName = @rCons ? join "\t", @rCons : "<no receivers>";
	if ($chName ne "<undef>" or $name ne "<undef>" or $value ne "<undef>") {
	    print "$channel:	$chName	$name	$value	$rName\n";
	} elsif (@rCons) {
	    if ($channel == 0) {
		print "$channel:				$rName\n";
	    } else {
		print "$channel:	<no sender>		$rName\n";
	    }
	}
    }
} # print_tables

########################################################################
#
#	Push connection and messages
#
########################################################################

sub pushReceiverData {
    my ($rconn, $msg1) = @_;
    unless (defined $ReceiverData{$rconn}) {
	## this is the first message for this receiver
	push @{$ReceiverData{$rconn}}, $rconn;	# save real connection
    }
    push @{$ReceiverData{$rconn}}, $msg1;	# collect messages for sending
} # pushReceiverData

########################################################################
#
#	Execute Autovivify actions after a delay with ualarm($AutoDelay)
#
########################################################################

sub autoVivify {
    if (scalar keys %AutoVivify) {
	my $autovivify = join ' ', sort {
	    my ($ha, $na, $za, $hb, $nb, $zb);
	    $a =~ /([A-Z]+)(\d+)(.*)/; $ha = $sortOrder{$1}; $na = $2; $za = $3;
	    $ha = $1 if not defined $ha;
	    $b =~ /([A-Z]+)(\d+)(.*)/; $hb = $sortOrder{$1}; $nb = $2; $zb = $3;
	    $hb = $1 if not defined $hb;
	    ############################################################
	    ## sort order is number then names in the following order
	    ## IX QX IB QB IW QW IL QL IH QH .. finally any instances
	    ##  0  1  2  3  4  5  6  7  8  9 .. correct for alpha cmp
	    ## print "$a $ha $na $za	$b $hb $nb $zb\n" if $opt_T;
	    ############################################################
	    $na <=> $nb || $ha cmp $hb || $za cmp $zb;
	} keys %AutoVivify;
	$autovivify = "$opt_A -n$ioName $autovivify";
	print "AUTOVIVIFY: '$autovivify'\n" if $opt_t;
	exec_process($autovivify);
	%AutoVivify = ();
    }
    if ($AutoDebug) {
	print "AUTODEBUG: '$AutoDebug'\n" if $opt_t;
	exec_process($AutoDebug);
	$AutoDebug = '';
    }
} # autoVivify

########################################################################
#
#	Receive message from client
#
#	connection $conn identifies the sender
#	message $msg has the following characteristics:
#	. undefined		ignore
#	. zero length		client has signalled shutdown
#	. comma separated list	break up into individual items $msg1
#	each item $msg1 has the following charecteristics:
#	. matches /^[NnSsRr]/	registration item
#	. matches /\d+:\d+/	split into $channel and $value, send
#				value to all receivers for the channel
#	. matches /^[XT]/	special actions
#	. else eror
#
########################################################################

sub rcvd_msg_from_client {
    my ($conn, $msg, $err) = @_;
    my ($sec, $usec);
    my ($con, $msg1, $aref, $direction, $name, $bits, $channel, $sender, $receiver, $rconn, $ini);
    if ($opt_m) {
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "S%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "S%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
    } elsif ($opt_t) {
	print "S: ";
    }
    if (defined $msg) {
	my $len = length $msg;
no warnings;
	$sender = $ClientNames{$conn};
	print "($len)$msg< '$sender'\n" if $opt_T;
use warnings;
	if ($len == 0) {
	    ############################################################
	    ## Client $conn has signalled shutdown - disconnect client
	    ## clear all entries for $conn in @Senders and @Receivers
	    ############################################################
	    disconnect($conn);
	}
	else {
	    foreach $msg1 (split /,/, $msg) {	# break up multiple messages
		if ($msg1 =~ /^(\d+):(.*)$/) {	# data message
		    ## $1 is channel : $2 is value
		    $channel = $1;
		    $con = $Senders[$channel][0];
		    warnD("Error $named: data '$msg1' during registration - app spec error") if $regFlag;
		    if (not defined $con or $con eq $conn) {
			$Senders[$channel][2] = $2;	# latest value in case lost connection
			if ($aref = $Receivers[$channel]) {
			    foreach $receiver (@$aref) {
				$rconn = $$receiver[0];
				pushReceiverData($rconn, $msg1);
			    }
			}
			if ($opt_t and (not $aref or not @$aref)) {
			    print "$ClientNames{$conn} $msg1 => dummy\n";	# not registered
			}
		    } else {
			print "conn = $conn, channel [0] = $Senders[$channel][0]\n";
			warnD("$ClientNames{$Senders[$channel][0]} $msg1 received on wrong connection $ClientNames{$conn}\n");
		    }
		}
		elsif ($msg1 =~ /^N(.+)/) {	# name part of registration
		    $name = $1;
		    $con = $Clients{$name};
		    if ($con) {
			############################################################
			## a client with the same name was previously registered
			############################################################
			unless ($opt_k) {
			    ############################################################
			    ## kill the new client and report error
			    ############################################################
			    warnD("trying to register client '$name' twice - aborted\n");
			    $conn->disconnect();	# new client was not registered yet
			    last;			# killed new client process
			}
			############################################################
			## -k option: unregister and disconnect previous instance
			## proceed with new registration
			############################################################
			warnD("kill previous client '$name' - restarted\n");
			disconnect($con, $name);	# kills old client process
			if ($channel = $Channels{"D$name"}) {
			    $iniString = "$channel:1";	# get S.T. from new client
			}
		    }
		    $Clients{$name} = $conn;		# client by this name exists now
		    $ClientNames{$conn} = $name;	# name may change for iClive connections
		    if ($name =~ /^-/) {
			foreach $receiver (@{$Receivers[0]}) {
			    if ($$receiver[0] eq $conn) {
				$$receiver[1] = $name;			# name has changed
				goto ALREADY_REGISTRERD;
			    }
			}
			push @{$Receivers[0]}, [ $conn, $name ];	# warning registration
		    }
		    ALREADY_REGISTRERD:
		    $numberOfConnections++;
		    $regFlag = 1;			# registration string has started
		    print "$name: client no. $numberOfConnections registering now\n" if $opt_t;
		}
		elsif ($msg1 =~ /^([SR])([\\\/\w]+(-\d*)?)(\((\d+)\))?/) {
		    ############################################################
		    # regex is permissive allowing any number of instance digits
		    # clients have to stay in specification 1 to 3 digits
		    # if not, server still functions correctly
		    ############################################################
		    $direction  = $1;
		    $name = $2;
		    $bits = $5;
		    $channel = allocate_channel($name);
		    my $ack = $channel;		# used to build acknowledge string
		    if ($direction eq 'S') {
			if ($Senders[$channel][0]) {
			    ############################################################
			    ## A client is trying to register a sender twice
			    ############################################################
			    $ack = -$channel;
			    warnD("$ClientNames{$conn}: trying to register S $name for channel $channel twice - aborted\n");
			    # has registered name and may already have registered some receivers
			    disconnect($conn);
			    $ackString = '';
			    last;
			}
			############################################################
			## Register a new Sender
			## sends all registered receivers on the channel a 0 value
			## (this also works for iClive - NOP)
			############################################################
			$Senders[$channel][0] = $conn;
			$Senders[$channel][1] = $name;
			$Senders[$channel][2] = 0;		# default initial value
			$aref = $Receivers[$channel];
			if ($aref and @$aref) {
			    foreach $receiver (@$aref) {
				$rconn = $$receiver[0];
				if ($rconn) {
				    pushReceiverData($rconn, "$channel:0");	# send initial value 0
				} else {
				    warn "$named: sender '$name' not connected when rgistering\n";
				}
			    }
			} else {				# no receiver registered
			    if ($opt_a and
				$name =~ /^Q[XBWL]\d+/ and	# not part of an equivalence
				not $EquivChannels{$name}) {	# not even first for senders
				my $iCbox_param = $bits ? "$name,$bits" : $name;
				$AutoVivify{$iCbox_param}++;
				print "Autovivify sender '$iCbox_param'\n" if $opt_T;
			    }
			    if ($opt_g and			# C_channel only as trigger
				$name =~ /^C([\\\/\w]+)(-(\d*))?$/ and
				not $EquivChannels{$name} and	# not part of an equivalence
				not $AutoDebug) {		# only 1 per application
				if (defined $3) {
				    $AutoDebug = "$opt_G -i$3 $1.ic";
				} else {
				    $AutoDebug = "$opt_G $1.ic";
				}
				print "AutoDebug: '$AutoDebug' for sender '$name'\n" if $opt_T;
			    }
			}
no warnings;
			print "$ClientNames{$conn}: $direction $name	ack = $ack\n" if $opt_t;
use warnings;
		    } elsif ($direction eq 'R') {
			############################################################
			## ignore duplicate Receiver entries for this $conn
			############################################################
			foreach $receiver (@{$Receivers[$channel]}) {
			    if ($$receiver[0] eq $conn) {
				# happens if receiver equivalences in the same client
				$ack = -$channel;		# not an error in iCbox
				print "Register R $name for channel $channel at '$ClientNames{$conn}' twice\n" if $opt_t;
			    }
			}
			if ($ack > 0) {
			    push @{$Receivers[$channel]}, [ $conn, $name ];	# actual R registration
			    if ($Senders[$channel][0]) {	# is sender registered ?
				$ini = $Senders[$channel][2];	# yes - current value
				if ($ini) {
				    ############################################################
				    ## sender is registered and has either initial value 0 or other
				    ## current value - send new receiver value different to 0
				    ## if sender is already registered
				    ############################################################
				    $ini = "$channel:$ini";
				    if ($iniString) {
					$iniString = join ',', $iniString, $ini;
				    } else {
					$iniString = $ini;
				    }
				}
			    }
			    elsif ($opt_a and			# no, sender not registered
				$name =~ /^I[XBWL]\d+/) {
				my $base = $EquivChannels{$name};
				unless (defined $base) {
				    $base = $name;
				}
				elsif ($base !~ /^I[XBWL]\d+/) {
				    $base = '';			# not an input
				}
				if ($base) {
				    my $iCbox_param = $bits ? "$base,$bits" : $base;
				    $AutoVivify{$iCbox_param}++;
				    print "Autovivify receiver '$iCbox_param'\n" if $opt_T;
				}
			    }
			}
no warnings;
			print "$ClientNames{$conn}: $direction $name	ack = $ack	ini = '$ini'\n" if $opt_t;
use warnings;
		    }
		    if ($ackString) {
			$ackString = join ',', $ackString, $ack;
		    } else {
			$ackString = $ack;
		    }
		}
		elsif ($msg1 eq 'Z') {
		    $regFlag = 0;		# registration string has terminated
		}
		elsif ($msg1 =~ /^n(.+)/) {
		    $name = $1;
		    $con = $Clients{$name};
		    unless ($con) {
			############################################################
			## no client with this name was previously registered
			############################################################
			warnD("$name: no client with n $name was previously registered\n");
		    }
		    print "$name: client no. $numberOfConnections unregistering now\n" if $opt_t;
		    delete $ClientNames{$conn};
		    delete $Clients{$name};
		    $numberOfConnections--;
		}
		elsif ($msg1 =~ /^([sr])(.+)/) {
		    $direction  = $1;
		    $name = $2;
		    unless (defined ($channel = $Channels{$name})) {
			warnD("$ClientNames{$conn}: trying to unregister $name not previously registered - aborted\n");
		    }
		    if ($direction eq 's') {
			unless ($Senders[$channel][0]) {
			    warnD("$ClientNames{$conn}: trying to unregister s $name not registered as sender - aborted\n");
			}
			############################################################
			## Unregister a previously registered Sender
			############################################################
			if (defined ($con = $Senders[$channel][0]) and $con eq $conn) {
			    $Senders[$channel][0] = undef;	# no need to splice out only array entry
			    print "$sender: s $channel undef\n" if $opt_t;
			} else {
			    warnD("$ClientNames{$conn}: trying to unregister s $name not registered as sender - aborted\n");
			}
			## leave name
			$Senders[$channel][2] = 0;	# reset initial value
		    } elsif ($direction eq 'r') {
			############################################################
			## check that there are no Receiver entries with this $conn
			############################################################
			my $i = 0;
			foreach $receiver (@{$Receivers[$channel]}) {
			    if ($$receiver[0] eq $conn) {
				splice @{$Receivers[$channel]}, $i, 1;
				print "$sender: r $channel spliced out\n" if $opt_t;
				############################################################
				## checked that there are no multiple Receiver entries
				## with the same $conn when registering
				## only used for iClive which only registers one receiver
				## but use full algorithm just in case of future clients
				############################################################
				last;
			    } else {
				$i++;		# index of next entry to be spliced out
			    }
			}
		    }
		}
		elsif ($msg1 eq 'X') {
		    print "iClive stopped $named\n";
		    exit 0;	# iClive started iCserver and now stopped it
		}
		elsif ($msg1 eq 'T' and $opt_t) {
		    print_tables();
		}
	    }
	    $sender = $ClientNames{$conn};
	    if ($ackString) {
		print "ACK: $ackString => $sender\n" if $opt_t;
		$conn->send_now($ackString);	# registration acknowledgment
		$ackString = '';
		unless ($regFlag) {		# defer ini and autoVivify until registration terminated
		    if ($iniString) {
			## must be independent xmission, because different rcv call in client
			print "INI: $iniString => $sender\n" if $opt_t;
			$conn->send_now($iniString);# registration initialisation
			$iniString = '';
		    }
		    if (scalar keys %AutoVivify or $AutoDebug) {
			$ioName = "$sender-IO";
			ualarm($AutoDelay);		# defer the action to allow more registrations
		    }
		}
	    }
	}
	############################################################
	## Scan destination connections for which data was collected
	############################################################
	foreach my $c (keys %ReceiverData) {	# only the unique string key for connection
	    $aref = $ReceiverData{$c};
	    $rconn  = shift @$aref;		# the real connection object
	    if (defined $rconn) {
		$msg1 = join ',', @$aref;	# one or more channel:value pairs
		print "$sender $msg1 => $ClientNames{$c}\n" if $opt_t;
		$rconn->send_now("$msg1");	# send channel:value pairs to destination
	    } else {
		warnD("no message to send to connection '$c' ???\n");
	    }
	}
	%ReceiverData = ();		# clear all keys and entries for next receive
    }
    if ($opt_m) {
	$t0 = [gettimeofday];
    }
} # rcvd_msg_from_client
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCserver - the central server for iC clients

=head1 SYNOPSIS

 iCserver [-agrktmh][ -s <host>][ -p <port>][ -f <file>][ -A <cmd>]
          [ -G <dbg>][ <list of equivalences>][ <list of client calls>]
    -s host address of server - clients must specify the same address
            unless (default '0.0.0.0' which accepts any client)
    -p port service port of server for all clients  (default '8778')
    -f file read options, equivalences and client calls from this file
    -a      autovivify I/O clients for missing I/O's with cmd
    -A cmd  use <cmd> to autovivify I/O clients (default 'iCbox')
    -g      autovivify debugger when an iC control application registers
    -G dbg  use <dbg> to autovivify debugger (default 'iClive')
    -r      reset registered receivers when sender disconnects
    -k      kill previous client, when a new client with the same
            name registers (default: do not accept the new client)
    -t      trace messages for debugging
    -m      display elapsed time in seconds and microseconds
    <list of equivalences>
            eg: IX8=IX8-0=IX8-1 IX9=IX9-0=IX9-1
    <list of client calls>
            eg: 'iCbox X0-X3' 'iCbox X10' sort
            if a client call has arguments, the call must be quoted
    -h      help, ouput this Usage text only

=head1 DESCRIPTION

iCserver acts as a router for a number of iC clients in a network, who
send data to each other. Each client connects via TCP/IP to iCserver on
a specified port (8778 default at the moment).  Only one iCserver on one
port may run in a network.  It is possible to run several iCservers on
different ports.  Clients can connect either via 'localhost' (default
for iC clients) when they run on the same processor as iCserver or via
the host address of the processor iCserver is running on.  On connection
each client registers itself with iCserver.

Clients for iCserver are iC control applications, I/O clients such
as iCbox or similar real I/O clients and debugging programs such
as iClive. These clients either send or receive data values from
and to named I/O locations or debugging information. As far as
iCserver is concerned I/O locations could have any name, but the iC
language calls for I/O names or addresses according to the IEC-1131
standard. Each client registers the I/O names it requires on connection
to iCserver. Each unique name is stored in a Hash in iCserver,
whose value is a channel number, which is used for all actual data
transfers. The Hash is only required for registration. Each channel
allows the naming of one Sender for data on the channel (or I/O name)
and one or more Receivers for the data. A detailed description follows
in the Specification below.

Additional functionality in iCserver.

 a) equivalence - or interconnection of different I/O addresses in
    iCserver. This option puts two or more entries in the Hash and
    assigns them a common channel number. Send or receive entries
    associated with the channel are undefined at this stage. Then
    when registration of one of the equivalence names occurrs,
    the common channel number is used. With this option different
    IEC-1131 addresses can be assigned to the same channel, thereby
    making them equivalent or interconnecting them.

    This functionality is required when the output of one iC control
    application is to be input for another instance if the same
    control application.  Several equivalences may be specified. The
    order of the equivalence is not relevant (it is not an assignment).
    For correct autovivification outputs should be named first though.

    Example 1:
	iCserver QX7-0=IX7-1 QX7-1=IX7-0

    This connects QX7 of instance 0 with IX7 of instance 1 via a common
    channel and QX7 of instance 1 with IX7 of instance 0 via another
    channel. Equivalencing an output and an input of the same instance
    is possible but rather useless and much slower than using internal
    variables (it may be useful for testing).

    Equivalencing is also required if one external I/O source must be
    connected to the input of more than one iC control application.

    Example 2:
	iCserver IX8=IX8-0=IX8-1 IX9=IX9-0=IX9-1

    This sets up common inputs IX8 and IX9 to two instances of the same
    controller. Naming the other inputs with the same base IEC-1131
    address is not necessary but highly advisable for transparency in
    the documentation. The first address is used for autovivifying an
    iCbox if it does not exist already. Autovivification does not take
    place for a channel, until a receiver has been registered for that
    channel and all other registrations have taken place.

    Equivalencing two or more output addresses (Q...) will lead to
    an error, if both output addresses register as senders in an iC
    control application - this would lead to two or more senders on
    the same channel. When the second or later output sender registers,
    the error will be reported. A similar error will be reported if a
    second external input device in an equivalence chain is registered
    as a second sender. This would happen if both IX8 and IX8-0 were
    started as iCboxes after the equivalence statement in Example
    2 above.

 b) client calls - a list of calls with their parameters allow iCserver
    to start a number of clients as separate processes like
    a shell.  These are usually all the I/O client(s) and control
    application(s) to make up a complete control system. By providing
    this functionality in iCserver, all the information for starting
    a control system is grouped in one place.

    Example 3:
	'iCbox -n sorter-IO IX0 QX0 QX1' sorter

    This starts two clients - iCbox and the control application sorter.
    Calls with parameters must be quoted on the command line.

 c) -f option - execute a file with iCserver options at startup.
    For very large equivalence tables a file defining equivalences and
    possibly other iCserver options can be used.

	iCserver -f <equivalence_file>

    Format of the equivalence file:
	<equivalence_line>
	<equivalence_line>
	...
	<other_options>

    Example same as Example 1, 2 and 3 above with extra options:
	QX7-0 = IX7-1
	QX7-1 = IX7-0
	IX8 = IX8-0 = IX8-1
	IX9 = IX9-0 = IX9-1
	iCbox -n sorter-IO IX0 QX0 QX1
	sorter

    All equivalences must be defined before any registrations at
    iCserver take place. Since equivalences are declared as iCserver
    parameters or with the -f option this will happen automatically
    at iCserver startup.

    Formally equivalences consist of two or more identifiers separated
    by an equal sign '='.

    Client calls consist of an identifier optionally followed by a space
    separated list of parameters.

    Identifiers match /[\.\d\w_]+/

    Individual equivalences and client calls must be written without
    spaces in the command line unless they are quoted. In the optional
    INI file which can be read with the -f option, each equivalence
    and client call must be placed in a separate line. White spaces
    may be used in equivalence lines and must be used to separate a
    client call from its parameters. Client calls need not be quoted
    in the INI file.

    Comments are started with any other character than [.\d\w_],
    usually #

 d) -a option - automatic startup of iCboxes (Autovivification)
    When a control program registers its I/O's, iCserver -a starts up a
    matching iCbox for all complementary I/O's, which have not already
    been registered. With this option, clients must be started in a
    particular order:

    i)  iCserver -a - always first anyway.

    ii) any manually started I/O's with real I/O or specific ranges etc
        or because of equivalances.

    iii)control application(s) which causes iCserver to autovivify any
	missing I/O's as iCboxes with default ranges.

    Note: the -a option would be incompatible with a scenario, where
    several control clients communicate via equivalenced channels.
    To overcome this problem, a heuristic is used, where no outputs QNm
    are autovivified, if they occurr anywhere in an equivalence list.
    If an Input INm occurs in an equivalence list, the first variable
    in the equivalence list is autovivified instead, as long as that
    is also an input.

    Note: when a control program exits (disconnects from iCserver)
    the I/O's are not disconnected. They can be reused by a restarted
    control application. When iCserver exits, all connected clients
    are closed.

 e) -k option - if a sender registers with the same name as one already
    registered, kill the previously registerd sender, rather than
    reporting an error. This allows a recompiled version of an iC
    application to be started, while an old version is still running -
    the old one will quitly be killed. This should not be done in a
    production system.

 f) -g option - automatically start iClive xxx.ic when SCxxx registers.

=head1 SPECIFICATION

 1) On connection to iCserver each client register by supplying the
    following registration information:

    a)  The name of the client device.

	<name_op><client_name>[-<instance>]

	<name_op>
	N signifies, that the named client registers with iCserver.
	n signifies, that the named client unregisters from iCserver.

	<client_name>
	The client_name must be unique. For iC applications the control
	program register with the name it is called with. The iClive
	debug program registers with the name of the iC application
	it is connected to preceded by a '-'. The leading - is used
	by iClive to detect live registrations, which may register
	and unregister with different names, to monitor different
	iC applications.

	-<instance>
	An optional instance number allows the registrations of several
	instances of the same control program. Its use is explained in
	detail later.

    b)	Registration codes: the type of data the client is sending or
	receiving and the physical address in IEC-1131 format:

	<send_receive_op><address_code>[-<instance>][(<bit_map>)]

	<send_receive_op>
	S signifies, that the client sends data to iCserver.
	R signifies, that the client receives data from iCserver.
	s sender unregisters from iCserver (used by iClive only)
	r receiver unregisters from iCserver (used by iClive only)

	<address_code>
	The <address_code> is made up either of an IEC-1131 code
	used in iC programs to identify (address) a particular
	input or output or by a special address for communicating
	with debugging and monitoring clients consisting of an
	<address_code> starting with C,D or M are used. These are
	followed by the name of the debugging or monitoring client.

	-<instance>
	An optional instance number allows the registrations of several
	instances of the same control program. Its use is explained in
	detail later.

	(<bit_map>)
	An optional bit map, which defines the bits implemented for
	a digital input or output. The default value is 255, which
	implements bits 0 to 7.

    c)	Termination code for the registration string consisting of
	the single letter 'Z'. This allows the registration string
	to be longer than the TCP/IP transmission size of 1400 bytes
	(also maximum buffer size) - it will be sent in more than one
	transmission if it is too long.

    In summary: the registration string consists of a comma seperated
    list beginning with 'Nname' followed by one or more individual
    sender and receiver registration codes starting with 'S' or 'R'
    and terminated with a single 'Z'. The whole is sent in one or
    more transmissions. iCserver acknowledges each transmission by
    sending a comma separated list of channel numbers used for each
    sender or receiver for each partial registration string. These
    acknowledge strings are always shorter than the registration
    strings - hence there is no danger of buffer overflow.

	IEC-1131 names are as follows:

	    <io_op><size_op><address>

	    <io_op>
	    I data is input to an iC control client.
	    Q data is output from an iC control client.

	    C debug data is output from an iC control client to iClive
	    D debug data is input to an iC control client from iClive
	    M signifies a monitor device (none implemented so far).
		more details for C, D and M in section 6)

	    <size_op>
	    X signifies 8 bits of single bit data.
		    bit addresses are not used in the registration or
		    transmission of X senders and receivers. 8 bits are
		    always transmitted as 1 byte and the clients insert
		    or extract modified bits as necessary.
	    B signifies 8 bits or 1 byte of numerical data.
	    W signifies 16 bits or 2 bytes of numerical data.
	    L signifies 32 bits or 4 bytes of numerical data.
	    H signifies 64 bits (not implemented on 32 bit processors)

	    <address>

	    This number is the numerical IEC-1131 address. Unlike
	    previous implementations, each data type has its own
	    address space, which is independent of the others. Also
	    the numbering of W (16 bit) addresses is continuous 0, 1,
	    2, 3 and not 0, 2, 4, 6 as in previous implemetations. The
	    same applies to L (32 bit) addresses.

	NOTE: the syntax of a correct IEC-1131 name is not actually
	checked by iCserver - it is listed here for reference only.

	Examples:
	SIX0    8 single bits IX0.0 to IX0.7 sent from an external source
	RIX0    8 single bits IX0.0 to IX0.7 received by an iC controller
	SQX9(7) 3 single bits IX9.0 to IX9.2 sent from an iC controller
	RQX9(7) 3 single bits IX9.0 to IX9.2 received by an external sink

	SIB10   single byte IB10 sent from an external source
	RIB10   single byte IB10 received by an iC controller
	SQB15   single byte QB15 sent from an iC controller
	RQB15   single byte QB15 received by an external sink

	SIW10   single word IW10 sent from an external source
	RIW10   single word IW10 received by an iC controller
	SQW15   single word QW15 sent from an iC controller
	RQW15   single word QW15 received by an external sink

	SIL10   single long IL10 sent from an external source
	RIL10   single long IL10 received by an iC controller
	SQL15   single long QL15 sent from an iC controller
	RQL15   single long QL15 received by an external sink

 2) As indicated under <address> above, each data type QX, QB, QW, QL
    and QH as well as IX, IB, IW, IL and IH define their own
    address space in iC control applications. This differs form the
    implementations 1.1 to 1.105, which defined a joint address space
    for inputs and a separate but joint address space for outputs where
    16 bit words had to have an even byte address and 32 bit long
    addresses had to be divisble by four. Also the control software
    had to check that different types of data did not overlap and that
    a maxinum address was not exceeded.  This will not be necessary
    with this new specification. Using the overlap for obscure control
    purposes was never implemented fully (sending worked, receiving
    did not). Its use is deemed to be too obscure to be maintained,
    and the new specification should be much easier to handle.

    In the new specification <address> simply indexes sparse arrays
    of bytes, words, longs (or 64 bit huge integers on a 64 bit
    machine). They are allocated by name to a channel number in
    iCserver and only the channel numbers are used by the clients after
    registration.

    Nevertheless it may be advisable to maintain the currently
    implemented checks on maximum I/O address and checks on word
    and long boundaries as well as overlaps between bit, byte, word
    and long fields as a compile option. This may be useful for real
    I/O implementations in which the input and output fields are two
    contiguous byte fields. Since this code is currently in place,
    it is easier to change it to an option, than to discard it now
    and to re-implement it later.

 3) One client device has one two way TCP/IP connection to iCserver,
    but it can register for any number of send and/or receive addresses.
    For example the simple iCbox registers as X0 by default, supplying
    8 bits if input data and sinking 8 bits of output data It will
    register itself as SIX0,RQX0. SIX0 is the source of the signals
    IX0.0 to IX0.7 and RQX0 is the sink of QX0.0 to QX0.7.  An iC
    control application handling those two signal groups will register
    itself as RIX0,SQX0.  RIX0 for receiving IX0.0 to IX0.7 and SQX0
    for sending QX0.0 to QX0.7.

    This scheme makes I/O devices and controllers identical as far as
    iCserver data handling is concerned. and opens the possibility,
    that one iC control application can communicate data to another via
    the iCserver network. This is a definite requirement when multiple
    iC applications are involved in an overall project. A more obscure
    use would be sending data from an external input directly to an
    external output. More realistic would be using an iCbox output to
    monitor the data going to another client doing real output.

    A shorter Registration code was used previously but registration
    happens only once at startup and so a more comprehensive
    registration code is preferable. The new specification allows
    fast interpretation - S and R are separated first. It is also
    readable for debugging.

 4) To allow monitoring and to allow several iC control applications to
    react to input from a single source, iCserver supports the receive
    registration of the same address from several clients. iCserver
    will then send the same data to each of those clients, when it
    is received from its source by iCserver for distribution.

 5) On the other hand, only one client may register as the sender for
    a particular address. If iCserver did not catch this as an error,
    serious malfunction would occurr, if several clients were to
    send data, which would then be overwritten inconsistently at the
    destination sinks.

 6) Communication with debugging devices (iClive) is regulated with two
    alternative <io_op>s; 'C' for controller and 'D' for debugger.
    There can be several instances of iClive running together, but
    only one for each control program. They are addressed by the
    program name, not an IEC-1131 address. A control program named
    'sorter' would connect with iClive as follows:

        iC program                 iClive
	 Nsorter,                 N-sorter,
	 SCsorter,     ====>      RCsorter,
	 RDsorter     <====       SDsorter

    Each unit registers for both send and receive, since the data
    handling for send and receive are handled in separate sections of
    iCserver and a live display needs both. This means that no special
    treatment of live display registration and data parsing is needed.

    As an alternative to a live display, a plot program (iCplot) could
    be connected. Since both could not be connected simultaneously
    if they were controlled by the 'D' identification an alternative
    for such a client programs is 'M' for monitor. Since live display
    requires a lot of support from a running application, which should
    not have to be duplicated for a monitor, yet other alternatives
    may be required. One is to integrate the 'plot' function into
    iClive. For specification purposes, all the alternatives are
    covered.

 7) Allow every application to be started by specifying an optional
    <instance> parameter (see 1), which is appended to all registration
    codes or addresses. The same instance number is also appended
    to the addresses of I/O clients communicating with a particular
    controller instance. Such a set of a controller and I/O clients
    with a common instance number are a set, which communicate with
    each other. The instance parameter is passed to each client with
    the calling parameter -i<instance>.

    Example without instance number:
        sorter     # (using IX0, QX0, QX1) will register with:
	    Nsorter,SCsorter,RDsorter,RIX0,SQX0,SQX1,Z
	iCbox      IX0 QX0 QX1           # will register with:
	    NIX0,SIX0,RQX0,RQX1,Z
	iClive     sorter                # will register with:
	    N-sorter,RCsorter,SDsorter,Z

    Example of a first instance:
        sorter -i0 # (using IX0, QX0, QX1) will register with:
	    Nsorter-0,SCsorter-0,RDsorter-0,RIX0-0,SQX0-0,SQX1-0,Z
	iCbox  -i0 IX0 QX0 QX1           # will register with:
	    NIX0-0,SIX0-0,RQX0-0,RQX1-0,Z
	iClive -i0 sorter                # will register with:
	    N-sorter-0,RCsorter-0,SDsorter-0,Z

    Example of a second instance:
        sorter -i1 # (using IX0, QX0, QX1) will register with:
	    Nsorter-1,SCsorter-1,RDsorter-1,RIX0-1,SQX0-1,SQX1-1,Z
	iCbox  -i1 IX0 QX0 QX1           # will register with:
	    NIX0-1,SIX0-1,RQX0-1,RQX1-1,Z
	iClive -i1 sorter                # will register with:
	    N-sorter-1,RCsorter-1,SDsorter-1,Z

    Although mixed registrations, in which clients of the same name
    are used with and without instance numbers as shown above will work
    correctly, this will cause confusion in the project documentation
    and iCserver will issue a warning if it occurrs.

 8) Registration of clients from the view of iCserver

    a)	A client connects to iCserver via TCP/IP, which accepts and
	issues a $conn object.

    b)	The client sends a Message with all its registration codes in
	a comma sperated list to iCserver (see specification).

    c)	In iCserver the registration code <address_code>[-<instance]
	is used as a key in a hash table, which associates a unique
	channel number with the key.  The key identifies either an
	IEC-1131 I/O or a debug address. It is the identification or
	name of a communication send/receive pair and is unique. The
	associated channel number is an index in an array which
	holds run-time details for the communication pair or
	channel. <send_receive_op> selects the correct entries in
	that array.

	iCserver maps each code against the Hash %clientNames,
	which returns the correct channel number if it has already
	been allocated. All further data transfers in iCserver and
	the clients use the channel number to identify a particular
	send/recive pair.

    d)	iCserver acknowledges registration of a client by sending a
	comma separated list of channel numbers in the same order as
	the registration codes. If a particular registration code
	cannot be registered correctly, the comma separated list
	contains a negative error number for that entry.

 9) Registration from the view of clients

    a)	When a client starts, it connects to iCserver (which must
	be running) and sends its registration string.

    b)	When the client receives the positive acknowledgement string,
	which will be the first message received, it pairs off the
	registration codes and the channel numbers received in the
	acknowledgement. The details depend on the client application.

	For the first example in section 7, the following tables will
	be set up in the different clients:

         client  name        channel  direction
        sorter
		Csorter		1	S
		Dsorter		2	R
		IX0		3	R
		QX0		4	S
		QX1		5	S
	iCbox
		IX0		3	S
		QX0		4	R
		QX1		5	R
	iClive
		Csorter		1	R
		Dsorter		2	S

 10)When registration is complete, iCserver can determine, that each
    channel has one and only one sender and at least one receiver. If a
    project is run only as a simulation, a missing sender or receiver
    may not matter and only a warning is issued. If a project drives
    real I/Os an error must be reported by iCserver. The option flag
    -w turns such error messages into warning messages only.

 11)Formats of data messages between iCserver and clients follow a
    uniform pattern:

    <channel_number>:<data_value> in a comma separated list for a number
    of simultaneous values on different channels to the same client.

    <channel_number> is always a simple decimal string identifying the
    unique channel allocated by iCserver.

    <data_value> is a decimal value with a - sign for negative values
    in case of the numeric types X, B, W, L (or H). iClive uses a more
    complex data format consisting of a semi-colon separated list of
    data pairs (see specification of iClive).

    Examples:
	4:1,5:2		# set QX0.0 and QX1.1 in the example above
	2:4;2 128;5 48	# a type 4 live data telegram for iClive

 12)Unregistering a client.

    A client must be able to unregister itself, without disrupting a
    running process, particularly if it is only a secondary receiver.
    This will happen when a client closes a TCP/IP connection. When a
    client is disconnected, keep the Hash entry for the channel number
    in case it connects again.

For measuring reaction times the Module Time::HiRes is used.
This activates the -m option and flash display of short events.
Make sure you have installed Time::HiRes (provided in this distribution)

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

Error and warning messages for transmissions to missing clients have
not been implemented yet (-w option).

Mixed instance warning not yet implemented.

The Specification supplements the Description of iCserver and may be
useful in understanding its workings.

=head1 SEE ALSO

L<immcc(1)>, L<iCbox(1)>, L<iClive(1)>

=head1 COPYRIGHT

Copyright (C) 2000-2012  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
