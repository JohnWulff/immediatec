#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2023-2024  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iCmqtt; interface between openHAB MQTT and iCserver
#
########################################################################

########################################################################

use iCmsgM;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
			## added code from   https://metacpan.org/pod/Net::MQTT::Simple
use strict;
use warnings;

my @ArgNames;		# stores IO base names and bit mask in argument list order
my @ChannelNames;	# stores IO names with instance for each registered channel
my @ChannelsQ;		# stores received value for all Q[XBWL]n outputs
my @ChannelsQX;		# stores computed bit value for all QXn.<0..7> outputs
my @ChannelsI;		# stores computed or selected value for all I[XBWL]n inputs
my $UnitRegistrations;	# stores the registration string
my @argv       = ();
my $server     = 0;
my $conn;
my $errorFlag;

my $Ch = 0;
my $Bit;

my @args;
my @runArgs = ();
my $argsP = \@args;			# intially fill @args
my $Rflag = 0;
my $opt_Z = 0;		# 1 for debugging sub convertFlags()
my %commandLineFlags = (
    'F'   => 1,				# Value flags
    'I'   => 1,
    'Q'   => 1,
    's'   => 1,
    'p'   => 1,
    'N'   => 1,
    'i'   => 1,
    'm'   => 1,
    'n'   => 1,
    'S'   => 1,
    'A'   => 1,
    'T'   => 1,
    'G'   => 0,				# Bool flags
    'E'   => 0,
    'B'   => 0,
    'q'   => 0,
    'a'   => 0,
    'z'   => 0,	# dummy flag for iCserver calls -R iCmqtt -z (stops error message)
    't'   => 0,
    'J'   => 0,
    'O'   => 0,
    'M'   => 0,
    'h'   => 0,
    'f'   => 1,				# include file
    'R'   => 1,				# Run an app
);

my @masks =	(1, 2, 4, 8, 16, 32, 64, 128);
my @bitIndex =	(
    0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,	# 0x01 0x02 0x04 0x08
    4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	# 0x10
    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x20
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x40
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 	# 0x80
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = untaint($0); $named =~ s#.*[/\\]##;
format STDERR =
Usage:
 @<<<<< [-GEBqatJOh][ -T <z>] -F <floor> -I <x> -Q <y> <openHAB>.items
	$named
        [ -s <iC host>][ -p <iC port>][ -N <name>][ -i <inst>]
        [ -m <MQTT host>][ -n <MQTT port>][ -f <file>]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
                COMMON OPTIONS
    -F floor regexp used for selecting one or more floors in openHAB topics
             examples: '[gf]f_[sp]' for two floor topics     (no default)
                       'gf_[sp]' or 'ff_[sp]' two individual floor topics
                           ending in 's' for subscribe and 'p for publish
                       'home/+' many combined floors with same topics for
                           subscribe and publish
                       'home/gelijkvloers' or 'home/verdiep' for two floors
    -I <x>   starting input IEC address IX<x>  (no default)
    -Q <y>   starting output IEC address QX<y> (no default)
    -f file  read flags and additional parameters from this file
       <openHAB>.items file   from openHAB/configuration/items
                GENERATE OPTIONS
    -G       generate auxiliary iC include files:
                 <floor>_OHalias.ih
                 <floor>_OHdeclare.ih
             outputs -I <x> and -Q <y> for next floor
    -E       also generate iC extern file:
                 <floor>_OHextern.ih
    -T <z>   also generate iC test file with IX<z> starting input:
                 <floor>_OHtest.ic with virtual I/O inputs IX<z>
             additionally outputs -T <z> for next floor
                RUN OPTIONS
    -s host  name of iCserver host        (default '127.0.0.1')
    -p port  service port of iCserver     (default '8778')
    -N name  iC registration name         (default <floor>_iCmqtt)
    -i inst  optional instance Id         (1 to 3 numeric digits)
    -m host  name of MQTT broker host     (default '127.0.0.1')
    -n port  service port of MQTT broker  (default '1883')
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients if iCserver
            is started by this @<<<<< call (default 'iCbox')
				$named
    -B      start iCbox -d to monitor active MQTT iC I/Os
    -q      quiet - do not report clients connecting and disconnecting
                DEBUG OPTIONS
    -a      analyse <openHAB>.items file - without -F floor:
               shows Switch selections where actions are not defined
                           - with -F floor:
               checks Switch selections have different id's
    -t      trace debug messages
    -J      trace rcv messages in iCmsgM.pm
    -O      trace send messages in iCmsgM.pm
    -M      display elapsed time in seconds and microseconds
    -h      help, ouput this Usage text only
                AUXILIARY APP   - start a Bernstein chain
    -R <app ...> run one app followed by -z and its arguments as a
                 separate process; -R ... must be last arguments,
                KEYBOARD INPUTS
        q    stops iCserver and all apps if @<<<<< started iCserver
					$named
        Q    stops @<<<<< only
		$named
        T    output iCserver client tables

Copyright (C) 2023-2024  John E. Wulff        <immediateC@gmail.com>
							  '@'
$Id: iCmqtt 1.6 $
.

########################################################################
#	convert POSIX flags to individual flags - process -f -R
########################################################################

my $f = convertFlags(\@ARGV);
print "args    = '", join(" ", @args), "'\n" if $opt_Z;
print "runArgs = '", join(" ", @runArgs), "'\n" if $opt_Z;
@ARGV = @args;

my $nr = qr/-?[1-9]\d*|0(x[\da-fA-F]+|b[01]+|[0-7]*)/;	# precompiled regex for number in all representations
							# NOTE: oct() only handles lower case 0b, 0x
########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use vars qw($opt_F $opt_I $opt_Q $opt_G $opt_E $opt_T $opt_a);
use vars qw($opt_s $opt_p $opt_N $opt_m $opt_n $opt_S $opt_A $opt_i $opt_h);
use vars qw($opt_ $opt_t $opt_J $opt_O $opt_M $opt_B $opt_q $opt_z);
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    ''    => \$opt_,			# lone - (not used)
    '<>'  => sub { push(@argv, @_); },	# Transfer items argument to @argv
    'F=s' => \$opt_F,
    'I=i' => \$opt_I,
    'Q=i' => \$opt_Q,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'N=s' => \$opt_N,
    'i=i' => \$opt_i,
    'm=s' => \$opt_m,
    'n=s' => \$opt_n,
    'S=s' => \$opt_S,
    'A=s' => \$opt_A,
    'T=i' => \$opt_T,
    'G'   => \$opt_G,
    'E'   => \$opt_E,
    'B'   => \$opt_B,
    'q'   => \$opt_q,
    'a'   => \$opt_a,
    'z'   => \$opt_z,	# dummy flag for iCserver calls -R iCmqtt -z (stops error message)
    't'   => \$opt_t,
    'J'   => \$opt_J,
    'O'   => \$opt_O,
    'M'   => \$opt_M,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long GetOptions() ???\n";
print "\$ $named ", join(" ", @args), " -R ", join(" ", @runArgs), "\n" if $f;

if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}
print "argv    = '", join(" ", @argv), "'\n" if $opt_Z;

if ($opt_q) {
    $opt_q = 'q';			# quiet option
} else {
    $opt_q = '';			# define $opt_q
}
$opt_A = 'iCbox' unless $opt_A;
$opt_S = 'iCserver' unless defined $opt_S;

use Time::HiRes qw(usleep gettimeofday);
my ($t0, $t1, $sec, $usec);
if ($opt_M) {
    $t0 = [gettimeofday];	# start of program
}

my $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = "-$opt_i";
	print "instance = '$instance'\n" if $opt_t;
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
	$opt_i = '';
    }
} else {
    $opt_i = '';
}
if (not $opt_a and (not defined $opt_F or not defined $opt_I or not defined $opt_Q)) {
    print STDERR "*** ERROR $named: -F <floor>, -I <x> and -Q <y> must be defined\n";
    write STDERR; exit 1;
}

########################################################################
#
#	Process openHAB items file
#
########################################################################

my ($icVar, $group, $ONadr, $ONbit, $OFFadr, $OFFbit, $onCnt, $offCnt, $stateCnt);
my ($Iflag, $IEC, $bit);
my $icON    = "";
my $icOFF    = "";
my $icQ    = "";
my %icVars = ();
my $state  = "B";		# Base state
my $floor  = $opt_F;
my $floorO = $floor;
$floor     =~ s/\/\+$/\/\\w+/;
$floorO    =~ s/\W/_/g;
$floorO    =~ s/^_+//;
$floorO    =~ s/_+/_/g;
$floorO    =~ s/_$//;
my %IECs   = ();
my $Istart = $opt_I;
my $Qstart = $opt_Q;
my @Ist    = ($Istart);
my @Qst    = ($Qstart);
my $Iadr   = $Istart - 1;
my $Qadr   = $Qstart - 1;
my @Iad    = ();
my @Qad    = ();
my $Ibit   = 7;
my $Qbit   = 7;
my @Ibt    = ();
my @Qbt    = ();
my %TopicChannels = ();
my %ChannelTopics = ();
my %Ips    = ();
my %Qps    = ();
my @Iprefs = ();
my @Qprefs = ();
my $Ipref  = '';
my $Qpref  = '';
my $Icnt   = 65535;			# large
my $Qcnt;
my $n;

for ($n = 0; $n <= $Icnt; $n++) {
    open IN, $argv[0] or die "Cannot open input file $argv[0]: $!";
    while (<IN>) {
	if ($state eq "B" and m/^\s*Switch\s+\w+\s+"(.*)"(\s+<.*>)?\s+\((.*)\)/) {
	    ($group) = split /,/, $3;
	    $icVar = "$group $1";
	    $icVar =~ s/\W/ /g;
	    $icVar =~ s/\s+/_/g;
	    $state = "S";		# Switch state
	} elsif ($state eq "S") {
	    if (m/^\s*{\s*mqtt\s*=\s*"\s*$/) {
		$onCnt = $offCnt = $stateCnt = 0;
		$state = "M";
	    } else {
		$icVars{$icVar} = "ON/OFF action defined in homecontrol.rules";
		$state = "B";
	    }
	} elsif ($state eq "M") {
	    if (m/^\s*>\[\w+:(($floor)(\/\w+)+):command:ON:/) {
		if (not $Ipref) {
		    $Ips{$2}++;
		} elsif ($2 eq $Ipref) {
		    if ($icVar ne $icON) {
			if (++$Ibit > 7) {
			    $Iadr++;
			    $Ibit = 0;
			}
			$ONadr = $Iadr;
			$ONbit = $Ibit;
			$icON = $icVar;
			push(@{ $IECs{"IX$ONadr"}[$ONbit] }, $icVar."_ON");	# iC variable
		    }
		    push(@{ $IECs{"IX$ONadr"}[$ONbit] }, "$1:ON");		# topic:ON
		    $onCnt++;
		}
	    } elsif (m/^\s*>\[\w+:(($floor)(\/\w+)+):command:OFF:/) {
		if (not $Ipref) {
		    $Ips{$2}++;
		} elsif ($2 eq $Ipref) {
		    if ($icVar ne $icOFF) {
			if (++$Ibit > 7) {
			    $Iadr++;
			    $Ibit = 0;
			}
			$OFFadr = $Iadr;
			$OFFbit = $Ibit;
			$icOFF = $icVar;
			push(@{ $IECs{"IX$OFFadr"}[$OFFbit] }, $icVar."_OFF");	# iC variable
		    }
		    push(@{ $IECs{"IX$OFFadr"}[$OFFbit] }, "$1:OFF");	# topic:OFF
		    $offCnt++;
		}
	    } elsif (m/^\s*<\[\w+:(($floor)(\/\w+)+):state:/) {
		if (not $Qpref) {
		    $Qps{$2}++;
		} elsif ($2 eq $Qpref) {
		    if ($icVar ne $icQ) {
			if (++$Qbit > 7) {
			    $Qbit = 0;
			    $Qadr++;
			}
			$icQ = $icVar;
			push(@{ $IECs{"QX$Qadr"}[$Qbit] }, $icVar);	# iC variable
		    }
		    push(@{ $IECs{"QX$Qadr"}[$Qbit] }, $1);		# topic
		    $stateCnt++;
		}
	    } elsif (m/^\s*}\s*$/) {
		if ($onCnt != $offCnt and $offCnt != $stateCnt) {
		    print STDERR "*** ERROR: $named: $icVar: onCnt = $onCnt, offCnt = $offCnt stateCnt = $stateCnt\n";
		    $errorFlag++;
		}  elsif ($onCnt != 0) {
		    $icVars{$icVar}++;
		}
		$state = "B";
	    }
	}
    }
    close IN;
    if (not $Ipref) {
	$Icnt = 0;
	foreach $Ipref (sort keys %Ips) {
	    push(@Iprefs, $Ipref);
	    $Icnt++;
	}
	$Qcnt = 0;
	foreach $Qpref (sort keys %Qps) {
	    push(@Qprefs, $Qpref);
	    $Qcnt++;
	}
	if ($Icnt == 0 or $Icnt != $Qcnt) {
	    print STDERR "*** ERROR $named: no topics found\n",
	                 "                  or number of subscribe topics ($Icnt)\n",
			 "                  does not match publish topics ($Qcnt)\n";
	    $errorFlag++;
	    last;
	}
    } else {
	push(@Ist, $Iadr + 1);
	push(@Qst, $Qadr + 1);
	push(@Iad, $Iadr);
	push(@Qad, $Qadr);
	push(@Ibt, $Ibit);
	push(@Qbt, $Qbit);
	$Ibit = $Qbit = 7;			# start with new IECs
    }
    $Ipref = $Iprefs[$n];
    $Qpref = $Qprefs[$n];
}
if ($errorFlag) {
    exit -2;
}

if ($opt_a) {
    foreach $icVar (sort keys %icVars) {
	printf "%34s: %s\n", $icVar, $icVars{$icVar};
    }
    exit 0;
}

if ($opt_G or $opt_E or defined $opt_T) {
    my $Tadr = "";
    for ($n = 0; $n < $Icnt; $n++) {
	$Istart = $Ist[$n];
	$Qstart = $Qst[$n];
	$Iadr   = $Iad[$n];
	$Qadr   = $Qad[$n];
	$Ibit   = $Ibt[$n];
	$Qbit   = $Qbt[$n];
	$Ipref  = $Iprefs[$n];
	$Qpref  = $Qprefs[$n];
	$floorO = $Ipref;
	$floorO    =~ s/\W/_/g;
	$floorO    =~ s/__+/_/g;
	$floorO    =~ s/^_//;
	$floorO    =~ s/_$//;

	open OUT, ">$floorO"."_OHalias.ih" or die "Cannot open output file '$floorO"."_OHalias.ih': $!";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	print OUT "// openHAB alias IEC assignments for \"$Ipref\"\n";
	print OUT "//   Must be included at the end of one .ic file only.\n";
	print OUT "//\n";
	print OUT "// IEC inputs\n";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	if ($instance) {
	    print OUT  "%{\n";
	    print OUT  "#include <stdio.h>\n";
	    print OUT  "#include <string.h>\n";
	    print OUT  "extern char * iC_iccNM;\n";
	    print OUT  "extern char * iC_iidNM;\n";
	    print OUT  "%}\n";
	    print OUT "if (EOI) {\n";
	    printf OUT "    if (strcmp(iC_iidNM, \"%s\") != 0) {\n", $opt_i;
	    printf OUT "	printf(\"*** ERROR: %%s: instance = '%%s' - should be '%s'\\n\", iC_iccNM, iC_iidNM);\n", $opt_i;
	    print  OUT "	iC_quit(SIGUSR2);\n";
	    print OUT  "    }\n";
	    print OUT  "}\n\n";
	}
	$Iflag = 1;
      IEC1:
	foreach $IEC (sort keys %IECs) {
	    for ($bit = 0; $bit < 8; $bit++) {
		my $IECp = \@{ $IECs{$IEC}[$bit] };
		for (my $i = 1; $i < scalar(@$IECp); $i++) {
		    if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			goto GEN1;
		    }
		}
		next;
	      GEN1:
		if ($Iflag) {
		    printf OUT "%-34s = %s;", $IECp->[0], "$IEC.$bit";
		} else {
		    printf OUT "%-7s= %-34s", "$IEC.$bit", $IECp->[0].";";
		}
		my $p = "\t";
		for (my $i = 1; $i < scalar(@$IECp); $i++) {
		    if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			printf OUT "$p// %s\n", $IECp->[$i];
			$p = "\t\t\t\t\t\t";
		    }
		}
		if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		    print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		    print OUT "// IEC outputs\n";
		    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
		    $Iflag = 0;
		    next IEC1;
		} elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		    last;
		}
	    }
	}
	close OUT;
	print "$floorO"."_OHalias.ih generated with IX$Istart - IX$Iadr and QX$Qstart - QX$Qadr\n";

	open OUT, ">$floorO"."_OHdeclare.ih" or die "Cannot open output file '$floorO"."_OHdeclare.ih': $!";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	print OUT "// openHAB declarations for \"$Ipref\"\n";
	print OUT "//   Copy lines declaring variables used or assigned in a .ic\n";
	print OUT "//   file just after the included extern declarations.\n";
	print OUT "//   Then use the variable names in bit expressions or assignments\n";
	print OUT "//   or as parameters in iC function block calls.\n";
	print OUT "//\n";
	print OUT "// iC input declarations\n";
	print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	$Iflag = 1;
      IEC2:
	foreach $IEC (sort keys %IECs) {
	    for ($bit = 0; $bit < 8; $bit++) {
		my $IECp = \@{ $IECs{$IEC}[$bit] };
		for (my $i = 1; $i < scalar(@$IECp); $i++) {
		    if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			goto GEN2;
		    }
		}
		next;
	      GEN2:
		printf OUT "imm bit %-34s", $IECp->[0].";";
		my $p = "\t";
		for (my $i = 1; $i < scalar(@$IECp); $i++) {
		    if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			printf OUT "$p// %s\n", $IECp->[$i];
			$p = "\t\t\t\t\t\t";
		    }
		}
		if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		    print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
		    print OUT "// iC output declarations\n";
		    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
		    $Iflag = 0;
		    next IEC2;
		} elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		    last;
		}
	    }
	}
	close OUT;
	print "$floorO"."_OHdeclare.ih generated\n";

	if ($opt_E) {
	    open OUT, ">$floorO"."_OHextern.ih" or die "Cannot open output file '$floorO"."_OHextern.ih': $!";
	    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	    print OUT "// openHAB extern declarations for \"$Ipref\"\n";
	    print OUT "//   Must be included at the beginning of each .ic file if more\n";
	    print OUT "//   than one .ic file is linked\n";
	    print OUT "//\n";
	    print OUT "// iC extern input declarations\n";
	    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	    $Iflag = 1;
	  IEC3:
	    foreach $IEC (sort keys %IECs) {
		for ($bit = 0; $bit < 8; $bit++) {
		    my $IECp = \@{ $IECs{$IEC}[$bit] };
		    for (my $i = 1; $i < scalar(@$IECp); $i++) {
			if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			    not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			    goto GEN3;
			}
		    }
		    next;
		  GEN3:
		    printf OUT "extern imm bit %-34s", $IECp->[0].";";
		    my $p = "\t";
		    for (my $i = 1; $i < scalar(@$IECp); $i++) {
			if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
			    not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
			    printf OUT "$p// %s\n", $IECp->[$i];
			    $p = "\t\t\t\t\t\t";
			}
		    }
		    if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
			print OUT "\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
			print OUT "// iC extern output declarations\n";
			print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
			$Iflag = 0;
			next IEC3;
		    } elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
			last;
		    }
		}
	    }
	    close OUT;
	    print "$floorO"."_OHextern.ih generated\n";
	}

	if (defined $opt_T) {
	    open OUT, ">$floorO"."_OHtest.ic" or die "Cannot open output file '$floorO"."_OHtest.ic': $!";
	    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
	    print OUT "// openHAB - iC test application for \"$Ipref\"\n";
	    print OUT "//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
	    print OUT "imm bit relay(bit sw, bit ohON, bit ohOFF) {\n";
	    print OUT "    imm bit swR = RISE(sw);\n";
	    print OUT "    this = JK(swR | ohON, swR | ohOFF);\n";
	    print OUT "}\n\n";
	    if ($opt_E) {
		print OUT "%include \"$floorO"."_OHextern.ih\"\n";
	    }
	    print OUT "%include \"$floorO"."_OHdeclare.ih\"\n\n";
	    my $Ia = $opt_T;
	    foreach $IEC (sort keys %IECs) {
		if ($IEC =~ m/^Q/) {
		    for ($bit = 0; $bit < 8; $bit++) {
			my $IECp = \@{ $IECs{$IEC}[$bit] };
			for (my $i = 1; $i < scalar(@$IECp); $i++) {
			    if ($IECp->[$i] =~ m/^$Qpref/) {
				goto GEN4;
			    }
			}
			next;
		      GEN4:
			printf OUT "%-34s = relay(%s, %s, %s);\n",
			    $IECp->[0], "IX$Ia.".$bit,
			    $IECp->[0]."_ON", $IECp->[0]."_OFF";
			last if $bit == $Qbit and $IEC eq "QX$Qadr";
		    }
		    $Ia++;		# is incremented correctly for floors not output here
		}
	    }
	    print OUT "\n%include \"$floorO"."_OHalias.ih\"\n";
	    close OUT;
	    print "$floorO"."_OHtest.ic generated\n";
	    $Tadr = " -T $Ia";
	}

    }
    $Iadr++; $Qadr++;
    print " -I $Iadr -Q $Qadr$Tadr # input and output IEC addresses for next -G run\n";
    exit 0;
}
print "$named running with IX$Istart - IX$Iadr and QX$Qstart - QX$Qadr registered.\n";

########################################################################
#
#	Connect to iCserver and register I/Os
#
#	Inhibit Nagle's algorithm
#
########################################################################

my $host = defined $opt_s ? $opt_s : '127.0.0.1';
my $port = defined $opt_p ? $opt_p : 8778;
my $name = untaint($opt_N ? "$opt_N$instance" : $floorO."_mqtt$instance");
$named = $name;			# use individual ID for warnings from now on

connect_to_server();

########################################################################
#
#  Additional code to connect to an MQTT broker
#
########################################################################

use Net::MQTT::Simple;

my $m_host = defined $opt_m ? $opt_m : 'localhost';
my $m_port = defined $opt_n ? $opt_n : 1883;

# Allow unencrypted connection with credentials
$ENV{MQTT_SIMPLE_ALLOW_INSECURE_LOGIN} = 1;

# Connect to broker
print "##### Net::MQTT::Simple->new(\"$m_host:$m_port\");\n" if $opt_t;
my $mqtt = Net::MQTT::Simple->new("$m_host:$m_port");
# subscribe to all topic-prefixes controled by this instance of iCmqtt
for ($n = 0; $n < $Icnt; $n++) {
    $Ipref = $Iprefs[$n];
    print "MQTT: subscribe \"$Ipref/#\"\n" if $opt_t;
    $mqtt->subscribe("$Ipref/#", \&mqttReceived);
}

############# send registration ############################

my $dir;			# direction 'S' or 'R'
my $register = 1;		# tested in rcvd_msg_from_server() for registration reply
my $ri = 0;			# registration index used in rcvd_msg_from_server()
$UnitRegistrations = "N$name";	# initiate registration string

for ($n = 0; $n < $Icnt; $n++) {
    $Iadr   = $Iad[$n];
    $Qadr   = $Qad[$n];
    $Ibit   = $Ibt[$n];
    $Qbit   = $Qbt[$n];
    $Ipref  = $Iprefs[$n];
    $Qpref  = $Qprefs[$n];
    $Iflag = 1;
  IEC4:
    foreach $IEC (sort keys %IECs) {
	my $from = 0;
	if ($IEC =~ /^I/) {
	    $dir = 'S';
	} elsif ($IEC =~ /^Q/) {
	    $dir = 'R';
	} else {
	    die "$named: invalid argument '$IEC' - internal error";
	}
	for ($bit = 0; $bit < 8; $bit++) {
	    my $IECp = \@{ $IECs{$IEC}[$bit] };
	    for (my $i = 1; $i < scalar(@$IECp); $i++) {
		if ($Iflag and $IECp->[$i] =~ m/^$Ipref/ or
		    not $Iflag and $IECp->[$i] =~ m/^$Qpref/) {
		    goto RUN1;
		}
	    }
	    next;
	  RUN1:
	    $from |= $masks[$bit];
	    if ($Iflag and $bit == $Ibit and $IEC eq "IX$Iadr") {
		$Iflag = 0;
		last;
	    } elsif ($bit == $Qbit and $IEC eq "QX$Qadr") {
		last;
	    }
	}
	next IEC4 if $from == 0;
	push @ArgNames, [ $IEC, $from ];		# argument order for handling ack
	$IEC .= $instance if $instance ne '';
	$IEC .= "($from)" if $from < 255;
	print "register: $dir$IEC\n" if $opt_t;
	if ((length($UnitRegistrations) + length($IEC)) > 1396) {	# REPLY 1400 - (1+2+1) in tcpc.h
	    print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
	    $conn->send_now($UnitRegistrations);		# unlikely to overflow - tested with length() < 139
	    my ($tmsg, $terr) = $conn->rcv_now();		# receive registration acknowledgment
	    print "$named: Reply: $tmsg\n" if $opt_t;
	    rcvd_msg_from_server($conn, $tmsg, $terr);	# process registration acknowledgment
	    $UnitRegistrations = "$dir$IEC"	# start new $unitRegistrations without comma
	} else {
	    $UnitRegistrations .= ",$dir$IEC";	# direction 1 ',Z' 2 term 1
	}
    }
}
$UnitRegistrations .= ",Z";			# terminate registration string
print "$named: UnitRegistrations: $UnitRegistrations\n" if $opt_t;
$conn->send_now($UnitRegistrations);
my ($tmsg, $terr) = $conn->rcv_now();		# receive final registration acknowledgment
print "$named: Reply: $tmsg\n" if $opt_t;
rcvd_msg_from_server($conn, $tmsg, $terr);	# process final registration acknowledgment

############# registration analysis ########################
$ri == scalar @ArgNames or
    die "$named: $ri: not enough registration replies from iCserver - system error";
$register = 0;
############# correct number of registration replies #######

########################################################################
#	Optionally start an iCbox -d to monitor all MQTT iC I/Os
########################################################################

if ($opt_B) {
    my $boxParams = "iCbox -d -n $named-IO";
    $boxParams .= " -s $host" unless $host eq "localhost" or $host eq "127.0.0.1";
    $boxParams .= " -p $port" unless $port eq "8778";
    for (my $i = 0; $i < scalar @ArgNames; $i++) {
	my ($IEC, $from) = @{$ArgNames[$i]};	# all argument base names and bit masks
	$IEC .= $instance if $instance ne '';
	$IEC .= ",$from" if $from < 255;
	$boxParams .= " $IEC";
    }
    print "MONITOR: '$boxParams'\n" if $opt_t;
    fork_and_exec($boxParams);			# run iCbox -d
}

########################################################################
#	Optionally run -R option
########################################################################
if (@runArgs) {
    splice(@runArgs, 1, 0, "-s", "$host") unless $host eq "localhost" or $host eq "127.0.0.1";
    splice(@runArgs, 1, 0, "-p", "$port") unless $port eq "8778";
    splice(@runArgs, 1, 0, "-i", "$opt_i") unless $opt_i eq "";
    splice(@runArgs, 1, 0, "-z$opt_q",);
    print "at fork	runArgs: '", join(':', @runArgs), "'\n" if $opt_t;
    fork_and_exec(@runArgs);
}

########################################################################
#
#	Register an event handler callback for STDIN to recognise
#	q or ctrl+D from the keyboard to terminate the program
#	unless $opt_z (-z) which blocks STDIN if called in a chain.
#
#	Sit in an infinite loop dispatching incoming events.
#	if connected to iCserver
#
########################################################################
iCmsgM->set_event_handler(*STDIN, "read" => \&readStdin) unless $opt_z;
iCmsgM->event_loop($mqtt);

####### End of main program ############################################

########################################################################
#
#	This is the MQTT callback function, when a message arrives for
#	the subscribed topic
#
########################################################################

sub mqttReceived
{
    my ($topic, $message) = @_;
    print "M: $named:	< $topic $message\n" if $opt_t;
    my $topicP = \@{ $TopicChannels{"$topic:$message"} };
    if ($topicP) {
	my ($channel, $mask) = @$topicP;
	send_input($channel, $mask);		# rise of the iC output pulse
	########################################################################
	#  Avoid using ualarm() because pulses for different topics cannot
	#  be high simultaneously and terminated correctly with SIG{ALRM}.
	#  usleep() makes pulses sequential with 50 ms resolution, which
	#  should be sufficient for manual events from openHAB.
	########################################################################
	usleep(100_000);				# sleep 100 ms
	send_input($channel, 0);			# fall of the iC output pulse
    } else {
	print STDERR "*** ERROR $named: received '$topic:$message' not ON or OFF\n";
    }
} # mqttReceived

########################################################################
#
#	Convert from Posix bundled flag interpretation to Go type flags.
#	Extract -f flag and open next argument as an include file
#	Extract first -R flag and save all further arguments in runArgs
#
#	Modify command line bundled flags to interpret -abc as -a -b -c,
#	which is the way flag.Parse must be presented with Bool flags.
#	flag.Parse interprets -abc as the flag named "abc".
#	Mofify Value flags to interpret -xVal as -x Val. Can also have
#	-abcx Val or -abcxVal, which are both converted to -a -b -c -x Val.
#	Value flags could be identified by the flag initialisers above,
#	but it is simpler to define a map of Value flag identifiers.
#	Command line flags starting with -- are not touched, which is the
#	Posix way of mixed flags starting with - or --.
#	https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#
#	The -f <include file> argument opens the include file, which is
#	trimmed of extraneous spaces and comments and produces another slice
#	of command line arguments. A recursive call of convertFlags() moves
#	these arguments into args and runargs, replacing the f<> argument.
#
#	The -R option starts a Bernstein chain. Each -R option in the chain
#	starts a new iC app. Apps in a Bernstein chain are started sequentially
#	to run their initialization code, at which point the app starts
#	the next iC app in the Bernstein chain with its -R option. The
#	current app keeps running in parallel with the app that started it.
#	Finally all iC apps in a Bernstein chain run in parallel after their
#	initialization codes have been run sequentially.
#	The first iC app in the Bernstein chain must have the -z option, which
#	suppresses stdin interrupts. This is necessary, because programs started
#	with exec.Command().run() close stdin, which causes EOF for stdin in
#	the iC app, which causes it to shut down. -z suppresses that.
#
#	Modifying command line options and interpreting -f is stopped after the
#	first -R option because any further options are interpreted by apps in the
#	Bernstein chain and may not be set correctly in the commandLineFlags map.
#
########################################################################

sub convertFlags {
    my ($argp) = @_;
    print "cF:	*argp = '", join(" ", @{$argp}), "'\n" if $opt_Z;
    my $Fflag = 0;
    foreach my $arg (@{$argp}) {
	if (length($arg) == 0) { next; }
	print "    \"$arg\"\n" if $opt_Z;
	my $Sflag = 1;
	my $s0 = substr $arg, 0, 1;
	my $s1 = substr $arg, 1, 1;
	if ($arg ne "-" && $s0 eq '-' && $s1 ne '-' && ($Rflag eq 0 || $s1 eq 'R')) {
	    $Sflag = 0;
	    my $i     = 0;
	    foreach my $sf (split(//, substr($arg, 1))) {
		print "	$sf	Sflag = $Sflag	Rflag = $Rflag	Fflag = $Fflag\n" if $opt_Z;
		unless (exists $commandLineFlags{$sf}) {
		    $arg = substr($arg, $i+1);	# not a flag value
		    $Sflag = 1;
		    last;
		}
		if ($sf eq "R" && $Rflag == 0) {
		    $Rflag = 1;			# first -R not appended to args or runArgs
		    $argsP = \@runArgs		# now fill arguments for -R option in runArgs
		} elsif ($sf eq "f" && $Rflag == 0) {
		    $Fflag = 1;
		} else {
		    push(@{$argsP}, "-$sf");
		}
		if ($commandLineFlags{$sf} == 1 && $i+2 < length($arg)) {
		    $arg = substr($arg, $i+2);	# value flag followed directly by value
		    $Sflag = 1;
		    last;
		}
		$i++;
	    }
	}
	print "		Sflag = $Sflag	Rflag = $Rflag	Fflag = $Fflag\n" if $opt_Z;
	if ($Sflag) {
	    if (not $Fflag) {
		push(@{$argsP}, $arg);		# append a value after a value flag
	    } else {
		my @incArgs;
		open IN, $arg or die "can't open ID file $arg! $!";
		LINE:
		while (<IN>) {			# read next entry from include file into $_
		    chomp;
		    print "$arg:$.: '$_'\n" if $opt_Z;
		    s/(^\s+)|(\s*(#.*)?$)//g;	# strip leading space and trailing comment
		    s/\s*([=:,;.])\s*/$1/g;	# remove spaces around separators
		    if (length($_) > 0) {
			push(@incArgs, split(" ", $_));
		    }
		}
		close IN;
		if (@incArgs) {
		    print "cF:	incArgs = '", join(" ", @incArgs), "'\n" if $opt_Z;
		    convertFlags(\@incArgs)	# recursive call to add options in include file
		}
	    }
	}
    }
    return $Fflag;
} # convertFlags

########################################################################
#
#	Quit program and stop iCserver, which stops all registered apps
#	unless 'Q' is pressed, which is useful for testing disconnect
#
########################################################################

sub quit_program {
    my (undef, $flag) = @_;
    print "$named: quit\n" if $opt_t;
    if ($conn) {
	if (not $flag) {
	    $conn->send_now("X$named");		# stop iCserver - (X), 'q' or disconnected by server
	} else {
	    $conn->send_now("");		# disconnect this app at iCserver only - 'Q'
	}
	$conn->disconnect();
    }
    $mqtt->disconnect();
    exit(0);
} # quit_program

########################################################################
#
#	Convert a number string obtained with $nr to an integer value
#	Parameter 1:	dec, bin, oct or hex number string - dec may be signed
#	Parameter 2:	default value
#	Parameter 3:	name of argument being converted
#	retun numerical value or default value if parameter 1 undef or ''
#
########################################################################

sub convert_nr {
    my ($val, $default, $argv) = @_;
    return $default if not defined $val or $val eq '';
    if ($val =~ /^-\s*0/) {
	$val = 0;
	print "\n" if $opt_t;
	warn "$named: $argv: bin, oct or hex numbers may not be signed - ignore initialiser\n";
    } else {
	$val = oct($val) if $val =~ /^0/;	# handles 017 0xf 0b1111
    }
    $val = int($val);				# initialize to a number for correct AND/OR
    return $val;
} # convert_nr

########################################################################
#
#	Send input value
#
########################################################################

sub send_input {
    my ($ch, $val) = @_;
    if ($val != $ChannelsI[$ch]) {
	$ChannelsI[$ch] = $val;		# always save latest value sent on this channel
	printMicroSeconds();
	print "M: $named: " if $opt_t and not $opt_M;
	print "$ch:$val	> $ChannelNames[$ch]\n" if $opt_t;
	printf "%s	> %2d:%d\n", $ChannelNames[$ch], $ch, $val if $opt_O;
	$conn->send_now("$ch:$val");		# send latest value
    }
} # send_input

########################################################################
#
#	Receive message from server - adjust outputs - ack registrations
#
########################################################################

sub rcvd_msg_from_server {
    my ($conn, $msg, $err) = @_;
    if (defined $msg) {
        my $len = length $msg;
	if ($len == 0) {
	    print STDERR "iCmqtt '$named' disconnected by server\n" unless $opt_q;
	    quit_program();			# never returns
	}
	my ($msg1, $channel, $value, $old, $bitRef, $from, $regId, $bit);
	foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
	    if ($msg1 =~ /^(\d+):(-?\d+)$/) {
		$channel = $1;			## receive data as channel:value
		$value   = $2;			## decimal value with optional sign
		$old = $ChannelsQ[$channel];
		if (defined $old) {
		    if ($value != $old) {
			printMicroSeconds();
			print "M: $named: " if $opt_t and not $opt_M;
			print "$msg1	< $ChannelNames[$channel]\n" if $opt_t;
			printf "%s	< %2d:%d\n", $ChannelNames[$channel], $channel, $value if $opt_J;
			# stores computed bit value for all QXn.<0..7> outputs
			$bitRef = $ChannelsQX[$channel];
			if (defined $bitRef) {		# only defined for QXm digital
			    my ($diff, $mask);
			    goto WrongFormat if $value > 0xff;		# only 8 bit map allowed
			    $diff = $old ^ $value;	# $old initialized to a number for correct XOR
			    while ($diff) {		# age old algorithm from CSR days
				$mask = $diff & -$diff;	# rightmost set bit from diff
				$bit = ${$bitRef}[$bitIndex[$mask]] = ($value & $mask) ? 1 : 0;
				$diff &= ~$mask;	# modify viewable output - clear rightmost bit
				my $state = $bit ? "ON" : "OFF";
				# Publish MQTT message(s)
				my $ChannelTopicP = \@{ $ChannelTopics{$channel}[$bitIndex[$mask]] };
				for (my $i = 0; $i < scalar(@$ChannelTopicP); $i++) {
				    my $topic = $ChannelTopicP->[$i];
				    print "M: $named:	> $topic $state\n" if $opt_t;
				    $mqtt->publish($topic, $state);
				}
			    }
			}
			$ChannelsQ[$channel] = $value;	# ready for next message
		    }
		} else {
		    warn "$named: not registered for $msg1 from iCserver - not OK\n";
		}
	    } elsif ($register and $msg1 =~ /^(-?\d+)$/) {
		next if $1 eq '-0';		## null acknowledgment
		$channel = $1;			## receive channel of a registration acknowledgment
		($IEC, $from) = @{$ArgNames[$ri]};	# all argument values
		defined $IEC or
		    die "$named: too many registration acknowledgments from iCserver - system error";
		print "$named: $ri: registering '$IEC' on channel '$channel'\n" if $opt_t;
		$ri++;
		my $dir = '';
		if ($IEC =~ m/^Q([XBWL])/) {
		    if ($channel == 0) {	# /^I([XBWL])/ if $opt_r
			warn "$named: trying to register receiver '$IEC' at channel 0 - error\n";
			next;
		    }
		    $dir = 'R';
		    if ($channel < 0) {
			$channel = -$channel;
			print "$named: registering receiver '$IEC' on channel $channel twice - equivalence\n" if $opt_t;
		    } else {
			$ChannelsQ[$channel] = 0;	# initial value and Q definition
			## when this array element is defined, it is a Q[XBWL] receiver (or I[XBWL] if $opt_d or $opt_r)
			if ($1 eq 'X') {
			    @{$ChannelsQX[$channel]}[0..7] = (0,0,0,0,0,0,0,0);
			    for my $bit (0 .. 7) {
				my $IECp = \@{ $IECs{$IEC}[$bit] };
				for (my $i = 1; $i < scalar(@$IECp); $i++) {
				    my $topic = $IECp->[$i];
				    printf ">>> %s.%d '%s' %d:%02x\n", $IEC, $bit, $topic, $channel, $masks[$bit] if $opt_t;
				    push(@{ $ChannelTopics{$channel}[$bit] }, $topic);		# topic
				}
			    }
			    ## when this array slice is defined, channel is a QXx.y
			    ## Q[BWL]n have this slice undefined for their channel
			}
		    }
		}
		elsif ($IEC =~ m/^I([XBWL])/) {
		    if ($channel == 0) {
			warn "$named: trying to register sender '$IEC' twice - not allowed\n";
			next;
		    }
		    $dir = 'S';
		    if ($1 eq 'X') {
			for my $bit (0 .. 7) {
			    my $IECp = \@{ $IECs{$IEC}[$bit] };
			    for (my $i = 1; $i < scalar(@$IECp); $i++) {
				my $topic = $IECp->[$i];
				printf "<<< %s.%d '%s' %d:%02x\n", $IEC, $bit, $topic, $channel, $masks[$bit] if $opt_t;
				$TopicChannels{$topic} = [ $channel, $masks[$bit] ];
			    }
			}
			## when this array slice is defined, channel is a IXx.y
			## I[BWL]n have this slice undefined for their channel
		    }
		    ## initial value and I definition
		    $ChannelsI[$channel] = 0;
		    ## when this array element is defined, it is a I[XBWL] sender
		}
		if ($dir) {
		    $regId = "$dir$IEC";
		    $ChannelNames[$channel] = "$IEC";
		    print "register: $regId channel = $channel from = '$from'\n" if $opt_t;
		}
	    } else {
	      WrongFormat:
		warn "$named: WARNING: '$msg1' out of '$msg' from iCserver has wrong format - ignored";
	    }
	}
    } elsif (not $opt_q) {
	warn "$named: undefined messagefrom iCserver - ignored $err";
    }
} # rcvd_msg_from_server

########################################################################
#
#	Connect to iCserver
#	connection is maintained until iCmqtt shuts down or iCserver disconnects
#
#	Inhibit Nagle's algorithm
#
########################################################################

sub connect_to_server {
    my $i = 0;
    my @s;
    if ($server >= 0) {
	iCmsgM->inhibit_nagle(1, $opt_J, $opt_O);# Nagle's algorithm for real time response
	while (1) {
	    $conn = iCmsgM->connect($host, $port, \&rcvd_msg_from_server, 1); # return imme if connect fails
	    if ($conn) {
		print STDERR "$named connected to server at '$host:$port'\n" unless $opt_q;
		last;
	    }
	    if ($server == 0) {
		@s = split(" ", $opt_S);
		print "\@s = '@s'\n" if $opt_t;
		splice(@s, 1, 0, "-z$opt_q", "-k", "-A", "$opt_A");	# block STDIN for chained iCserver
		splice(@s, 1, 0, "-p", "$port") unless $port eq "8778";
		print "\@s = '@s'\n" if $opt_t;
		if ($host eq "localhost" or $host eq "127.0.0.1") {
		    fork_and_exec(@s);	# start iCserver
		    $server = 1;		# remember that this iC app started iCserver
		} else {
		    warn "$named: '@s' cannot be started here - start it on '$host' (ctrl-C to stop)\n";
		    $server = 2;		# waiting for start of iCserver on a remote host
		}
	    } elsif ($server > 0) {
		if ($server == 2 or $i++ < 4) {
		    print "$named: $i: wait 2 seconds for iCserver to start\n" if $opt_t;
		    select undef, undef, undef, 2;
		} else {
		    warn "$named: waited 8 seconds for '@s' to start - give up\n";
		    $server = -1;	# something wrong with iCserver
		    exit 3;
		}
	    }				# try to connect immediately
	}
    }
} # connect_to_server

########################################################################
#
#	Read from STDIN
#
########################################################################

sub readStdin {
    my $line = readline(STDIN);
    if (not defined $line or $line =~ m/^q/) {	# ctrl+D (EOF) or q
	if ($server >= 1) {
	    quit_program();				# this iC app started iCserver - stop it
	} else {
	    print "$named: stopped from terminal\n";
	    quit_program(undef, 1);			# quit without stopping iCserver
	}
    } elsif ($line =~ m/^Q/) {
	quit_program(undef, 1);				# quit without stopping iCserver
    } elsif ($line =~ m/^T/) {
	$conn->send_now("T") if $conn;			# show iCserver client tables
    } elsif ($line !~ m/^$/) {
	warn("*** WARNING: $named: not recognised: $line");
    }
} # readStdin

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    print STDERR "\$ @_ &\n" unless $opt_q;
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Compute and print elapsed microseconds
#
########################################################################

sub printMicroSeconds {
    if ($opt_M) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "M: $named: %3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "M: $named: %3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
	$t0 = $t1;
    }
} # printMicroSeconds

########################################################################
#
#	Untaint a string for executing from a setuid program
#
########################################################################

sub untaint {
    my ($string) = @_;
    if ($string =~ m/^([-\@\w.\/\\]+)$/) {
	return $1;		# now untainted
    } else {
	die "Bad data in $string";
    }
} # untaint
__END__

############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iCmqtt - a bi-directional interface between openHAB MQTT and immediate C

=head1 SYNOPSIS

 iCmqtt [-GEBqatJOh][ -T <z>] -F <floor> -I <x> -Q <y> <openHAB>.items
        [ -s <iC host>][ -p <iC port>][ -N <name>][ -i <inst>]
        [ -m <MQTT host>][ -n <MQTT port>][ -f <file>]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
                COMMON OPTIONS
    -F floor regexp used for selecting one or more floors in openHAB topics
             examples: '[gf]f_[sp]' for two floor topics     (no default)
                       'gf_[sp]' or 'ff_[sp]' two individual floor topics
                           ending in 's' for subscribe and 'p for publish
                       'home/+' many combined floors with same topics for
                           subscribe and publish
                       'home/gelijkvloers' or 'home/verdiep' for two floors
    -I <x>   starting input IEC address IX<x>  (no default)
    -Q <y>   starting output IEC address QX<y> (no default)
    -f file  read flags and additional parameters from this file
       <openHAB>.items file   from openHAB/configuration/items
                GENERATE OPTIONS
    -G       generate auxiliary iC include files:
                 <floor>_OHalias.ih
                 <floor>_OHdeclare.ih
             outputs -I <x> and -Q <y> for next floor
    -E       also generate iC extern file:
                 <floor>_OHextern.ih
    -T <z>   also generate iC test file with IX<z> starting input:
                 <floor>_OHtest.ic with virtual I/O inputs IX<z>
             additionally outputs -T <z> for next floor
                RUN OPTIONS
    -s host  name of iCserver host        (default '127.0.0.1')
    -p port  service port of iCserver     (default '8778')
    -N name  iC registration name         (default <floor>_iCmqtt)
    -i inst  optional instance Id         (1 to 3 numeric digits)
    -m host  name of MQTT broker host     (default '127.0.0.1')
    -n port  service port of MQTT broker  (default '1883')
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients if iCserver
            is started by this iCmqtt call (default 'iCbox')
    -B      start iCbox -d to monitor active MQTT iC I/Os
    -q      quiet - do not report clients connecting and disconnecting
                DEBUG OPTIONS
    -a      analyse <openHAB>.items file - without -F floor:
               shows Switch selections where actions are not defined
                           - with -F floor:
               checks Switch selections have different id's
    -t      trace debug messages
    -J      trace rcv messages in iCmsgM.pm
    -O      trace send messages in iCmsgM.pm
    -M      display elapsed time in seconds and microseconds
    -h      help, ouput this Usage text only
                AUXILIARY APP   - start a Bernstein chain
    -R <app ...> run one app followed by -z and its arguments as a
                 separate process; -R ... must be last arguments,
                KEYBOARD INPUTS
        q    stops iCserver and all apps if iCmqtt started iCserver
        Q    stops iCmqtt only
        T    output iCserver client tables

=head1 DESCRIPTION

The program B<iCmqtt> is a bi-directional interface between an MQTT
broker and iCserver. It deals with openHAB topics and message content
available from a connected MQTT broker. B<iCmqtt> subsribes to openHAB
topics, which are ON and OFF commands. When a message for a subscribed
topic is received, iCmqtt sends a 100 ms pulse to iCserver for an
input IEC variable eg IX10.0.  When a 'state' variable is received
from iCserver from an IEC output variable eg QX10.0, B<iCmqtt>
publishes the openHAB topic and state.

As an extra service B<iCmqtt> -G generates the include files:
     <floor>_OHalias.ih and <floor>_OHdeclare.ih and optionally
     <floor>_OHextern.ih with the additional -E flag and a test app
     <floor>_OHtest.ic with virtual I/O inputs IX<z> with -T <z>
for every floor to provide descriptive iC variable alias names for
IX... and QX...

The translation between MQTT topic names and iEC-1131 I/O names is
extracted from 'openHAB/configurations/items/<openHAB>.items'.
The following are two typical entries:

Switch Sw_Sitting_Area "Sitting area" <switchnew> (ff_RBD, Lights)
    {mqtt="
    >[geertvc:home/ff_s/LightChange/Lt_Sitting_Area:command:ON:MAP(openclose.map)],
    >[geertvc:home/ff_s/LightChange/Lt_Sitting_Area:command:OFF:MAP(openclose.map)],
    <[geertvc:home/ff_p/LightChange/Lt_Sitting_Area:state:MAP(openclose.map)]"
    }

Switch Sw_Bedroom "Bedroom" <switchnew> (ff_RBD, Lights)
    {mqtt="
    >[geertvc:home/ff_s/LightChange/Lt_Bedroom:command:ON:MAP(openclose.map)],
    >[geertvc:home/ff_s/LightChange/Lt_Bedroom:command:OFF:MAP(openclose.map)],
    <[geertvc:home/ff_p/LightChange/Lt_Bedroom:state:MAP(openclose.map)]"
    }

It is strongly recommended, that the prefix of the topic for
subscribing to ON and OFF openHAB messages be different from the prefix
of the similar topic for publishing the state. In the examples the
prefixes are home/ff_s for subscribing and home/ff_p for publishing
to openHAB. If the prefixes and hence the whole topic for subsribing
and publishing are the same, state messages published by iCmqtt are
immediately sent back by MQTT to iCmqtt, which then transmits them to
the immediate C app. Usually this does not do any harm, because the
value received (ON=1 or OFF=0) by the iC app will try to maintain the
state just published. But it does mean the data traffic is doubled
for no reason.

iCmqtt generates two files for each floor - example for one floor from the entries above:

    1. The actual alias assignments - home_ff_OHalias.ih,
       which is included last in the iC control program.
       The iC names are generated from the the 'Switch' line of each openHAB item, derived
       from the first group identifier in the finial group list in round brackets and the
       parenthesized text earlier in the Switch line.

    ff_RBD_SittingArea_ON  = IX10.0;    // home/ff_s/LightChange/Lt_Sitting_Area:command:ON
    ff_RBD_SittingArea_OFF = IX10.1;    // home/ff_s/LightChange/Lt_Sitting_Area:command:OFF
    QX10.0 = ff_RBD_SittingArea;        // home/ff_p/LightChange/Lt_Sitting_Area:state

    ff_RBD_Bedroom_ON      = IX10.2;    // home/ff_s/LightChange/Lt_Bedroom:command:ON
    ff_RBD_Bedroom_OFF     = IX10.3;    // home/ff_s/LightChange/Lt_Bedroom:command:OFF
    QX10.1 = ff_RBD_Bedroom;            // home/ff_p/LightChange/Lt_Bedroom

       IX<x> and QX<y> variable names are chosen by iCmqtt starting with the I <x> and
       Q <y> command line parameters. Bit 0 - 7 are used for the first 8 entries. Then
       <x> or <y> is incremented. The final IX... and QX... generated is output after
       generation to allow selection of a second inon-clashing range of IX... and QX...
       for another floor.

    2. The declarations of those variables - home_ff_OHdeclare.ih,
       which is included early in the iC control program.

    imm bit   ff_RBD_SittingArea_ON;    // home/ff_s/LightChange/Lt_Sitting_Area:command:ON
    imm bit   ff_RBD_SittingArea_OFF;   // home/ff_s/LightChange/Lt_Sitting_Area:command:OFF
    imm bit   ff_RBD_SittingArea;       // home/ff_p/LightChange/Lt_Sitting_Area:state

    imm bit   ff_RBD_Bedroom_ON;        // home/ff_s/LightChange/Lt_Bedroom:command:ON
    imm bit   ff_RBD_Bedroom_OFF;       // home/ff_s/LightChange/Lt_Bedroom:command:OFF
    imm bit   ff_RBD_Bedroom;           // home/ff_p/LightChange/Lt_Bedroom

       All iC variables declared above must be used as inputs in the iC control program
       if they are _ON or _OFF and input as IX...
       or assigned if they are state variables output as QX....

    3. The topics between the first pair of colons in the openHab items file and the 'ON'
       and 'OFF' commands as well as the 'state' values ON and OFF derived from Q... values
       1 and 0 are used to subsribe and publish openHAB messages from and to MQTT.

=head1 SPECIFICATION

On startup of B<iCmqtt> the following actions are carried out:

  1) If command line parameter -G is given, the openHAB ini
     file 'openHAB/configurations/items/<openHAB>.items' is used as
     described above to generate include files and optionally an iC
     test program to assist in placing the genrated iC variable names
     for connecting from and to openHAB via iCmqtt and the MQTT broker.

  2) When run without ithe -G command line flag he openHAB ini file
     'openHAB/configurations/items/<openHAB>.items' is scanned again
     and MQTT topics` and iC IEC-1131 I/O names are  extracted.

     a) The <floor> topic prefix associated with the IX... variables
        followed by "/#" is sent as a 'subscribe' message to the MQTT
        broker.

     b) IEC-1131 I/O names starting with 'I' are iC inputs.

        i)   The IEC-1131 I/O base-name is registerd with iCserver as
             a 'sender, which returns a channel nunber.

        ii)  The I/O basename is used as a key in the Hash-file
             %IECs, containing an array for every bit to store
             the iC variable name in the SWitch line extended by
             either :ON or :OFF.

        iii) When MQTT sends a message ON or OFF for one of the
             subscribed topics a 100 ms pulse is sent to the matching
             IX... via the channel number and the bit obtained from
             %IECs.

        vi)  The alias assignment for IX... in <iCinclude>_ass.ih
             will pulse the apropriate descriptive iC variable in
             the iC control program for 100 ms.

     b) IEC-1131 I/O names starting with 'Q' are iC outputs.

        i)   The IEC-1131 I/O base-name is registerd with iCserver as
             a 'receiver, which returns a channel nunber.

        ii)  The I/O basename is used as a key in the Hash-file
             %IECs, containing an array for every bit to store
             the iC variable name in the SWitch line.

        iii) When iCserver sends a value 0 or 1 (LO or HI) on the
             channel and bit associated with the QX... variable, the
             topic obtained via %IECs is published with ON or OFF as
             the states message.

  3) iCserver is started unless it is running already.

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<iCbox(1)>, L<iClive(1)>, L<iCpiI2C(1)>, L<iCserver(1)>, L<immcc(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2023  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
