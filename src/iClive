#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2005  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file or <john@je-wulff.de>
#
#	iClive; display for iC sources and listings
#
#	A full description is in the POD documentation at the end
#
#	For measuring reaction times the Module Time::HiRes is used.
#	This is activated by the -m option.
#	Make sure you have installed Time::HiRes (provided in this distribution)
#
########################################################################

use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use Msg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use Tk::Balloon;
use Tk::Dialog;
use Cwd;
use strict;
use warnings;
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday];	# start of program
my %delayedColour;	# colour that should be restored after a flash

########################################################################
#
#	Colour selection for background/foreground and false/true
#	$colourSelect[ftype] must match the definitions in 'icg.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the false/true colours.
#	ALIAS ftype's are generated by adding MAX_FTY (22) to ftype.
#	ftype MAX_FTY+GATE+INV has an odd 'cs' which inverts the colours.
#	Allow for GATE as well as GATEX by making INV (inversion << 1).
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#	Uses Tk::After. Flash 2 clocks in a row white. This happens if
#	CLOCK or TIMER has 2 slave gates which are fired together.
#
#	the following array is indexed by gt_fni is ftype (see icg.h)
#
#	UDFA	ARITH	GATE	GATEX	RI_BIT	S_SH	R_SH	D_SH	0-8
#	CH_BIT	S_FF	R_FF	D_FF	F_SW	F_CF	F_CE	CLCK	9-15
#	TIMR	TRAB	OUTW	OUTX	CLCKL	TIMRL	F_ERR		16-22
#	MAX_FTY	+ARITH	+GATE	+GATEX	+GATE+INV  ...	+CLCKL	+TIMRL	22-25...42-43
#
#	ftype-abbreviations are used for debugging to list the Symbol Table.
#	They are also indexed by gt_fni (holds ftype). (lines up with FOPS in icc.h)
#
## #define	FOPS	"UA _EsrHVSRDIFGCTBWX:!"	/* DEBUG display of ftypes */
#
########################################################################

my @abbrevSelect  = ( 'U','A',' ','_','E','s','r','H','V','S','R','D','I','F','G',
		      'C','T','B','W','X',':','!',		   # as[ftype] 0 - 21
		      'e','aA','a ','a_','~ ','~_','?','?','?','?','?','?','?','?',
		      '?','?','?','?','?','a:','a!',		   # ALIAS    22 - 43
		    );

my @colourSelect  = ( 0,2,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,2,2,0,4,6, # cs[ftype] 0 - 21
		      0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6, # ALIAS    22 - 43
		    );

#  live colouring     false 0          true 1             cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
							## cs|010 no change
		     'PaleGreen1'   , 'yellow'       ,  # 0 1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 2 3 ARITH
		     'chocolate2'   , 'chocolate2'   ,  # 4 5 CLCKL
		     'CadetBlue'    , 'CadetBlue'    ,  # 6 7 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  # 0 1 GATE
		     'black'        , 'red'          ,  # 2 3 ARITH
		     'black'        , 'white'        ,  # 4 5 CLCKL
		     'black'        , 'white'        ,  # 6 7 TIMRL
							## cs|010 flash glitch
		     'white'        , 'white'        ,  # 0 1 GATE
		     'white'        , 'white'        ,  # 2 3 ARITH
		     'white'        , 'white'        ,  # 4 5 CLCKL
		     'white'        , 'white'        ,  # 6 7 TIMRL
		    );

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
use vars qw($opt_T $opt_t $opt_m $opt_d $opt_s $opt_p $opt_i $opt_f $opt_l $opt_w $opt_g $opt_u $opt_X $opt_h);
format STDERR =
Usage:
@<<<<<<<[ -umtTh][ -s <host>][ -p <port>][ -i <inst>][ -f <font>]
 $named
        [ -l <num>][ -w <num>][ -g <geometry>][ -d <deb>][ <file> ...]
    -s host host name of server    (default 'localhost')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -f font font or font size to use in Text window (default '16')
    -l num  height of the Text window (default @<)
					$opt_l
    -w num  width  of the Text window (default @<)
					$opt_w
    -g geom geometry for main window (-g= is special small window)
    -d deb  extra debug options (see iCapplication -h)
    -t      trace output run time changes in target application (-d100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -u      activate undo edit facility (not recommended if Live display
            is used, because display may skip to lines which change)
    -h      help, ouput this Usage text only
    file ... one or more iC source files. The first will be opened. The
            rest will be stored in the File menu for later selection.

 Menu buttons:                                              Accelerators
    [File] New  provide a new empty file for editing.             Alt-n
       Open     open and load the selected file.                  Alt-o
       Open.lst open the listing x.lst corresponding to x.ic      Alt-l
       Save     save the current file if modified.                Alt-s
       SaveAs   store the current file at the selected path.      Alt-a
       Quit     quit the program.                                 Alt-q

    [Build]     build either the C file or the executable application
                from the currently displayed iC program text.     Alt-b

    [Run/Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [ -]        select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
    /Edit]      clears live markings in the Text window. In this mode the
                text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are described in the Tk::Text man page in the section
                'BINDINGS' near the end.  If called with the -u option,
                ctrl-U is the <<Undo>> binding.

    [Search:]   in the Text window. Text may be scanned for an exact
                match or for a regular expression in the entry window
                next to the button. All hits will be marked. Repeating
                'Search down' or RETURN will display a new group of
                hits. 'Search up' or SHIFT-RETURN reverses the direction
                of scrolling.  Another option is to Go to a line entered
                in the entry window.                             RETURN

    [Help]      display the iClive man page                       Alt-h

Copyright (C) 2000-2005  John E. Wulff          <john@je-wulff.de>
						    '@'
$Id: iClive,v 1.41 2008/02/29 11:17:54 jw Exp $ uses Tk-@<<<<<<<<<
						    $Tk::VERSION
.

require "getopts.pl";
&Getopts('tTmd:s:p:i:f:l:w:g:uXh');	# sets $opt_h if -h etc

exit -1 if $opt_X;		# $named -X called in forked process if first exec fails
$opt_l = 25 unless $opt_l;
$opt_w = 80 unless $opt_w;
if ($opt_h) {
    write STDERR; exit 0;	# -h, ouput Usage only
}

my $u = '';
if ($opt_u) {
    use Tk::TextUndo;		# 7 times slower for live display and jerky
    $u = ' -u';			# show -u option in title when editing
}

my ($fontSize, $font);
if (defined $opt_f) {
    if ($opt_f =~ /^\d+$/) {
	$fontSize = $opt_f;
    } else {
	$font = $opt_f;
    }
}
unless ($font) {
    if ($ENV{COMSPEC}) {	# defined on Windows 98 and Windows XP
	$fontSize = 10 unless $fontSize;
	$font = "{Lucida Console} $fontSize normal";
    } else {			# Linux
	$fontSize = 16 unless $fontSize;
	$font = "-adobe-courier-medium-r-normal--$fontSize-100-100-100-m-90-iso8859-1";
    }
}
no warnings;
print "opt_f = '$opt_f' fontSize = '$fontSize'\nfont     = '$font'\n" if $opt_T;
use warnings;

########################################################################
#
#	Handle signals
#
#	NOTE: a signal to be caught by one of the callbacks below will
#	not be processed, until this application receives focus or handles
#	some other event internally (Problem with Tk::MainLoop())
#
########################################################################

## $SIG{QUIT} = \&quit_program;	# catch signal from (X) button
## $SIG{TERM} = \&quit_program;	# catch signal from signal 15

## $SIG{HUP} = \&catch_sig;	# catch signal 1
## $SIG{INT} = \&catch_sig;	# catch signal 2
## $SIG{QUIT} = \&catch_sig;	# catch signal 3
## $SIG{TERM} = \&catch_sig;	# catch signal 15

$SIG{PIPE} = \&catch_sig;	# catch signal in syswrite() in Msg.pm line 103

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : 'localhost';
my $port = defined $opt_p ? $opt_p : 8778;
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my $maxSymbolLength = 4;
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 0;
my $conn;

my $info = '';		# info messages in status bar
my $infoDisplaying = 0;
my @infoMessages = ();

my $fileName = '';	# name of currently loaded file (should be iC or derivative)
my $fileTime = 0;	# last modified time of currently loaded file
my $procName = '';	# name of runnable iC control program
my $instName = '';	# name of runnable iC control program with instance extension
my $regName = '';
my $runName = '';	# name of running iC control program
my $C_channel = 0;	# receiver channel from control program
my $D_channel = 0;	# sender channel to control program
my $searchText = '';
my $oldContents = '';
my $newName = 'unknown.ic';
my $cwd = cwd;
print "cwd = $cwd\n" if $opt_T;

my $fileTypes = [
    ['iC Source Files',  ['.ic',  '.ih',   ], ['TEXT', ], ],
    ['iC Listing Files', ['.lst',          ], ['TEXT', ], ],
    ['C  Source Files',  ['.c',   '.h',    ], ['TEXT', ], ],
    ['Text Files',       ['.txt', '.text', ],             ],
    ['Text Files',       ['',              ], ['TEXT', ], ],
    ['All Files',        ['*',             ],             ],
];

# in scan() Tk::Text->search() does not accept a pre-compiled regex qr/.../
my $scanPattern = '[~\s]*(-\s*\d+|\w[\w\$]*(\s*\.\s*\w+)?)\s*((~ )?---|=$)?';
my $bMsg = '';		# balloon message
my $wIdx = '';		# Index of current wordstart
my $pIdx = '';		# Index of previous wordstart

# has to be global, 'our' not portable yet
my ($home);
my (@hits, @groups, $gi, $gl, $centre);
my $prevText = '';
my $prevMatch = '';
my $prevStart = 0;
my $prevLast  = 0;
my $server  = 0;

########################################################################
#
#	Create main window and menus
#
#	NOTE: parameters in -command => [ ] closures are taken from the
#	      time the command was executed - not when event takes place
#
########################################################################

my $mainWindow = MainWindow->new();
if ($opt_g) {
    if ($opt_g =~ /^=?(\d+x\d+)?([+-]\d+[+-]\d+)?$/) {
	$opt_g = '540x418+0+320' if $opt_g eq '=';	# special in lower left corner
	$mainWindow->geometry($opt_g);
    } else {
	warn "bad geometry string '$opt_g' - ignored\n";
    }
}
$mainWindow->title("$named$u");

if (($home = $ENV{HOME}) ne '') {
    if (($opt_T or not -f "$home/.$named.bit") and open(INI, ">$home/.$named.bit")) {
	print "$named: generate a new minimise icon file\n";
	print INI << "EOF";
/* minimise icon 'iC' for iClive */
\#define ic_width 48
\#define ic_height 48
static unsigned char ic_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,
    0xe0, 0x00, 0x00, 0x00, 0x7f, 0x1c,
    0xf0, 0x01, 0x00, 0xe0, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xf8, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xfe, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xff, 0xff, 0x1f,
    0xf0, 0x01, 0x80, 0x7f, 0x00, 0x1f,
    0xe0, 0x00, 0xc0, 0x1f, 0x00, 0x1c,
    0x00, 0x00, 0xe0, 0x07, 0x00, 0x18,
    0x00, 0x00, 0xf0, 0x03, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0x01, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf8, 0x01, 0x3c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3e, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x3c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0x7c, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf8, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf8, 0x00, 0x00, 0x00,
    0xf0, 0x01, 0xf0, 0x01, 0x00, 0x00,
    0xf0, 0x01, 0xf0, 0x03, 0x00, 0x00,
    0xf0, 0x01, 0xe0, 0x07, 0x00, 0x18,
    0xf0, 0x01, 0xc0, 0x1f, 0x00, 0x1c,
    0xf0, 0x01, 0x80, 0x7f, 0x00, 0x1f,
    0xf0, 0x01, 0x00, 0xff, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xfe, 0xff, 0x1f,
    0xf8, 0x03, 0x00, 0xf8, 0xff, 0x0f,
    0xf8, 0x03, 0x00, 0xe0, 0xff, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
EOF
	close(INI);
    }
    $mainWindow->iconbitmap("\@$home/.$named.bit");
}

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton(-text               => 'File',
				    -relief             => 'raised',
				    -borderwidth        => 2,
				    -takefocus          => 1,
				    -highlightthickness => 1,
				    -tearoff            => 1,		# 0 - tear off
				   )->pack(-side => 'left',
					   -padx => 2,
					  );
$menuFile->command(-label       => 'New',				# 1
		   -accelerator => 'Alt-n',
		   -command     => \&new_text);
$menuFile->command(-label       => 'Open',				# 2
		   -accelerator => 'Alt-o',
		   -command     => \&open_file);
$menuFile->command(-label       => 'Open.lst',				# 3
		   -accelerator => 'Alt-l',
		   -command     => \&open_list);
$menuFile->command(-label       => 'Save',				# 4
		   -accelerator => 'Alt-s',
		   -command     => \&save_file);
$menuFile->command(-label       => 'SaveAs',				# 5
		   -accelerator => 'Alt-a',
		   -command     => \&saveAs_file);
$menuFile->separator();							# 6
$menuFile->command(-label       => 'Quit',				# 7
		   -accelerator => 'Alt-q',
		   -command     => \&quit_program);
$menuFile->separator();							# 8
my $menuFileStart = 9;				# first dynamic entry:  # 9
my %currentFiles = ();
my $menuFileCount = 0;				# caching count
my %lastFile = ();				# save last open file
my $lastFileCount = 0;				# caching count

########################################################################
#	Build menu
########################################################################
my $build_mb   = $menuBar->Menubutton(-text               => 'Build',
				      -relief             => 'raised',
				      -borderwidth        => 2,
				      -takefocus          => 1,
				      -highlightthickness => 1,
				      -tearoff            => 0,		# no tear off
				     )->pack(-side => 'left',
					     -padx => 2,
					    );
$build_mb->command(-label       => 'Build executable',
		   -accelerator => 'Alt-b',
		   -command     => [ \&build_file, 0, 0 ]);
$build_mb->command(-label       => 'Save &Build unconditionally',
		   -accelerator => 'Alt-u',
		   -command     => [ \&build_file, 0, 1 ]);
$build_mb->command(-label       => 'Build C file only',
		   -accelerator => 'Alt-c',
		   -command     => [ \&build_file, 0, 2 ]);
if ($opt_T) {
    $build_mb->command(-label   => 'Symbol Table by name',
    		       -command => [ \&output_symbol_table, 0, 0 ]);
    $build_mb->command(-label   => 'Symbol Table by index',
    		       -command => [ \&output_symbol_table, 0, 1 ]);
    $build_mb->command(-label   => 'T to iCserver',	# iCserver prints table
    		       -command => sub { conn_send_now('T') if $conn; });
    $build_mb->command(-label   => 'X to iCserver',	# stop iCserver
    		       -command => sub { conn_send_now('X') if $conn; });
}
my $makeName = '';
my $restartFlag = 0;

########################################################################
#	Run or Stop button
########################################################################
my $runButton  = $menuBar->Button(-text        => 'Run ',
				  -relief      => 'raised',
				  -width       => 4,
				  -borderwidth => 2,
				  -command     => \&run_file,
			         )->pack(-side => 'left',
				         -padx => 2,
				        );

########################################################################
#	Instance button
########################################################################
my ($instanceText, $instance, $oldInstance);
my @instanceOptions = (
    [""  , ''],
    ["-0", 0 ],
    ["-1", 1 ],
    ["-2", 2 ],
    ["-3", 3 ],
    ["-4", 4 ],
    ["-5", 5 ],
    ["-6", 6 ],
    ["-7", 7 ],
    ["-8", 8 ],
    ["-9", 9 ]
);

$instanceText = $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = $opt_i;
	$instanceText = "-$instance";
	if (length $instance > 1) {
	    push @instanceOptions, [$instanceText, $instance];
	}
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
    }
}
$oldInstance = $instanceText;
print "instanceText=$instanceText, instance=$instance\n" if $opt_T;

my $instButton  = $menuBar->Optionmenu(-command      => \&change_instance,
				       -textvariable => \$instanceText,
				       -variable     => \$instance,
				       -options      => \@instanceOptions
				      )->pack(-side => 'left',
					      -padx => 2,
					     );

########################################################################
#	Live or Edit button
########################################################################
my $scanButton = $menuBar->Button(-text        => 'Live',
				  -relief      => 'raised',
				  -width       => 4,
				  -borderwidth => 2,
				  -command     => \&scan,
			         )->pack(-side => 'left',
				         -padx => 2,
				        );
my $scanFlag = 0;		# text is initially cleared

########################################################################
#	Search menu 
########################################################################
my $menuSearch = $menuBar->Menubutton(-text               => 'Search:',
				      -relief             => 'raised',
				      -borderwidth        => 2,
				      -takefocus          => 1,
				      -highlightthickness => 1,
				      -tearoff            => 1,		# 0 - tear off
				     )->pack(-side => 'left',
					     -padx => 2,
					    );
my $matchType = "-exact";	# default, alternatives -nocase -regexp

$menuSearch->command(-label       => 'Search down',			# 1
		     -accelerator => 'Return',
		     -command     => [ \&search_text, 0, undef, 0 ]);
$menuSearch->command(-label       => 'Search up',			# 2
		     -accelerator => 'Shift-Ret',
		     -command     => [ \&search_text, 0, undef, 1 ]);
$menuSearch->command(-label       => 'Clear',				# 3
		     -accelerator => 'Ctrl-Ret',
		     -command     => [ \&search_text, 0, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$menuSearch->radiobutton(-label    => 'Go to line',			# 4
			 -accelerator => 'Alt-Ret',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 0, undef, 2 ]);
########################################################################
#	Exact match
########################################################################
$menuSearch->radiobutton(-label    => 'Exact match',			# 5
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 0, undef, 0 ]);
########################################################################
#	Ignore case
########################################################################
$menuSearch->radiobutton(-label    => 'Ignore case',			# 6
			 -value    => '-nocase',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 0, undef, 0 ]);
########################################################################
#	Regexp match
########################################################################
$menuSearch->radiobutton(-label    => 'Regexp match',			# 7
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 0, undef, 0 ]);
########################################################################
#	Regexp match - Ignore case
########################################################################
$menuSearch->radiobutton(-label    => 'Regexp Ignore case',		# 8
			 -value    => 'ri',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 0, undef, 0 ]);
$menuSearch->separator();						# 9
my $menuSearchStart = 10;			# first dynamic entry:  #10
my %currentSearches = ();
my $menuSearchCount = 0;			# caching count

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 20,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left',
					 -padx => 2,
					);
####### Search entry bindings ##########################################
$entrySearch->bind('<KeyPress-Return>',		[ \&search_text, undef, 0 ]); # search down
$entrySearch->bind('<Shift-KeyPress-Return>',	[ \&search_text, undef, 1 ]); # search up
$entrySearch->bind('<Control-KeyPress-Return>',	[ \&search_text, '',    0 ]); # clear
$entrySearch->bind('<Alt-KeyPress-Return>',	[ \&search_text, undef, 2 ]); # go to line
####### File menu bindings #############################################
$entrySearch->bind('<Alt-Key-l>', [ \&open_list ]);	# active in Live mode
$entrySearch->bind('<Alt-Key-q>', [ \&quit_program ]);	# active in Live mode
####### Run/Stop button binding ########################################
$entrySearch->bind('<Alt-Key-r>', [ \&run_file ]);	# active in Live mode
####### Live/Edit button binding #######################################
$entrySearch->bind('<Alt-Key-e>', [ \&scan ]);		# active in Live mode
####### Help button binding ############################################
$entrySearch->bind('<Alt-Key-h>', [ \&fork_help ]);	# active in Live mode
####### X-Movement bindings #### Y-Movement used by Entry #############
$entrySearch->bind('<Key-Down>',  [ \&scroll_text, 1    ]); # scroll down
$entrySearch->bind('<Key-Up>',    [ \&scroll_text, -1   ]); # scroll up
$entrySearch->bind('<Key-Next>',  [ \&scroll_text, $opt_l-2 ]); # next page
$entrySearch->bind('<Key-Prior>', [ \&scroll_text, -$opt_l+2]); # prior page
$entrySearch->bind('<Key-Home>',  [ \&position_text, '1.0'  ]); # beginning
$entrySearch->bind('<Key-End>',   [ \&position_text, 'end'  ]); # end

########################################################################
#	Help button
########################################################################
my $helpButton = $menuBar->Button(-text        => 'Help',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -command     => \&fork_help,
			         )->pack(-side => 'right',
				         -padx => 2,
				        );

########################################################################
#	Ini data for file and search menu lists
########################################################################
my %iniMenuData = (
    files	=> [
	$menuFile,		# file menu
	$menuFileStart,		# start of dynamic entries
	\%currentFiles,		# save file menu entries
	10,			# number of dynamic entries
	\&open_file,		# call back for open file
	\$menuFileCount,	# current caching count
    ],
    'last open file' => [
	0,			# no menu
	0,
	\%lastFile,		# save last open file, line # and instance
	0,			# (not used)
	0,
	\$lastFileCount,	# current caching count
    ],
    searches	=> [
	$menuSearch,		# search menu
	$menuSearchStart,	# start of dynamic entries
	\%currentSearches,	# save search menu entries
	10,			# number of dynamic entries
	\&search_text,		# call back for search text
	\$menuSearchCount,	# current caching count
    ],
);

my %matchExtensions = (
    -exact	=> '',
    -nocase	=> '	i',
    -regexp	=> '	r',
    ri		=> '	ri',
    g		=> '	g',
);
my %matchRestores = (
    e		=> '-exact',
    i		=> '-nocase',
    r		=> '-regexp',
    ri		=> 'ri',
    g		=> 'g',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom',
					-fill => 'x',
				       );

########################################################################
#	Text window
########################################################################
my $text;
if ($opt_u) {
    $text = $mainWindow->Scrolled('TextUndo',
				     -scrollbars => 'osoe',
				     -background => 'cornsilk1',
				     -wrap       => 'none',
				     -font       => $font,
				    )->pack(-fill   => 'both',
					    -expand => 1,
					   );
    $text->eventAdd('<<Undo>>' => '<Control-u>');	# extra Undo binding
} else {
    $text = $mainWindow->Scrolled('Text',
				     -scrollbars => 'osoe',
				     -background => 'cornsilk1',
				     -wrap       => 'none',
				     -font       => $font,
				    )->pack(-fill   => 'both',
					    -expand => 1,
					   );
}
unless ($opt_g) {
    $text->configure (-width  => $opt_w);
    $text->configure (-height => $opt_l);
}
####### Text window bindings ###########################################
$text->bind('<KeyPress>', [ \&report_cursor ]);	# change in cursor position
$text->bind('<Button-1>', [ \&report_cursor ]);	# change in cursor position
$text->bind('<ButtonRelease>', [ \&adjust_live ]);
####### Y-Scrollbar bindings ###########################################
my $yScrollbar = $text->Subwidget('yscrollbar');
$yScrollbar->bind('<Alt-Key-l>',[ \&open_list ]);
$yScrollbar->bind('<Key-l>',    [ \&open_list ]);
$yScrollbar->bind('<Key-q>',	[ \&quit_program ]);
$yScrollbar->bind('<Alt-Key-q>',[ \&quit_program ]);
$yScrollbar->bind('<Key-Right>',[ \&scroll_x_text, 1  ]); # scroll right
$yScrollbar->bind('<Key-Left>',	[ \&scroll_x_text, -1 ]); # scroll left
$yScrollbar->bind('<ButtonRelease>', [ \&adjust_live ]);
$yScrollbar->bind('<KeyRelease>', [ \&adjust_live ]);
####### Search entry bindings ##########################################
$yScrollbar->bind('<KeyPress-Return>',		[ \&search_text, undef, 0 ]); # search down
$yScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_text, undef, 1 ]); # search up
$yScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_text, '',    0 ]); # clear
$yScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_text, undef, 2 ]); # go to line
####### X-Scrollbar bindings ###########################################
my $xScrollbar = $text->Subwidget('xscrollbar');
$xScrollbar->bind('<Key-Down>',	[ \&scroll_text, 1    ]); # scroll down
$xScrollbar->bind('<Key-Up>',	[ \&scroll_text, -1   ]); # scroll up
$xScrollbar->bind('<Key-Next>',	[ \&scroll_text, $opt_l-2 ]); # next page
$xScrollbar->bind('<Key-Prior>',[ \&scroll_text, -$opt_l+2]); # prior page
$xScrollbar->bind('<Key-Home>',	[ \&position_text, '1.0'  ]); # beginning
$xScrollbar->bind('<Key-End>',	[ \&position_text, 'end'  ]); # end
$xScrollbar->bind('<ButtonRelease>', [ \&adjust_live ]);
####### Search entry bindings ##########################################
$xScrollbar->bind('<KeyPress-Return>',		[ \&search_text, undef, 0 ]); # search down
$xScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_text, undef, 1 ]); # search up
$xScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_text, '',    0 ]); # clear
$xScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_text, undef, 2 ]); # go to line
########################################################################
#	The Tk::Text Widget uses no Alt bindings - so we use them here
####### File menu bindings #############################################
$text->bind('<Alt-Key-n>', [ \&new_text ]);	# not active in Live mode
$text->bind('<Alt-Key-o>', [ \&open_file ]);	# not active in Live mode
$text->bind('<Alt-Key-l>', [ \&open_list ]);	# active in Live mode
$text->bind('<Alt-Key-s>', [ \&save_file ]);	# not active in Live mode
$text->bind('<Alt-Key-a>', [ \&saveAs_file ]);	# not active in Live mode
$text->bind('<Alt-Key-q>', [ \&quit_program ]);	# active in Live mode
####### Build menu bindings ############################################
$text->bind('<Alt-Key-b>', [ \&build_file, 0 ]);# not active in Live mode
$text->bind('<Alt-Key-u>', [ \&build_file, 1 ]);# not active in Live mode
$text->bind('<Alt-Key-c>', [ \&build_file, 2 ]);# not active in Live mode
####### Run/Stop button binding ########################################
$text->bind('<Alt-Key-r>', [ \&run_file ]);	# active in Live mode
$yScrollbar->bind('<Alt-Key-r>', [ \&run_file ]);
$yScrollbar->bind('<Key-r>',     [ \&run_file ]);
$yScrollbar->bind('<Key-s>',     [ \&run_file ]);
####### Live/Edit button binding #######################################
$text->bind('<Alt-Key-e>', [ \&scan ]);		# active in Live mode
$yScrollbar->bind('<Alt-Key-e>', [ \&scan ]);
$yScrollbar->bind('<Key-e>',     [ \&scan ]);
####### Help button binding ############################################
$text->bind('<Alt-Key-h>', [ \&fork_help ]);	# active in Live mode
$yScrollbar->bind('<Alt-Key-h>', [ \&fork_help ]);
$yScrollbar->bind('<Key-h>',     [ \&fork_help ]);
########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-state => 'balloon');
my $balloonAttached = 0;
########################################################################
#	Bug in Tk-804.027 (possibly only on MAC OsX-1.3-darwin)
#	next (commented) statement causes XS_TK__Callback_Call error
#	just forget about it ???	JW 2005/02/02
########################################################################
# $mainWindow->OnDestroy(sub { $balloon->destroy; });
$mainWindow->bind('<Configure>', [ \&adjust_live ]);

########################################################################
#	Initialise file and search menu lists, open the first file
########################################################################

ini_program();

########################################################################
#	Connect to iCserver
########################################################################

print "$named: initial register_at_server\n" if $opt_T;
register_at_server();

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################

MainLoop();
exit(0);

####### End of main program ############################################

########################################################################
#
#	Display information on the info bar
#	(make sure all displays to info bar go via this routine)
#	Parameter 1:	delay in milliseconds
#	Parameter 2:	colour (change if $message ne '')
#	Parameter 3:	message text
#
#	messages  are queued and displayed at <delay> ms intervals
#
########################################################################

sub info_display {
    push @infoMessages, @_;	# must always be 3 parameters
    display_callback() unless $infoDisplaying;	# wait if displaying
} # info_display

sub display_callback {
    my ($delay, $colour, $message);
    while (@infoMessages) {
	($delay, $colour, $message) = splice @infoMessages, 0, 3;	# shift 3
	$infoBar->configure(-foreground => $colour) if $message ne '';
	$info = $message;	# display now
	if ($delay) {
	    $infoDisplaying = 1;
	    $text->after($delay, \&display_callback);	# call self in delay ms
	    return;
	}
    }
    $infoDisplaying = 0;	# current display will stay - ready for imm change
} # display_callback

########################################################################
#
#	Report the cursor position in the info bar
#
########################################################################

sub report_cursor {
    info_display(0, 'black', $text->index('insert'));	# '27.4'
    adjust_live();
} # report_cursor

########################################################################
#
#	Adjust live display to only the text in the view window.
#
#	This speeds up live display enourmously - especially on very
#	large listing texts eg. 10,000 lines, where 15 seconds were needed
#	to build the live display and live updates were then still sluggish
#	approx. 0.5 seconds near the end of the text. Worse still my 2.5 GHz
#	processor was stretched to the limit to keep the live display up to
#	date, although 99% or more of the changes did not affect the current
#	text visible in the text window. With the change live displays come
#	up in a fraction of a second no matter how large the text is. All
#	one can see when scrolling the text window is a blink in '1' variables.
#	Measured 2 ms for a typical 26 line window. CPU loading between 0 and
#	10% for an application displaying 4 shift registers changing every
#	50 ms. Associated network traffic 25K.
#
#	Since this activation may come from several binds resulting in the
#	same $start and $last lines, do_scan only once when line numbers
#	change.
#
#	$prevStart and $prevLast must be cleared when changing file or instance
#	in case the text in the window is similar.
#
#	The computation of $start and $last from $end has always yielded
#	integer values with the fractions returned by $text->yview().
#	If this were not the case, function int($start+0.5) could be used.
#	Perl seems to do this internally on the 16th precision digit ???
#	Tested empircally JW 20050404
#
#	parameter 1:	$_[0], has HASH ref when callback from bind
#	parameter 2:	$_[1], do_scan unconditionally if true
#
########################################################################

sub adjust_live {
    if ($scanFlag) {
	my @position = $text->yview();
	my $end = $text->index('end');	# re-compute in case text has changed
	$end =~ s/(\d+).*/$1/;
	$end--;
	my $start = $end * $position[0];
	$start++;
	my $last = $end * $position[1];
	$last++;
	$last++ unless $last > $end;
	if ($start != $prevStart or $last != $prevLast or $_[1]) {
	    if (@activeSymbols) {
		deleteAllTags();
		clear_scan();
	    }
	    do_scan("$start.0", "$last.0");
	    $prevStart = $start;
	    $prevLast  = $last;
	    printMicroSeconds();
no warnings;
	    print "do_scan complete, $start, $last, '$_[1]'\n" if $opt_t;
use warnings;
	}
	$last--;			# actual last line
	info_display(0, 'dark green', "$start      $last");
    }
} # adjust_live

########################################################################
#
#	Send message to $conn now
#
########################################################################

sub conn_send_now {
    my ($msg) = @_;
    eval {
	$conn->send_now($msg);
    }; warn "eval: $@" if $@;
}  # conn_send_now

########################################################################
#
#	Register at iCserver
#	connection is maintained until iClive shuts down or iCserver disconnects
#
#	Register read events
#	Register I/O at iCserver and request Symbol Table if $scanFlag is set
#
########################################################################

sub register_at_server {
    my $i = 0;
    CONNECT: until ($conn) {
	$conn = Msg->connect($host, $port, \&rcvd_msg_from_server);
	if ($conn) {
	    print "Connection $named at server.\n";
	    $mainWindow->fileevent($conn->{sock}, 'readable', sub { Msg->event_loop(1); });
	    info_display(2000, 'blue', "Connection to '$host:$port'");
	} else {
	    last CONNECT if $i++ >= 3;
	    fork_and_exec('iCserver', '-a');	# start iCserver
	    $server = 1;			# remember that this iClive started iCserver
	}
    }
    if ($conn) {
	if ($regName eq '') {
	    my $ret = '';
	    my $Registrations = "N-$instName,RC$instName,SD$instName";
	    $regName = $instName;		# register but may not connect to application
	    print "$named: Registrations: $Registrations\n" if $opt_T;
	    conn_send_now($Registrations);
	    info_display(2000, 'blue', "Register as '-$instName'");	# ZZZ
	    my ($tmsg, $terr) = $conn->rcv_now();
no warnings;
	    print "$named: Reply: '$tmsg' err = '$terr'\n" if $opt_T;
	    $i = 1;
	    REPEAT:
	    if ($tmsg !~ /^(\d+),(\d+)$/) {	# analyse registration reply now
		rcvd_msg_from_server($conn, $tmsg, $terr);
		unless ($conn) {
		    print "$named: failed to register on attempt $i\n" if $opt_T;
		    goto FAILED_TO_REGISTER;	# stop trying if registered twice
		}
		($tmsg, $terr) = $conn->rcv_now();
		print "$named: Reply: '$tmsg' err = '$terr' ($i)\n" if $opt_T;
		die "registration failed\n" if $i++ >= 3;
		goto REPEAT;	# cannot use while, because $1 $2 not in scope - if OK
	    }
use warnings;
	    $C_channel = $1;	# receiver channel from control program
	    $D_channel = $2;	# sender channel to control program
	    print "$named: registered: C_channel = $C_channel, D_channel = $D_channel\n" if $opt_T;
	    conn_send_now("$D_channel:2");	# poll application to see if it is live
	}
    } else {
	FAILED_TO_REGISTER: info_display(2000, 'red',
	    "Could not connect to '$host:$port' - no live listing - edit only");
    }
} # register_at_server

sub catch_sig {
    my $signame = shift;
    die "$named: Somebody sent me a SIG$signame: $!";
} # catch_sig

########################################################################
#
#	Unregister current session from iCserver
#
########################################################################

sub unregister_from_server {
    if ($regName ne '') {
	print "$named: unregister '$regName' '$D_channel:0'.\n" if $opt_T;
	conn_send_now("$D_channel:0");
	my $UnRegistrations = "n-$regName,rC$regName,sD$regName";
	$regName = '';
	print "$named: UnRegistrations: $UnRegistrations\n" if $opt_T;
	$mainWindow->title("$named$u: $fileName");	# YYY
	conn_send_now($UnRegistrations);
    }
    clear_all();
} # unregister_from_server

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occurr if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
    die "named: rcvd on a strange connection '$rConn', should be '$conn'\n$msg\n" if $rConn ne $conn;
    if (defined $msg) {
	my $len = length $msg;
	print "($len)$msg< iCserver\n" if $opt_T;
	if ($len == 0) {
	    print "$named: rcvd zero length message - disconnect\n" if $opt_T;
	    info_display(2000, 'red', "$named: disconnected by iCserver");
	    unregister_from_server();
	    $scanFlag = 0;
	    $scanButton->configure(-text => 'Live');
	    $regName = $runName = '';
	    $runButton->configure(-text => 'Run ');
	    print "$named: rcvd_msg_from_server(0) buttons to 'Run ' 'Live'\n" if $opt_T;
	    $mainWindow->title("$named$u: $fileName");
	    $makeName = '';
	    $conn->disconnect;		# should only happen when iCserver shuts down
	    $conn = 0;
	    info_display(2000, 'red', "iCserver has disconnected $named from '$host:$port'");
	} else {
	    my ($msg1);
	    printMicroSeconds();
	    print "rcvd '$msg'\n" if $opt_t;
	    foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
		my @symbols = split /;/, $msg1;	# break up message
		my $entry = shift @symbols;		# first entry is an operation
		if ($entry =~ /$C_channel\:(\d+)/) {
		    if (($entry = $1) eq '1') {
			print "received '$C_channel:1'\n" if $opt_T;
			####################################################
			## Symbol Table block
			## Symbol table entries consist of two or three words.
			## Usually symbol-id and ftype are received. In this
			## case the ST-offset is the index. (computed by counting)
			## For ALIASes the index of the Gate to which the
			## ALIAS resolves is transmitted as a 3rd value.
			## For bit I/O names IX0.0 etc, add a second entry IX0_0
			## For number constants 0 1 etc, add a second entry _0 _1
			## For negative constants -1 etc, add a second entry __1
			####################################################
			while ($entry = shift @symbols) {
			    my ($symbol, $ftype, $index) = split " ", $entry;
			    my ($l);
			    $index = $stIndex unless defined $index;
			    print "$index\t$symbol\t$ftype\n" if $opt_T;
			    @{ $symbolTable{$symbol} } = ($ftype, $index);
			    if ($symbol =~ s/^([IQT]X\d+)\.(\d+(_\d+)?)$/$1_$2/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^-(\d+)$/__$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^(\d+)$/_$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    if ($opt_T and ($l = length $symbol) > $maxSymbolLength) {
				$maxSymbolLength = $l;
			    }
			    $stIndex++;
			}
		    }
		    elsif ($entry eq '2') {
			if ($runName eq '') {	# block 2nd receive of ch:2;<name>
			    print "received '$C_channel:2'\n" if $opt_T;
			    ####################################################
			    ## Application is running
			    ## The 2nd entry is the name of the running iC program.
			    ## This name allows a check against the file name of
			    ## the displayed text. (Assume it should match)
			    ## change text on run button to 'Stop'
			    ####################################################
			    $runName = shift @symbols;
			    $mainWindow->title("$named$u: $fileName $runName");
			    info_display(2000, 'blue', "'$runName' is running");
			    $runButton->configure(-text => 'Stop');
			    print "$named: rcvd_msg_from_server received :2 'Stop' scanFlag = '$scanFlag'\n" if $opt_T;
			    if ($scanFlag) {
				%symbolTable = ();
				print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
				conn_send_now("$D_channel:1");	# request Symbol Table
			    }
			}
		    }
		    elsif ($entry eq '3') {
			print "received '$C_channel:3'\n" if $opt_T;
no warnings;
			####################################################
			## New data values
			## Data value entries consist of ST-index and value
			####################################################
			my $normalFlag = 0;		# state currently diasabled
			while ($entry = shift @symbols) {
			    my ($index, $value) = split " ", $entry;
			    my ($tRest, $cs, $tNew, $tOld);
			    ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			    $activeSymbols[$index][3] = $tNew = [gettimeofday];
			    $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
# print "index: $index value: $value rest: $tRest\n";
			    $cs ^= 1 if $value;			# change colour
			    $activeSymbols[$index][1] = $value;	# for value display
			    if ($activeSymbols[$index][0] & 01) {
				if ($tRest < 10) {
				    colourTag("$index", $cs);	# normal colour
				} else {
				    colourTag("$index", $cs | 010);	# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index" ]);
				}
				if ($cs == 5 or $cs == 7) {	# hi CLOCK or TIMER
				    ## turn colour off after 50 ms.
				    $text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 02) {
				$cs ^= 1;				# complement colour
				if ($tRest < 10) {
				    colourTag("$index~", $cs);	# latest $cs is saved
				} else {
				    colourTag("$index~", $cs | 010);# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index~" ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 04) {
				my $tag = "$index=";
				my @ranges = $text->tagRanges($tag);
# print "value at index $index: $activeSymbols[$index][1] '@ranges'\n";
				unless ($normalFlag) {
				    $text->configure(-state => 'normal');
				    $normalFlag = 1;	# state normal until loop end
				}
				for (my $i = 0; $i < @ranges; $i += 2) {
				    my ($beg, $end) = @ranges[$i, $i+1];
				    $text->delete($beg, $end);
				    $text->insert($beg, " $value", $tag);
				}
			    }
			    printMicroSeconds();
			    print "$index	$value\n" if $opt_t;
			}
			if ($normalFlag) {
			    $text->configure(-state => 'disabled');
			}
use warnings;
		    }
		    elsif ($entry eq '4') {
			####################################################
			## End of Symbol Table
			####################################################
			info_display(2000, 'blue', "'$runName' Symbol Table received");
			$stIndex = 0;		# ready for next reception
			print "received '$C_channel:4'\n" if $opt_T;
			printMicroSeconds();
			$scanFlag = 1;
			adjust_live(-1, -1);
		    }
		    elsif ($entry eq '5') {
			####################################################
			## Application has stopped - received :5
			####################################################
			print "received '$C_channel:5'\n" if $opt_T;
			info_display(2000, 'blue', $regName ne '' ?
			    "'$regName' was stopped" :
			    "application was stopped - not registered !?");
			clear_all();
			$runName = '';
			$mainWindow->title("$named$u: $fileName");
			$makeName = '';
			if ($restartFlag) {
			    $restartFlag = 0;
			    run_file();	# restart after scan detects out of date build
			} else {
			    ####################################################
			    ## change text on run button to 'Run '
			    ####################################################
			    $runButton->configure(-text => 'Run ');
			    print "$named: rcvd_msg_from_server received :5 'Run '\n" if $opt_T;
			}
			if ($scanFlag) {
			    $scanButton->configure(-text => 'wait');
			    print "$named: rcvd_messgae_from_server received :5 'wait'\n" if $opt_T;
			}
		    }
		    elsif ($entry ne '0') {	# ignore :0 messages
			print "received '$C_channel:$entry'\n" if $opt_T;
			goto Spurious;
		    }
		}
		elsif ($entry =~ /0:(\d+)/) {	# channel 0:1; warning from iCserver
		    if (($entry = $1) eq '1') {
			####################################################
			## Warning from iCserver. $msg is 0:1;<warning message>
			####################################################
			$msg =~ /^0:1;(.*)/;
			print "$named: Warning: $1\n" if $opt_T;
			info_display(2000, 'red', $1);
			last;	# used whole of $msg - ignore splits on ',' and ';'
		    }
		    elsif ($entry ne '0') {	# ignore :0 messages
			goto Spurious;
		    }
		}
		else {
		    Spurious: warn "$named: spurious operation '$entry' ???\n";
		}
		printMicroSeconds();
	    }
	    print "rcvd end\n" if $opt_t;
	}
    } else {
	print "undefined message< iCserver\n" if $opt_T;
    }
} # rcvd_msg_from_server

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
# print "colourTag: $tag $cs\n";
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
    $delayedColour{$tag} = $cs;		# save colour for end of flash
} # colourTag

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
# print "restoreTag: $tag $cs\n";
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
#endif
} # restoreTag

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from bind('<Return>', [ \&search_text, 1 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy first parameter when called directly
#
#		parameter 1:	(dummy)
#		parameter 2:	newSearchText
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up	(save searchText when clearing)
#		    "		2  Go to line
#		    "		4  Special search down - suppress search statistics
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
#	When called from build_file() to search for '*** ', which Error or
#	Warning lines, suppress search statistics to retain display from build
#
########################################################################

sub search_text {
    $text->after(0, [ \&search_now, @_ ]); # allow pop up to go away
} # search_text

sub search_now {
    my ($dummy, $newSearchText, $direction) = @_;
    my ($saveText, $saveMatch, $option, $auxiliary, $current, $hl, $y, $x, $length);
    my $tmpText;
    my $suppress = $direction & 0x04;	# extract additional parameter 3 info
    $direction &= 0x03;			# remove suppress bit
    if (defined $newSearchText) {
	if ($newSearchText eq '' and $direction) {	# save search text when clearing
	    ($saveText, $saveMatch) = ($searchText, $matchType);
	}
	($searchText, $option) = split(/\t/, $newSearchText);
	$matchType = $option ? $matchRestores{$option} : '-exact';
    }
    $searchText = '' if not defined $searchText;
    while ($direction == 2 or $matchType eq 'g') {
	## go to line $searchText
	if ($searchText eq '') {
	    $searchText = $current = "1.0";
	} elsif ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    $matchType = '-exact';	# try exact match - most likely
	    last;
	}
	print "goto: '$searchText' '$current' '$matchType' $direction\n" if $opt_T;
	$matchType = 'g';
	$text->see($current);
	## grey out the whole line - until mouse moves - visible in Edit and Live mode
	$text->tagAdd('sel', "$current linestart", "$current lineend");
	$text->markSet('insert', $current);
	report_cursor();
	$tmpText = "$searchText$matchExtensions{$matchType}";
	check_menu($tmpText, 'searches');
	return;
    }
    if ($prevText ne $searchText or $prevMatch ne $matchType) {
	########################################################################
	#	Start of a new search
	########################################################################
	print "pattern: '$searchText' '$matchType'\n" if $opt_T;
	@hits = ();
	@groups = ();
	$gl = 0;
	$text->tagDelete('searchTag') if $prevText;
	$text->tagConfigure('searchTag',
			    -background => 'black',	# same as 'less'
			    -foreground => 'white',	# stands out amongst live colours
			   );				# cannot see live status though
	if ($matchType eq 'ri') {
	    $matchType = '-regexp';
	    $auxiliary = '-nocase';
	} else {
	    $auxiliary = '-forwards';	# fill as placeholder
	}
	$current = '1.0';
	$length = '0';
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,
					 $matchType,
					 $auxiliary,
					 '--',
					 $searchText,
					 $current,	# start index
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display(0, 'red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;
	    my @lineinfo = $text->dlineinfo($current);
	    if ($opt_T) {
		my $word = $text->get($current, "$current + $length char");
		print "word: $word $length '@lineinfo'\n";
	    }
	    $text->tagAdd('searchTag', $current, "$current + $length char");
	    $current =~ /(\d+)\.(\d+)/;
	    $y = $1; $x = $2;
	    push @hits, [ $current, $y, $x, $length, ];
	    $current = $text->index("$current + $length char");	# point bejond hit
	}
	$matchType = 'ri' if $auxiliary eq '-nocase';	# otherwise radio button skips
	if (($hl = scalar @hits) > 0) {
	    if ($searchText ne '^\*\*\* ') {	# regular expression to find errors in listing
		$tmpText = "$searchText$matchExtensions{$matchType}";
		check_menu($tmpText, 'searches');
	    }
	    ########################################################################
	    #	Analyse hits and group them into display groups.
	    #   First pseudo_code for the algorithm.
	    #
	    #	determine centre of page
	    #	for (gi = 0; @hits; gi++) {
	    #	    top = first entry in a group - start with first element of @hits
	    #	    cLeft = top_c;
	    #	    cRight = top_c + top.length;
	    #	    my cMid = cLeft + int((cRight - cLeft) / 2);
	    #	    see top_l < center ? 1.0 : end; see "top_l.cMid";
	    #	    groups[gi] = "top_l.cMid";
	    #	    for each further entry bot in @hits {
	    #		cLeft = bot_c if bot_c < cLeft;
	    #		cRight = bot_c + bot.length if bot_c + bot.length > cRight;
	    #		lMid = yTop + int((lBot - yTop) / 2);
	    #		cMid = cLeft + int((cRight - cLeft) / 2);
	    #		unless (bbox "lBot.cRight") {
	    #		    see lMid < center ? 1.0 : end; see "lMid.cMid";
	    #		    last unless bbox yTop.cLeft and bbox "lBot.cRight"
	    #		    groups[gi] = "lMid.cMid";
	    #		}
	    #	    }
	    #	}
	    #
	    #	By using text->bbox(bot) first, there may be no need to reposition and
	    #	even short pages are analyzed optimally. When repositioning becomes
	    #	necessary, see the opposite end to the target being analyzed first, the
	    #	text->see() method will position the argument index in the centre
	    #	of the window. Using text->bbox() it is determined, whether the top
	    #	left index and the bottom right + word length index of a rectangle
	    #	enclosing all hits in a group are visible. Using this strategy, optimal
	    #	group size is achieved and scrolling by seeing the centre of the group
	    #	is identical and correct in either direction.
	    #
	    #	The previous algorithm, which was much longer actually missed showing
	    #	some hits under some circumstances.
	    ########################################################################
	    $text->see('1.0');			# position to top left so bbox works
	    my ($x, $y, $w, , $lineHeight, $h) = $text->bbox("1.0");
	    ## print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
	    $centre = $text->index("end");
	    $centre =~ /(\d+)\.\d+/;		# start is 1.0, end is 1 line past last line
	    $centre = $1 / 2;			# x for the centre of the page
	    my $dir = 1;			# start in forward direction
	    my $ip = "end";
	    print "centre = $centre dir = $dir\n" if $opt_T;
	    my ($aRef, $lMid, $cLeft, $cMid, $cRight);
	    my ($top_current, $top_l, $top_c, $top_length);
	    my ($bot_current, $bot_l, $bot_c, $bot_length, $bot_end);
	    for ($gi = 0; @hits; $gi += $dir) {
		if ($dir and $hits[0][1] >= $centre) {
		    $dir =  0;			# reverse direction
		    $gi++ if @groups;		# splice on right, skip forwards
		    $ip = "1.0";
		}
		# top is first or last entry in a group
		$aRef = $dir ? shift @hits : pop @hits;	# start with first or last hit
		($top_current, $top_l, $top_c, $top_length) = @$aRef;
		$lMid = $bot_l = $top_l;
		$bot_c = $top_c;
		$cLeft = $top_c;		# left and right bounds of box
		$cRight = $top_c + $top_length;
		$cMid = $cLeft + int(($cRight - $cLeft) / 2);
		$text->see($ip);		# position to top left corner or end
		$text->see("$top_l.$cMid");	# position to middle of first word
		splice @groups, $gi, $dir, [ $ip, $lMid, $cMid ];# next entry in group
		print "first $gi '$ip' => '$lMid.$cMid' '$bot_l.$bot_c' dir = $dir\n" if $opt_T;
		while (@hits) {
		    my $repos;
		    $aRef = $dir ? shift @hits : pop @hits;
		    ($bot_current, $bot_l, $bot_c, $bot_length) = @$aRef;
		    $cLeft = $bot_c if $bot_c < $cLeft;
		    $bot_end = $bot_c + $bot_length;
		    $cRight = $bot_end if $bot_end > $cRight;
		    $lMid = $top_l + int(($bot_l - $top_l) / 2);
		    $cMid = $cLeft + int(($cRight - $cLeft) / 2);
		    unless ((($x, $y, $w, $h) = $text->bbox("$bot_l.$cRight")) and
			    defined $h and
			    $h >= $lineHeight) {	# bot still visible ?
			$text->see($ip);		# position to top left corner or end
			$text->see("$lMid.$cMid");	# position to middle of new group
			unless ((($x, $y, $w, $h) = $text->bbox("$top_l.$cLeft")) and
				defined $h and
				$h >= $lineHeight and
				(($x, $y, $w, $h) = $text->bbox("$bot_l.$cRight")) and
				defined $h and
				$h >= $lineHeight) {	# top and bot still visible ?
			    print "skip  $gi '$ip' => '$lMid.$cMid' '$bot_l.$bot_c' dir = $dir\n" if $opt_T;
			    $dir ? unshift @hits, $aRef
				 : push @hits, $aRef;	# no longer visible
			    if ($dir and $hits[0][1] >= $centre) {
				$dir =  0;		# reverse direction
				$gi++ if @groups;	# splice on right, skip forwards
				$ip = "1.0";
			    }
			    last;			# use with next group
			}
			## print "h = $h, lineHeight = $lineHeight\n" if $opt_T;
			$repos = 'repos';
		    } elsif ($opt_T) {
			## print "h = $h, lineHeight = $lineHeight\n";
			$repos = '     ';
		    }
		    splice @groups, $gi, 1, [ $ip, $lMid, $cMid ];# next entry in group
		    print "$repos $gi '$ip' => '$lMid.$cMid' '$bot_l.$bot_c' dir = $dir\n" if $opt_T;
		}
	    }
	    ###### last entry is not stored in @ groups if always seen by bbox
	    ## splice @groups, $gi, 1, [ $ip, $lMid, $cMid ];# last entry
	    ## print "last  $gi '$ip' => '$lMid.$cMid' '$bot_l.$bot_c' dir = $dir\n" if $opt_T;
	    $gi = -1;				# see index
	    $gl = scalar @groups;
	    my $plural = $gl > 1 ? 's' : '';
	    info_display(0, 'dark green', "/$searchText/ found $hl times in $gl group$plural") unless $suppress;
	    $text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	}
	$prevText = $searchText;
	$prevMatch = $matchType;
	$entrySearch->focus();
    }
    ########################################################################
    #	Use @groups to scroll over the groups forwards or backwards.
    #	Initial group index is $gi = -1. Used to determine scroll start for
    #	immediate backward scroll.
    #	Even for a single group, re-position group every time RETURN is pressed,
    #	because the hits could have been moved by manual scrolling.
    ########################################################################
    if ($gl > 0) {
	my $infoFlag = ($gi < 0 or $gl < 2) ? 0 : 1;	# allows search statistics info to stay
	if (not $direction) {
	    $gi++;			# forward scroll
	    if ($gi >= $gl) {
		$gi = 0;
		if ($infoFlag) {
		    info_display(0, 'dark red', "search hit BOTTOM, continuing at TOP");
		    $infoFlag = 0;
		}
	    }
	} else {
	    $gi--;			# backward scroll
	    if ($gi < 0) {
		if ($infoFlag and $gi == -1) {	# -2 is first time backwards
		    info_display(0, 'dark red', "search hit TOP, continuing at BOTTOM");
		    $infoFlag = 0;
		}
		$gi = $gl - 1;
	    }
	}
	if ($infoFlag) {
	    info_display(0, 'black', '');	# clears display_info
	}
	my ($ip, $lMid, $cMid) = @{$groups[$gi]};
	$text->see($ip);		# position to top left corner or end
	$text->see("$lMid.$cMid");	# position to middle of new group
	adjust_live();
	print "see $gi '$ip' => '$lMid.$cMid'\n" if $opt_T;
    } elsif ($gl == 0 and not $@) {	# do not overwrite search eval error message
	if ($searchText ne '') {
	    info_display(0, 'red', "/$searchText/ not found");	# report every time
	} else {
	    info_display(0, 'dark red', "search cleared");
	    if ($scanFlag) {
		$yScrollbar->focus();
	    } else {
		$text->focus();
	    }
	}
    }
    if ($saveText) {
	($searchText, $matchType) = ($saveText, $saveMatch);
    }
} # search_now

########################################################################
#
#	Clear_all
#
########################################################################

sub clear_all {
    deleteAllTags();	# also clears @activeSymbols
    %symbolTable = ();	# clear symbol table so balloons dont show
    clear_scan(1);	# detach balloon
} # clear_all

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    $text->configure(-state => 'normal');
    $text->focus();
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
} # deleteAllTags

########################################################################
#
#	Live/Edit - switch between clear_scan and do_scan
#
########################################################################

sub scan {
    deleteAllTags();	# also clears @activeSymbols
    if ($scanFlag) {
	reset_scan();
    } elsif ($conn) {
	$scanFlag = 1;
	$scanButton->configure(-text => 'wait');
	print "$named: scan 'wait'\n" if $opt_T;
	if ($runName ne '') {
	    print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
	    conn_send_now("$D_channel:1");	# request Symbol Table
	}
    } else {
	print "not connected ???\n" if $opt_T;
	register_now();
    }
} # scan

########################################################################
#
#	Reset $scanFlag and then clear_scan()
#		parameter 1:	1  skips clear active symbols in application
#
########################################################################

sub reset_scan {
    if ($scanFlag) {
	$scanFlag = 0;
	$scanButton->configure(-text => 'Live');
	if ($runName ne '') {
	    clear_scan(@_);
	}
    }
} # reset_scan

########################################################################
#
#	Clear scan and detach balloon processing. Prepare for scan.
#	Clear active symbols for faster processing of connected controller
#		parameter 1:	1  skips clear active symbols in application
#
########################################################################

sub clear_scan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    unless (@_) {		# skip if parameter 1 set
	info_display(0, 'black', '');	# clears display_info
	if ($conn) {
	    ####################################################################
	    ## clear active symbols in connected iC controller process
	    ## reset last D_channel value in iCserver
	    ####################################################################
	    if ($runName ne '') {
		print "clear_scan() sends '$D_channel:5,$D_channel:0'\n" if $opt_T;
		conn_send_now("$D_channel:5,$D_channel:0");
	    }
	}
    }
} # clear_scan

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach balloon processing while display is live.
#	Balloon processing is detached for a newly loaded file and when
#	the scan is cleared to allow clean editing.
#
########################################################################

sub do_scan {
    my ($current, $last) = @_;
    my ($word, $i, $iw, $tag, $cs, $ts, $ftype, $index, $t);
    print "do_scan: instName = '$instName' regName = '$regName' makeName = '$makeName'\n" if $opt_T;
    if (defined $instName and $instName ne '') {
	if ($instName ne $regName) {
	    unregister_from_server();
	    register_now();	# register at new process
	    return;
	}
	if (defined $makeName and $makeName ne '') {
	    my $dialog = $text->Dialog (-title   => 'Modified build',
					-bitmap  => 'question',
					-text    => 'Start up to date build?',
					-buttons => [qw(Yes No Cancel)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$makeName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom',
						  -fill => 'x',
						 );
	    my $answer = $dialog->Show();
	    if ($answer eq 'Cancel') {
		return 0;			# cancel operation
	    } elsif ($answer eq 'Yes') {
		print "do_scan: stop '$instName' start '$makeName'\n" if $opt_T;
		stop_file();			# $runName = ''
		$restartFlag = 1;		# restart after receiving stopped message
		return 0;
	    }
	}
	if ($fileName !~ /\b$procName\./) {
	    info_display(2000, 'red',
		"WARNING: '$fileName' does not match connected control program '$runName'");
	    $scanFlag = 0;
	    $scanButton->configure(-text => 'Live');
	    return;
	}
	$text->configure(-state => 'normal');
	$current = '1.0' unless defined $current;
	$last    = 'end' unless defined $last;
	my $length = '0';
	while (1) {
	    $current = $text->search(-count => \$length,
				     '-regexp',
				     '--',
				     $scanPattern,
				     $current,
				     $last);
	    last if (!$current);
	    $iw = $i = $text->get($current, "$current + $length char");
	    $i =~ s/(-)?([~\t ]*)(-\s*\d+|\w[\w\$]*(\s*\.\s*\w+)?)([~\t ]*)/$2$5/;
	    $word = defined $1 ? "$1$3" : $3;	# word for the symbol table
no warnings;
	    $tag = "'$word' length=$length, iw='$iw' i='$i' 1='$1' 2='$2' 3='$3' 5='$5'\n" if $opt_T;
use warnings;
	    $word =~ s/\s//g;			# delete any white space
	    if (defined $word and $symbolTable{$word}) {
		($ftype, $index) = @{ $symbolTable{$word} };
		if (defined $index and $ftype) {
		    print $tag if $opt_T;
		    $tag = $index;		# word is in the symbol table
		    $cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
		    @{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday]);
		    while ($i =~ m/~/g) {
			$cs ^= 1;		# complement initial colour selection
		    }
		    $tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
		    $ts++;			# convert to a mask 0 => 01, 1 => 02
		    print "$tag	$word	'$iw'\n" if $opt_T;
		    unless (($t = $activeSymbols[$index][0]) and ($t & $ts)) {
			## using $t | $ts causes warning of uninitialised value in (|)
			$activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			colourTag($tag, $cs);	# initial tag colour
		    }
		    $text->tagAdd($tag, $current, "$current + $length char");
		    if ($iw =~ /[\w.]+\s*=$/) {
			$tag = "$index=";
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless ($activeSymbols[$index][0] & 04) {
			    $activeSymbols[$index][0] |= 04; # for analog value display
			    colourTag($tag, 2);	# ARITH tag colour never changed
			}
			$text->insert("$current lineend", " 0", $tag);
		    }
		}
		## ELSE - there may be spurious words in symbolTable with undefined data
		##        as explained in "Programming Perl 3rd ed. page 254" - IGNORE
	    }
	    $current = $text->index("$current + $length char");
	}

	####################################################################
	## Send list of active symbols to the iC control process. Only the
	## state (logic or arithmetic) for the symbols in this list need to
	## be updated for this display, since the others are not displayed.
	## It is immaterial for the control program in which logic
	## sense the symbol is displayed, except for inverted ALIASes.
	####################################################################

	my $msg = '';
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index][0]) {
		print "$index\n" if $opt_T;
		if (length $msg > 391) {			# REPLY - 9 in icg.h
		    conn_send_now("$D_channel:3$msg");	# intermediate active symbols
		    printMicroSeconds();
		    print "sent '$D_channel:3$msg'\n" if $opt_t;
		    $msg = '';
		}
		$msg .= ";$index";
	    }
	}
	conn_send_now("$D_channel:4$msg");		# send last active symbols
	printMicroSeconds();
	print "sent '$D_channel:4$msg'\n" if $opt_t;
	conn_send_now("$D_channel:0");			# reset last value in iCserver

	####################################################################
	## Attach balloon processing
	####################################################################

	unless ($balloonAttached) {
	    $balloon->attach($text,
	       -balloonmsg      => \$bMsg,
	       -balloonposition => 'mouse', # not used since postcommand returns real position
	       -postcommand     => sub {
		    my ($word, $stem, $ftype, $index, $val, $wlen, $wlen_1);
		    ## Have a word under mouse - change the message:
		    $stem = $text->get($wIdx, "$wIdx lineend");
		    ## Skip if word starts with a non-word char
		    return 0 if not $stem or $stem =~ /^\W/;	# first character is not \w
		    print "$stem\n" if $opt_T;
		    ## Try bit I/O like IX0.0 QX10.7 or TX0.0_14 first
		    if ($stem =~ /^([IQT]X\d+\s*.\s*\d+(_\d+)?)/) {
			$word = $1;		# bit I/O variable found
			$wlen = length $word;
			$word =~ s/\s//g;	# delete possible white space around '.'
		    }
		    elsif ($stem =~ /^(\w[\$\w]*)/) {
			$word = $1;		# number or variable found
			$wlen = length $word;
			if ($word =~ /\d+/) {
			    $stem = $text->get("$wIdx linestart", "$wIdx + $wlen chars");
			    if ($stem =~ /((-\s*)\d+)\s*$/) {
				$word = $1;	# negative number
				$wlen = length $word;
				$wlen_1 = length $2;
				$wIdx = $text->index("$wIdx - $wlen_1 chars");
				$word =~ s/\s//g;	# delete possible white space around '-'
			    }
			}
		    } else {
			return 0;		# unlikely with \W test above
		    }
		    print "	word = $word\n" if $opt_T;
		    if (not defined ($index = $symbolTable{$word}[1])) {
			return 0;		# not found in S.T.
		    }
		    $wlen_1 = $wlen - 1;
		    $ftype = $symbolTable{$word}[0];
		    $val = $activeSymbols[$index][1]; $val = 0 unless $val;
		    print "	wlen = $wlen, index = $index, ftype = $ftype, val = $val\n" if $opt_T;
		    $val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
		    $bMsg = "$val";
		    $text->tag('add', 'sel', $wIdx, "$wIdx + $wlen chars");
		    ## a good place to put the balloon is below the last char in the word
		    my $i = $text->index("$wIdx + $wlen_1 chars");
		    my @p = $text->bbox($i);
no warnings;
		    my $x = $text->rootx + $p[0] + $p[2] - 4;
		    my $y = $text->rooty + $p[1] + $p[3] + 2;
use warnings;
		    return "$x,$y";
		},
	       -motioncommand   => sub {
		    my $x = $text->pointerx - $text->rootx;
		    my $y = $text->pointery - $text->rooty;
		    $wIdx = $text->index("\@$x,$y wordstart");
		    if ($wIdx eq $pIdx) {
			## Same word as previous word - dont cancel the balloon.
			return 0;
		    } else {
			## New word under mouse
			## cancel it so a new balloon will be posted.
			$text->SelectionClear;
			$pIdx = $wIdx;		# save as previous word
			return 1;
		    }
		},
	    );
	    $balloonAttached = 1;
	}

	####################################################################
	## change text on scan button to 'Edit'
	####################################################################

	$text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	$scanButton->configure(-text => 'Edit');
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
	$scanFlag = 1;		# scan successful
    } else {
	info_display(2000, 'red', "no current runnable proces");
    }
} # do_scan

########################################################################
#
#	Register_now
#
########################################################################

sub register_now {
    $scanFlag = 1;
    $scanButton->configure(-text => 'wait');
    print "$named: register_now 'wait'\n" if $opt_T;
    register_at_server();
    # will call do_scan() if connect was successful via Request S.T and :2 reply
} # register_now

########################################################################
#
#	Check if a file has been modified and needs to be saved
#
#	IF contents has changed AND Button 'Yes' is pressed
#		saves $fileName
#		changes entry box text to $fileName if successful
#		returns 1 if successful else 0
#	ELSE
#		does nothing
#		returns 0 if 'Cancel' else 1 ('No')
#
#	no regex matches allowed for run_file()
#
########################################################################

sub check_save {
    my $ret = 1;
    my $contents = $text->get("1.0", "end - 1 chars");	# whole text
    if ($contents ne $oldContents) {
	my $l1 = length $contents;
	my $l2 = length $oldContents;
	print "length contents = $l1, length oldContents = $l2\n" if $opt_T;
	my $dialog = $text->Dialog (-title   => 'Modified file',
				    -bitmap  => 'question',
				    -text    => 'Save modified file?',
				    -buttons => [qw(Yes No Cancel)],
				   );
	my $dialogBar = $dialog->Label(-textvariable => \$fileName,
				       -relief       => 'ridge',
				      )->pack(-side => 'bottom',
					      -fill => 'x',
					     );
	my $answer = $dialog->Show();
	if ($answer eq 'Cancel') {
	    $ret = 0;			# cancel operation
	} elsif ($answer eq 'Yes') {
	    $ret = save_file(1);	# save modified $fileName
	}
    }
    return $ret;
} # check_save

########################################################################
#
#	New text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    reset_scan();
    if (check_save()) {
	$text->delete("1.0", "end");
	$oldContents = '';
	$fileName = $newName;
	$mainWindow->title("$named$u: $fileName $runName");
    }
} # new_text

########################################################################
#
#	Open the list file (file.lst) for the currently loaded $fileName
#	Alternatively open the corresponding file.ic if file.lst open
#
########################################################################

sub open_list {
    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|lst?|c|ini)$/) {
	if ($4 eq 'lst') {
	    open_file(0, "$1.ic");
	} else {
	    open_file(0, "$1.lst");
	}
    } else {
	info_display(2000, 'red', "ERROR: no list file matching '$fileName'");
    }
} # open_list

########################################################################
#
#	Opens a file if possible; then loads the contents
#		parameter 1:	1 load unconditionally (discard changes)
#				0 or '' save first if text is altered (default)
#		parameter 2:	file_name
#				'' use getOpenFile from Tk::FBox (default)
#	$fileName is assigned new file_name if successfully opened
#	this is done, rather than returning new name because open_file is often
#	called from a call-back, where the return value cannot be used
#
#	file_name must be 2nd parameter to line up with search_text(), which
#	has a dummy 1st parameter and whose 2nd parameter searchText is also
#	supplied from a menu via a closure set up in check_menu()
#	both are called via check_menu()
#
########################################################################

sub open_file {
    my ($unconditional, $fName) = @_;	# optional parameters
    my $ci = 0;
    unless (defined $fName and $fName ne '') {
	$fName = $mainWindow->getOpenFile(-filetypes => $fileTypes);
	unless (defined $fName and $fName ne '') {
	    info_display(2000, 'red', "no file opened");
	    return;			# global $fileName is not altered
	}
	$fName =~ s#^C:/cygwin## or $fName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fName =~ s#^$cwd/##;
    }
    if ($fName ne $fileName) {
	print "open_file: $unconditional $fName\n" if $opt_T;
	if ($scanFlag) {
	    deleteAllTags();		# required here to clear = values in text
	    clear_scan();
	}
	my $rName = $runName;
	$rName =~ s/-\d+//;		# check without instance number
	if ($rName and $fName !~ /^$rName/) {
	    # old file is running and is not derived from new file
	    info_display(2000, 'red', "'$runName' is still running - should be stopped unless compatible with '$fName'");
	    my $dialog = $text->Dialog (-title   => 'Still running',
					-bitmap  => 'question',
					-text    => 'Stop executable?',
					-buttons => [qw(Yes No Cancel)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$runName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom',
						  -fill => 'x',
						 );
	    my $answer = $dialog->Show();
	    if ($answer eq 'Cancel') {
		info_display(2000, 'blue', "'$fName' was not loaded - '$runName' is still running");
		return 0;			# cancel operation
	    } elsif ($answer eq 'Yes') {
		print "open_file: open '$fName' stop '$runName'\n" if $opt_T;
		stop_file();			# $runName = ''
	    }
	}
	if ($unconditional or check_save()) {
	    stat($fName);
	    if (-f _ and -r _ and open(FH, "$fName")) {
		$text->delete("1.0", "end");	# clear the text area
		$oldContents = '';
		while (<FH>) {
		    $oldContents .= $_;
		}
		close(FH);
		## read last modified time from new stat now in case it changed since last stat
		$fileTime = (stat($fName))[9]; $fileTime = 0 unless defined $fileTime;
		$text->insert("end", $oldContents);
		my $length = length $oldContents;
		$fileName = $fName;	# alter global $fileName
		$mainWindow->title("$named$u: $fileName $runName");
		info_display(2000, 'black', "File '$fileName', $length bytes loaded");
		if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|lst?|c|ini)$/) {
		    $procName = $3;
		    $instName = "$procName$instanceText";
		    if ($4 eq 'lst') {
			$menuFile->entryconfigure(3, -label => 'Open.ic');
		    } else {
			$menuFile->entryconfigure(3, -label => 'Open.lst');
			check_menu($fileName, 'files');
		    }
		    $ci = change_instance();
		    adjust_live(-1, -1);
		}
		$prevText = '';		# start a new search
		return if $ci;		# global $fileName and application has altered
	    } else {
		check_menu($fName, 'files', 1);		# delete fName in the menu
		info_display(2000, 'red', "ERROR: Could not open $fName");
	    }
	}
	adjust_live();
    }
    return;
} # open_file

########################################################################
#
#	Saves the file previously loaded or last saved
#		parameter 1:	1 overwrite file unconditionally (new destination)
#				0 or '' overwrite if contents has changed (default)
#
########################################################################

sub save_file {
    my $ret = 1;		# good return
    if (defined $fileName and $fileName ne $newName and $fileName ne '') {
	my ($unconditional) = @_;	# optional parameter
	my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	## allow non existing file to be written by setting to $fileTime if undef
	if ($ftime != $fileTime) {
	    info_display(2000, 'red', "'$fileName' modified in background");
	    my $dialog = $text->Dialog (-title   => 'Modified since reading file',
					-bitmap  => 'question',
					-text    => 'Save to modified file?',
					-buttons => [qw(Yes No)],
				       );
	    my $dialogBar = $dialog->Label(-textvariable => \$fileName,
					   -relief       => 'ridge',
					  )->pack(-side => 'bottom',
						  -fill => 'x',
						 );
	    my $answer = $dialog->Show();
	    if ($answer ne 'Yes') {
		info_display(2000, 'red', "'$fileName' modified in background - not written");
		return 0;	# No or Cancel - report error
	    }
	    $unconditional = 1;	# definitely write to modified file
	}
	deleteAllTags();	# also clears @activeSymbols
	reset_scan(1);		# take away all live text
	my $contents = $text->get("1.0", "end - 1 chars");
	if ($unconditional or $contents ne $oldContents) {
	    ## rename to backup if $fileName exists (stat was done above)
	    if (-f _ and not rename $fileName, "$fileName.bak") {
		info_display(2000, 'red', "ERROR: Could not rename backup to '$fileName.bak'");
		$ret = 0;	# error return
	    }
	    elsif (open(FH, ">$fileName")) {
		$oldContents = $contents;
		my $length = length $oldContents;
		print FH $oldContents;
		close(FH);
		## read last modified time from new stat now as it changed since last stat
		$fileTime = (stat($fileName))[9]; $fileTime = 0 unless defined $fileTime;
		$mainWindow->title("$named$u: $fileName $runName");
		info_display(2000, 'black', "File '$fileName', $length bytes saved (backup '$fileName.bak')");
		check_menu($fileName, 'files');
	    } else {
		info_display(2000, 'red', "ERROR: Could not open '$fileName' for writing");
		$ret = 0;	# error return
	    }
	} else {
	    info_display(2000, 'blue', "FILE '$fileName' has not changed - not written");
	}
    } else {
	$ret = saveAs_file();
    }
    return $ret;
} # save_file

########################################################################
#
#	Save file to suggested $fileName or to another selected file_name
#		return:		1  file successfully saved, instance is reset
#				0  failure - $fileName not changed
#	$fileName is assigned new file_name if successfully saved
#
########################################################################

sub saveAs_file {
    my $ret = 1;
    my $oldName = $fileName;
    $fileName = $mainWindow->getSaveFile(-filetypes => $fileTypes,
					 -initialfile => $fileName);
    if (defined $fileName and $fileName ne '') {
	if ($fileName ne $oldName) {
	    my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	    ## allow non existing file to be written by setting to $fileTime if undef
	    $fileTime = $ftime;
	}
	$fileName =~ s#^C:/cygwin## or $fileName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fileName =~ s#^$cwd/##;
	print "saveAs_file: $fileName\n" if $opt_T;
	if (save_file($fileName ne $oldName) == 0) {
	    ## could not save $fileName
	    $fileName = $oldName;	# restore fileName
	    $mainWindow->title("$named$u: $fileName $runName");
	    $ret = 0;
	} elsif ($fileName ne $oldName) {
	    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|lst?|c|ini)$/) {
		$procName = $3;
		$instanceText = $instance = '';		# reset instance
		$instName = "$procName$instanceText";
		change_instance();
	    }
	    $prevText = '';		# start a new search
	}
    } else {
	info_display(2000, 'red', "no file saved");
	$fileName = $oldName;	# restore fileName
	$ret = 0;
    }
    return $ret;
} # saveAs_file

########################################################################
#
#	Build a target file generated from $fileName (C file or executable)
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate a new target file if target is older than $fileName
#	or unconditional build was specified.
#
#	2nd parameter:	0   Build executable
#			1   Save & Build unconditionally
#			2   Build C file only
#
########################################################################

sub build_file {
    my $par2 = $_[1];
    my $saved = 0;
    if ($fileName !~ /(^[\w\.\\\/]+)\.ic/) {
	info_display(2000, 'blue', "WARNING: cannot build '$fileName' (must end in .ic)");
    } else {
	my $baseName = $1;
	deleteAllTags();		# also clears @activeSymbols
	reset_scan(1);			# must be done before save_file, because live expands text
	if ($par2 == 1) {
	    $saved = save_file(1);	# save unconditionally
	} else {
	    $saved = check_save();
	}
	if ($saved) {
	    my $targetName = $par2 == 2 ? "$baseName.c" : $baseName;
	    my $ftime = (stat($fileName))[9]; $ftime = 0 unless defined $ftime;
	    my $mtime = (stat($targetName))[9]; $mtime = 0 unless defined $mtime;
	    my $ret = 0;
	    if ($par2 == 1 or $mtime < $ftime) {
		## system() requires signal CHLD to notify completion
		$SIG{CHLD} = 'DEFAULT';
		my @args = ("iCmake", "-qA", $fileName, "2>&1");	# -A useful for live display
		if ($par2 == 2) {
		    splice(@args, 1, 0, '-b');	# iCmake -b to suppress making executable
		}
		print "qx(@args)\n" if $opt_T;
		my @errText = qx(@args);	# exwcute iCmake ...
		$ret = $? >> 8;
		my $len = @errText;
		my $gr = grep /^\*\*\* /, @errText;
		print "ret = $ret, len = $len, *** = $gr\n" if $opt_T;
		print STDERR @errText;
		$SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
		if ($ret or $gr) {
		    sleep 2;
		    my $listName = "$baseName.lst";
		    open_file(1, $listName);	# load the listing file (iC is up to date)
		    $searchText = '^\*\*\* ';	# regular expression to find errors in listing
		    $prevText = '';		# start a new search
		    $matchType = '-regexp';
		    search_text(0, undef, 4);	# carry out the search, setting markers but no display
		}
		if ($ret) {
		    info_display(2000, 'red',
			"ERROR: '$targetName' cannot be built from '$fileName' (return = $ret)");
		    warn "ERROR: '$targetName' cannot be built from '$fileName' (return = $ret)\n";
		} else {
		    if ($runName ne '') {
			$makeName = $targetName;# running process is not current build
		    }
		    my $build_warnings;
		    if ($gr) {
			$build_warnings = "built with $gr Warnings - can be run";
			warn "WARNING: '$targetName' $build_warnings\n";
			$build_warnings .= " after pressing Alt-l";
		    } else {
			$build_warnings = "successfully built";
		    }
		    info_display(2000, 'dark green', "'$targetName' $build_warnings");
		}
	    } else {
		info_display(2000, 'blue', "'$targetName' is up to date");
	    }
	} # ELSE operation was cancelled by check_save() or file could not be saved
    }
} # build_file

########################################################################
#
#	Scroll text left or right
#
########################################################################

sub scroll_x_text {
    my ($dummy, $increment) = @_;
    print "scroll_x increment = '$increment'\n" if $opt_T;
    $text->xview('scroll', $increment, 'units');
    adjust_live();
} # scroll_x_text

########################################################################
#
#	Scroll text up or down
#
########################################################################

sub scroll_text {
    my ($dummy, $increment) = @_;
    print "scroll increment = '$increment'\n" if $opt_T;
    $text->yview('scroll', $increment, 'units');
    adjust_live();
} # scroll_text

########################################################################
#
#	Position text
#
########################################################################

sub position_text {
    my ($dummy, $position) = @_;
    print "scroll position = '$position'\n" if $opt_T;
    $text->see($position);
    adjust_live();
} # position_text

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    sleep 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    sleep 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Fork to the help process
#
########################################################################

sub fork_help {
    fork_and_exec('iCman', '-n', $named);
} # fork_help

########################################################################
#
#	Stop or run the executable file generated from $fileName
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate name of executable file from $fileName
#	run executable if it exists, is executable and newer than source
#
########################################################################

sub run_file {
    if ($runName ne '') {
	## running - stop application
	stop_file();
    } elsif ($fileName !~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|lst?|c|ini)$/) {
	info_display(2000, 'blue', "WARNING: cannot run '$fileName' (must end in .ic .lst .c or .ini)");
    } elsif ($4 ne 'ic' or check_save()) {
	my $processName = $1;		# full path name of executable
	$procName = $3;			# execuatble without directory path
	deleteAllTags();		# also clears @activeSymbols
	clear_scan(1);
	print "run_file: $processName from $fileName\n" if $opt_T;
	my $ftime = (stat($fileName))[9];
	my $mtime = (stat($processName))[9];
	if (not -f _) {
	    info_display(2000, 'red', "ERROR: no file named '$processName' (Build it first)");
	} elsif (not -x _) {
	    info_display(2000, 'red', "ERROR: '$processName' not executable ??");
	} elsif ($mtime < $ftime) {
	    info_display(2000, 'blue', "WARNING: '$processName' is older than '$fileName' (Build again)");
	} else {
	    $instName = "$procName$instanceText";
	    print "$named: register_at_server before fork_and_exec '$processName'\n" if $opt_T;
	    register_at_server();	# in case newly started
	    ## generate the call
	    $makeName = '';	# up to date build is running (unless deliberate No save)
	    my @call = ($processName);
	    splice @call, 1, 0, '-p', $opt_p if defined $opt_p;
	    splice @call, 1, 0, '-t' if defined $opt_t;
	    splice @call, 1, 0, "-d$opt_d" if defined $opt_d;
	    splice @call, 1, 0, '-m' if defined $opt_m;
	    splice @call, 1, 0, "-i$instance" if (defined $instance and $instance ne '');
	    print "@call\n" if $opt_T;
	    ## fork and exec the call
	    fork_and_exec(@call);	# if application starts it will send back <ch>:2;<name>
	}
    } # ELSE operation was cancelled by check_save()
} # run_file

########################################################################
#
#	Stop the control program if connected
#
########################################################################

sub stop_file {
    info_display(2000, 'blue', "'$runName' stopping");
    if ($scanFlag) {
	conn_send_now("$D_channel:5");		# GET_END - clear S.T.
	$scanButton->configure(-text => 'wait');	# was 'Edit'
	print "$named: stop_file 'wait'\n" if $opt_T;
    }				# leave scanButton as 'Edit' if not $scanFlag
    conn_send_now("$D_channel:6,$D_channel:0");	# STOP_PROGRAM
    # receives "$C_channel:5" from application when it quits - sets 'Run ' then
} # stop_file

########################################################################
#
#	Change instance selection
#
########################################################################

sub change_instance {
    if ($instName ne $regName or $oldInstance ne $instanceText) {
	print "$named: change_instance from '$oldInstance' to '$instanceText'\n" if $opt_T;
	$instName = "$procName$instanceText";
	print "$named: from regName '$regName' to instName '$instName'\n" if $opt_T;
	unregister_from_server();
	register_at_server();
	####################################################
	## change text on run button to 'Run '
	####################################################
	$runButton->configure(-text => 'Run ');
	$runName = '';		# if :2 is received will change back to <name>
	$mainWindow->title("$named$u: $fileName");
	print "$named: change_instance 'Run '\n" if $opt_T;
	$oldInstance = $instanceText;
	if ($scanFlag) {
	    $scanButton->configure(-text => 'wait');
	    print "$named: change_instance scan to 'wait'\n" if $opt_T;
	}
	return 1;
    }
    return 0;
} # change_instance

########################################################################
#
#	Enter a new value into a particular menu
#	check_menu (newEntry, menuKey[, delete])
#	    iniMenuData{menuKey} ==> [
#		menuRef,
#		menuPos,
#		entriesRef,
#		entriesLim,
#		commandRef,
#		cachingRef,
#	    ])
#	'newEntry' is appended to (or moved to the bottom of) the 'menuKey' menu
#	when 'delete' is set, 'newEntry' in the menu is deleted and not replaced
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey, $delete) = @_;
    my $menuData = $iniMenuData{$menuKey};
    my ($menuRef, $menuPos, $entriesRef, $entriesLim, $commandRef, $cachingRef) = @$menuData;
    my $oldEntry = $$entriesRef{$newEntry};
    $$cachingRef++;				# increment caching count
    $$entriesRef{$newEntry} = $$cachingRef;
    if ($menuRef) {
	my $size = scalar keys %$entriesRef;
	if ($oldEntry) {
	    $menuRef->menu->delete($newEntry);	# delete old entry
	} else {
	    $size++;				# menu increases in size
	}
	if ($delete) {
	    delete $$entriesRef{$newEntry};	# delete this entry
	} else {
	    $menuRef->command(-label   => "$newEntry",	# must use local $newEntry below
			      -command => [ $commandRef, 0, $newEntry, 0 ]);	# define 0 (down for search)
	    if ($size > $entriesLim + 1) {
		my $label = $menuRef->menu->entrycget($menuPos, '-label');
		print "label = $label size = $size\n" if $opt_T;
		$menuRef->menu->delete($menuPos);	# first dynamic menu entry
		delete $$entriesRef{$label};	# delete the oldest entry
	    }
	}
    }
    if ($opt_T) {
	if ($menuKey and $delete) {
	    print "check_menu: [$menuKey] '$newEntry' deleted\n";
	} else {
	    print "check_menu: [$menuKey] '$newEntry' {$$entriesRef{$newEntry}}\n";
	}
    }
} # check_menu

########################################################################
#
#	Initialise the program by reading .iClive.ini if it exists
#	and initialising file list and search list in menus
#	IF there are no file arguments, open the last open file
#	ELSE	open the first file in the argument list
#		add any others to the file list menu
#
#	structure of .iClive.ini
#	[files]
#		sort5.ic
#		sort5.lst
#		/tmp/trial.ic
#	[last open file]
#		sort5.ic		# last open file
#		27.4			# line #
#		1			# instance
#	[searches]
#		pip			# default match type is -exact
#		[files]			# a curious -exact match
#		timer		i	# match type -nocase (<tab>i)
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		ix[\d+]\.[\d+]	ri	# is resolved to -regexp -nocase
#
#	since tabs cannot be entered in the search entry box (skips to Text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($menuData, $menuKey, $entry, $initialFile, $position);
    ## restore file and search menu lists from .iClive.ini
    if (open(INI, ".$named.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniMenuData{$menuKey};
		print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
	    } elsif ($menuData and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		$entry = $_;
		check_menu($entry, $menuKey);
	    }
	}
	close(INI);
    }	# ignore if .iClive.ini cannot be opened or found
    $initialFile = shift @ARGV;			# ARGV may be empty
    unless (defined $initialFile and $initialFile ne '') {
	($initialFile, $position, $entry) = sort {		# forward sort
						    $lastFile{$a} <=> $lastFile{$b}
						 } keys %lastFile;
	if (not defined $entry and defined $position and $position =~ /^\d+$/) {
	    $entry = $position;
	}
	if (defined $position and $position !~ /^\d+\.\d+$/) {
	    $position = undef;
	}
no warnings;
	print "initialFile = '$initialFile' position = '$position' instance '$entry'\n" if $opt_T;
use warnings;
	if (defined $initialFile and not defined $opt_i) {
	    $instance = $entry;
	    if (defined $instance and $instance ne '') {
		$instanceText = "-$instance";
		if ($instance !~ /^[0-9]$/) {
		    push @instanceOptions, [$instanceText, $instance];
		    $instButton->configure(-options => \@instanceOptions);
		}
	    }
	}
    }
    if (defined $initialFile and $initialFile ne '') {
	open_file(0, $initialFile);
    }
    if (defined $position and $position ne '' and $position ne "1.0") {
	$text->see($position);			# Tk has segmentation fault if $position eq ''
	## grey out the whole line - until mouse moves
	$text->tagAdd('sel', "$position linestart", "$position lineend");
    } else {
	$position = "1.0";
    }
    $text->markSet('insert', $position);
    foreach $initialFile (@ARGV) {
	check_menu($initialFile, 'files');	# stuff the rest in the file menu list
    }
} # ini_program

########################################################################
#
#	Quit program after checking if file needs saving
#	and current file and search menu lists have been written
#
#	Care has been taken, that the hash indices $fileName, $position
#	and $instance can never be the same - they have different signatures
#		$fileName	\w+\.ic|lst|c
#		$position	\d+\.\d+
#		$instance	\d+
#	It is of course possible to fudge a filename like "0", which clashes
#	with instance 0. But "0" should be the executable built from "0.ic".
#
########################################################################

sub quit_program {
    my ($menuKey, $entriesRef, $entry);
    deleteAllTags();	# also clears @activeSymbols
    clear_scan();
    if (check_save()) {
	%lastFile = ();		# in case not fully shifted in ini_program due to $opt_i
	if (defined $fileName and $fileName ne $newName and $fileName ne '') {
	    $lastFile{$fileName} = 1; 
	    $lastFile{$text->index('insert')} = 2;
	    if (defined $instance and $instance ne '') {
		$lastFile{$instance} = 3;
	    }
	}
	## save file and search menu lists to .iClive.ini
	if (open(INI, ">.$named.ini")) {
	    foreach $menuKey (sort keys %iniMenuData) {
		print INI "[$menuKey]\n";
		print "INI: [$menuKey]\n" if $opt_T;
		$entriesRef = @{$iniMenuData{$menuKey}}[2];
		foreach $entry (sort {		# forward sort
					$$entriesRef{$a} <=> $$entriesRef{$b}
				     } keys %$entriesRef) {
		    if (defined $entry and $entry ne '') {
			print INI "\t$entry\n";
			print "INI:	$entry => '$$entriesRef{$entry}'\n" if $opt_T;
		    }
		};
	    }
	    close(INI);
	} else {
	    warn "ERROR: Can't open .$named.ini: $!\n";
	}
	print "$named: quit\n" if $opt_T;
	if ($server) {
	   conn_send_now('X') if $conn;	# iClive started iCserver - stop it
	} elsif ($runName ne '') {
	    print "quit_program() sends '$D_channel:7,$D_channel:0'\n" if $opt_T;
	    conn_send_now("$D_channel:7,$D_channel:0");
	    ####################################################
	    ## causes application to send C_channel:2;<name>
	    ## is available in iCserver for next iClive start
	    ####################################################
	}
	exit(0);
    }
    ## continue if check_save() was cancelled
} # quit_program

########################################################################
#
#	Compute and print elapsed microseconds (activated by $opt_m)
#
########################################################################

sub printMicroSeconds {
    my $t1 = tv_interval $t0, [gettimeofday];
    if ($opt_m) {
	my ($sec, $usec);
	$t1 = [gettimeofday];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t) {
	    printf "D%3d.%03d,%03d: ", $sec, int($usec/1000), $usec%1000;
	} else {
	    printf "D%3d.%03d,%03d\n", $sec, int($usec/1000), $usec%1000;
	}
    } elsif ($opt_t) {
	print "D: ";
    }
    $t0 = [gettimeofday];
} # printMicroSeconds

########################################################################
#
#	Output Symbol Table for debugging purposes
#	called by extra Build menu items activated by $opt_T
#
#	parameter 1	(ignore)
#	parameter 2	sorting order: 0 by name	1 by index
#
########################################################################

sub output_symbol_table {
    my $par2 = $_[1];
    if ($runName ne '') {
	my ($symbol, $index, $previndex);
	$previndex = -1;
	if ($par2 == 0) {
	    print "\nSymbol Table '$runName' by name\n";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    printf "%2s %-*s %4s\n", "ft", $maxSymbolLength, " name", "ix ";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    foreach $symbol (sort keys %symbolTable) {
		printf "%2s %-*s %4d\n",
		    $abbrevSelect[$symbolTable{$symbol}[0]],
		    $maxSymbolLength, $symbol,
		    $symbolTable{$symbol}[1];
	    }
	}
	elsif ($par2 == 1) {
	    print "\nSymbol Table '$runName' by index\n";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength, "\n";
	    printf "%4s %2s %-*s %2s %-*s .. ...\n", "ix ",
		"ft", $maxSymbolLength, " name",
		"ft", $maxSymbolLength, " name";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength;
	    foreach $symbol (sort {
				$symbolTable{$a}[1] <=> $symbolTable{$b}[1]
				||
				$a cmp $b
			    } keys %symbolTable)
	    {
		$index = $symbolTable{$symbol}[1];
		if ($index != $previndex) {
		    printf "\n%4d %2s %-*s", $index,
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		    $previndex = $index;
		} else {
		    printf " %2s %-*s",
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		}
	    }
	    print "\n";
	}
    } else {
	info_display(2000, 'red', "No Symbol Table - not connected to a running control program");
    }
} # output_symbol_table
__END__

############ POD to generate man page ##################################

=head1 NAME

 iClive - an editor and live debugger for iC clients

=head1 SYNOPSIS

 iClive [ -umtTh][ -s <host>][ -p <port>][ -i <inst>][ -f <font>]
        [ -l <num>][ -w <num>][ -g <geometry>][ -d <deb>][ <file> ...]
    -s host host name of server    (default 'localhost')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -f font font or font size to use in Text window (default '16')
    -l num  height of the Text window (default 40)
    -w num  width  of the Text window (default 80)
    -g geom geometry for main window (-g= is special small window)
    -d deb  extra debug options (see iCapplication -h)
    -t      trace output run time changes in target application (-d100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -u      activate undo edit facility (not recommended if Live display
            is used, because display may skip to lines which change)
    -h      help, ouput this Usage text only
    file ... one or more iC source files. The first will be opened. The
            rest will be stored in the File menu for later selection.

=head1 DESCRIPTION

 Menu buttons:                   Action                      Accelerator
    [File] New  provide a new empty file for editing.             Alt-n
       Open     open and load the selected file.                  Alt-o
       Open.lst open the listing x.lst corresponding to x.ic      Alt-l
       Save     save the current file if modified.                Alt-s
       SaveAs   store the current file at the selected path.      Alt-a
       Quit     quit the program.                                 Alt-q

    [Build]     build either the C file or the executable application
                from the currently displayed iC program text.     Alt-b

    [Run/Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [ -]        select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
    /Edit]      clears live markings in the Text window. In this mode
                the text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are described in the section 'KEYBOARD BINDINGS'
                (copied from Tk::Text).  If called with the -u option,
                ctrl-U is the <<Undo>> binding.

    [Search:]   in the Text window. Text may be scanned for an exact
                match or for a regular expression in the entry window
                next to the button. All hits will be marked. Repeating
                'Search down' or RETURN will display a new group of
                hits. 'Search up' or SHIFT-RETURN reverses the direction
                of scrolling.  Another option is to Go to a line entered
                in the entry window.                             RETURN

    [Help]      display this man page.                            Alt-h

In B<Edit> mode B<iClive> provides an edit window in which the text
of a source or listing can be displayed and optionally edited and
saved. The line number and column of the cursor are shown in the
bottom status bar.

In B<Live> mode B<iClive> is normally a client of a running
iC application. On startup it requests the symbol table of the
application. It returns a list of words from the symbol table on
which it wants live updates of the state of the nodes, named by each
word in the list. The application then provides updates to B<iClive>
when the state of any node from the list changes as soon as possible
after the change.

All words in the text which exactly match any token in the list are
marked with a colour depending on the current state of the node.
Logical nodes are B<green/black> for B<false> and B<yellow/red> for
B<true>.  Logical active words in the list which are preceded by ~
or ! or which are followed by ~ show the inverse state of the node.
Arithmetic nodes are B<blue>, clocks B<brown> and timers B<dark green>.
Clocks and timers flash briefly (50 ms) every time they fire.  All coloured
nodes are called 'active' words, because they display the live state of
these nodes in the running application.

When the mouse cursor sits on an active word the value of the node is
displayed in a balloon window. This is useful for displaying the current
value of arithmetic nodes. A line terminated with an active word followed
by an equal sign will be followed by the value of the word in a live display.

    eg.  // offset =
    will be displayed as
         // offset = 15
    (this construct is usually commented with //)

To be effective, the displayed text must be either the source of the
running iC application or a text derived from that source, such as the iC
listing.  Whenever a new iC text or another instance is selected, B<iClive>
will automatically attach itself to the selected application (provided it
is running).  B<iClive> shows the logical statements of the source and the
colours will show what the current state is.  It is easy to inspect
such a live listing and relate states with the logic of the application.

This program uses the Tk::Text widget, an extension Tk::TextUndo may
be used to provide an UNDO facility while editing. This extension has
disadvantages for the 'live display' - it is 7 times slower in making
arithmetic updates and it causes the window to jump to the last updated
text for value changes in the control application. This makes the 'live
display' hard to interpret. This does not happen with Tk::Text. If you
want to activate the UNDO facility use the -u option (recommended only
for editing)

=head1 KEYBOARD BINDINGS (from Tk::Text)

Tk automatically creates class bindings for texts that give them
the following default behavior.  In the descriptions below, 'word'
refers to a contiguous group of letters, digits, or '_' characters,
or any single character other than these.

[1] Clicking mouse button 1 positions the insertion cursor just before
   the character underneath the mouse cursor, sets the input focus to
   this widget, and clears any selection in the widget.  Dragging with
   mouse button 1 strokes out a selection between the insertion cursor
   and the character under the mouse.

[2] Double-clicking with mouse button 1 selects the word under the
   mouse and positions the insertion cursor at the beginning of the
   word.  Dragging after a double click will stroke out a selection
   consisting of whole words.

[3] Triple-clicking with mouse button 1 selects the line under the
   mouse and positions the insertion cursor at the beginning of the
   line.  Dragging after a triple click will stroke out a selection
   consisting of whole lines.

[4] The ends of the selection can be adjusted by dragging with mouse
   button 1 while the Shift key is down;  this will adjust the end
   of the selection that was nearest to the mouse cursor when button
   1 was pressed.  If the button is double-clicked before dragging
   then the selection will be adjusted in units of whole words; if
   it is triple-clicked then the selection will be adjusted in units
   of whole lines.

[5] Clicking mouse button 1 with the Control key down will reposition
   the insertion cursor without affecting the selection.

[6] If any normal printing characters are typed, they are inserted
   at the point of the insertion cursor.

[7] The view in the widget can be adjusted by dragging with mouse
   button 2.  If mouse button 2 is clicked without moving the mouse,
   the selection is copied into the text at the position of the
   mouse cursor.  The Insert key also inserts the selection, but at
   the position of the insertion cursor.

[8] If the mouse is dragged out of the widget while button 1 is
   pressed, the entry will automatically scroll to make more text
   visible (if there is more text offscreen on the side where the
   mouse left the window).

[9] The Left and Right keys move the insertion cursor one character
   to the left or right;  they also clear any selection in
   the text.  If Left or Right is typed with the Shift key down,
   then the insertion cursor moves and the selection is extended
   to include the new character.  Control-Left and Control-Right
   move the insertion cursor by words, and Control-Shift-Left and
   Control-Shift-Right move the insertion cursor by words and also
   extend the selection.  Control-b and Control-f behave the same as
   Left and Right, respectively.  Meta-b and Meta-f behave the same
   as Control-Left and Control-Right, respectively.

[10]
   The Up and Down keys move the insertion cursor one line up or
   down and clear any selection in the text.  If Up or Right is
   typed with the Shift key down, then the insertion cursor moves
   and the selection is extended to include the new character.
   Control-Up and Control-Down move the insertion cursor by paragraphs
   (groups of lines separated by blank lines), and Control-Shift-Up
   and Control-Shift-Down move the insertion cursor by paragraphs
   and also extend the selection.  Control-p and Control-n behave
   the same as Up and Down, respectively.

[11]
   The Next and Prior keys move the insertion cursor forward or
   backwards by one screenful and clear any selection in the text.
   If the Shift key is held down while Next or Prior is typed,
   then the selection is extended to include the new character.
   Control-v moves the view down one screenful without moving the
   insertion cursor or adjusting the selection.

[12]
   Control-Next and Control-Prior scroll the view right or left by one
   page without moving the insertion cursor or affecting the selection.

[13]
   Home and Control-a move the insertion cursor to the beginning of
   its line and clear any selection in the widget.  Shift-Home moves
   the insertion cursor to the beginning of the line and also extends
   the selection to that point.

[14]
   End and Control-e move the insertion cursor to the end of the line
   and clear any selection in the widget.  Shift-End moves the cursor
   to the end of the line and extends the selection to that point.

[15]
   Control-Home and Meta-< move the insertion cursor to the
   beginning of the text and clear any selection in the widget.
   Control-Shift-Home moves the insertion cursor to the beginning of
   the text and also extends the selection to that point.

[16]
   Control-End and Meta-> move the insertion cursor to the end of
   the text and clear any selection in the widget.  Control-Shift-End
   moves the cursor to the end of the text and extends the selection
   to that point.

[17]
   The Select key and Control-Space set the selection anchor to
   the position of the insertion cursor.  They don't affect the
   current selection.  Shift-Select and Control-Shift-Space adjust
   the selection to the current position of the insertion cursor,
   selecting from the anchor to the insertion cursor if there was
   not any selection previously.

[18]
   Control-/ selects the entire contents of the widget.

[19]
   Control-\ clears any selection in the widget.

[20]
   The F16 key (labelled Copy on many Sun workstations) or Meta-w
   copies the selection in the widget to the clipboard, if there is
   a selection.

[21]
   The F20 key (labelled Cut on many Sun workstations) or Control-w
   copies the selection in the widget to the clipboard and deletes
   the selection.  If there is no selection in the widget then these
   keys have no effect.

[22]
   The F18 key (labelled Paste on many Sun workstations) or Control-y
   inserts the contents of the clipboard at the position of the
   insertion cursor.

[23]
   The Delete key deletes the selection, if there is one in the widget.
   If there is no selection, it deletes the character to the right
   of the insertion cursor.

[24]
   Backspace and Control-h delete the selection, if there is one in
   the widget.  If there is no selection, they delete the character
   to the left of the insertion cursor.

[25]
   Control-d deletes the character to the right of the insertion
   cursor.

[26]
   Meta-d deletes the word to the right of the insertion cursor.

[27]
   Control-k deletes from the insertion cursor to the end of its
   line; if the insertion cursor is already at the end of a line,
   then Control-k deletes the newline character.

[28]
   Control-o opens a new line by inserting a newline character in
   front of the insertion cursor without moving the insertion cursor.

[29]
   Meta-backspace and Meta-Delete delete the word to the left of the
   insertion cursor.

[30]
   Control-x deletes whatever is selected in the text widget.

[31]
   Control-t reverses the order of the two characters to the right
   of the insertion cursor.

The following extra bindings have been defined for iClive:

[32]
   Alt-n   open a New file
   Alt-o   Open a file
   Alt-l   switch beteen iC-source and iC-Listing
   Alt-s   Save current file
   Alt-a   saveAs current file under a new name
   Alt-h   Help for iClive
   Alt-q   Quit iClive

   Alt-b   Build executable from current iC-file
   Alt-u   Unconditionally save and build
   Alt-c   build C-file only from current iC-file

   Alt-r   Run/stop the current executable
   Alt-e   switch between Edit/live mode

If the widget is disabled, as it is in 'Live' mode, then its view can
still be adjusted and text can still be selected, but no insertion
cursor will be displayed and no text modifications will take place.
In 'Live' mode the focus is normally on the y-Scrollbar or on the
search-Entry window.  The following Bindings have been programmed for
'Live' mode.

[33]
   The Left and Right keys scroll the whole text left and right one
   character at a time.

[34]
   The Up and Down keys scroll the text up and down one line at a time.

[35]
   The Next and Prior keys scroll the text up and down one page at
   a time.

[36]
   The Home and End keys move the text to the beginning or end.

These scroll modes are also available in 'Edit' mode, by putting
the focus in the 'search-Entry' window by clicking in it. To
continue editing click in the text window again.

[37]
   The view in the widget can be adjusted by dragging with mouse
   button 3. (same in both modes)

[38]
   In 'Live' mode the following Accelerators work without
   the Alt-Key pressed:
    l   switch beteen iC-source and iC-Listing
    h   Help for iClive
    q   Quit iClive
    r   stop the current executable (Alt-r to RUN again)
    s   Stop the current executable (Alt-r to RUN again)
    e   switch to Edit mode         (Alt-e for LIVE mode)
   All these accelerators (except s) also work with the
   Alt-Key pressed.

=head1 MODULE Time::HiRes

For measuring reaction times the Module Time::HiRes is used.  This
activates the -m option and flash display of short events.  Make sure
you have installed Time::HiRes (provided in this distribution)

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<john@je-wulff.de> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iCbox(1)>, L<iCserver(1)>, L<iCmake(1)>, L<iCman(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2005  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
