#!/usr/bin/perl

########################################################################
#
#	Copyright (C) 2000-2023  John E. Wulff
#
#   You may distribute under the terms of either the GNU General Public
#   License or the Artistic License, as specified in the README file.
#
#   For more information about this program, or for information on how
#   to contact the author, see the README file
#
#	iClive; an Integrated Development Environment (IDE) for editing
#	and debugging iC programs.
#
#	A full description is in the POD documentation at the end
#
#	Make sure your system has the Perl Module Time::HiRes installed.
#	This is required by this program and also activates the -m option
#	for measuring reaction times.
#
########################################################################

use Tk;			# The graphical user interface toolkit perl/Tk
			##                   by Nick Ing-Simmons
use iCmsg;		# Messaging Toolkit: from Advanced Perl Programming
			##                   by Sriram Srinivasan
use Tk::Balloon;
use Tk::Dialog;
use Tk::DialogBox;
use Tk::LabEntry;
use Cwd;
my $cwd = getcwd();	#  current working directory
use strict;
use warnings;
use Time::HiRes qw(sleep gettimeofday tv_interval);
my $t0 = [gettimeofday()];	# start time of program
my %delayedColour;	# colour that should be restored after a flash
my $shift_control_state = 0;
my @argv = ();

my %iniNames = ();
my %iniProcs = ();

########################################################################
#
#	Colour selection for background/foreground and lo/hi
#	$colourSelect[ftype] must match the definitions in 'icg.h'
#	Different ftypes select the 'cs' index to select four colours.
#	The last bit of cs selects the lo/hi colours.
#	ALIAS ftype's are generated by adding MAX_FTY (23) to ftype.
#	ftype MAX_FTY+GATE+INV has an odd 'cs' which inverts the colours.
#	Allow for GATE as well as GATEX by making INV (inversion << 1).
#
#	To display clocks and glitches, the foreground is flashed white
#	for 50 milliseconds. Flashing the background looks confusing.
#	Uses Tk::After. Flash 2 clocks in a row white. This happens if
#	CLOCK or TIMER has 2 slave gates which are fired together.
#
#	the following 3 arrays are indexed by gt_fni is ftype (see icc.h)
#
#	UDFA	ARITH	GATE	GATEX	RI_BIT	S_SH	R_SH	D_SH	0-8
#	CH_BIT	S_FF	R_FF	D_FF	CH_AR	F_SW	F_CF	F_CE	9-15
#	CLCK	TIMR	TRAB	OUTW	OUTX	CLCKL	TIMRL	F_ERR	16-23
#	MAX_FTY	+ARITH	+GATE	+GATEX	+GATE+INV  ...	+CLCKL	+TIMRL	23-28...44-45
#
#	ftype-abbreviations are used for debugging to list the Symbol Table.
#	They are also indexed by gt_fni (holds ftype). (lines up with FOPS in icc.h)
#
#   #define	FOPS	"UA _EsrHVSRDvIFGCTBWX:!e"	/* DEBUG display of ftypes */
#
#   list of ftypes fromm icc.h
#   #define	FULL_FTYPE
#	"UDFA","ARITH","GATE","GATEX","RI_BIT","S_SH","R_SH","D_SH",
#	"CH_BIT","S_FF","R_FF","D_FF","CH_AR","F_SW","F_CF","F_CE","CLCK","TIMR",
#	"TRAB","OUTW","OUTX","CLCKL","TIMRL","F_ERR",
#
########################################################################

my @abbrevSelect  = ( 'U','A',' ','_','E','s','r','H','V','S','R','D','v','I','F','G',
		      'C','T','B','W','X',':','!',		     # as[ftype] 0 - 22
		      'e','aA','a ','a_','~ ','~_','?','?','?','?','?','?','?','?','?',
		      '?','?','?','?','?','a:','a!',		     # ALIAS    23 - 45
		    );

my @full_ftype    = ( 'UDFA','ARITH','GATE','GATEX','RI_BIT','S_SH','R_SH','D_SH',
		      'CH_BIT','S_FF','R_FF','D_FF','CH_AR','F_SW','F_CF','F_CE','CLCK','TIMR',
		      'TRAB','OUTW','OUTX','CLCKL','TIMRL',	     # as[ftype] 0 - 22
		      'F_ERR','ARITH_ALIAS','GATE_ALIAS ','GATEX_ALIAS','INV_ALIAS ','INVX_ALIAS',
		      '?','?','?','?','?','?','?','?','?','?','?','?','?','?',
		      'CLCkL_ALIAS','TIMRL_ALIAS',		     # ALIAS    23 - 45
		    );

my @colourSelect  = ( 0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,0,0,0,2,2,0,4,6, # cs[ftype] 0 - 22
		      0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6, # ALIAS    23 - 45
		    );

#  live colouring     lo 0             hi 1                 cs  ftype
my @tagBackground = ('PaleGreen1'   , 'yellow2'      ,  #  0  1 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  #  2  3 ARITH
		     'chocolate1'   , 'chocolate1'   ,  #  4  5 CLCKL
		     'CadetBlue3'   , 'CadetBlue3'   ,  #  6  7 TIMRL
							## cs|010 no change
		     'PaleGreen1'   , 'yellow2'      ,  # 10 11 GATE
		     'LightSkyBlue1', 'LightSkyBlue1',  # 12 13 ARITH
		     'chocolate1'   , 'chocolate1'   ,  # 14 15 CLCKL
		     'CadetBlue3'   , 'CadetBlue3'   ,  # 16 17 TIMRL
		    );
my @tagForeground = ('black'        , 'red'          ,  #  0  1 GATE
		     'black'        , 'red'          ,  #  2  3 ARITH
		     'black'        , 'white'        ,  #  4  5 CLCKL
		     'black'        , 'red'          ,  #  6  7 TIMRL
							## cs|010 flash glitch
		     'white'        , 'white'        ,  # 10 11 GATE
		     'white'        , 'white'        ,  # 12 13 ARITH
		     'white'        , 'white'        ,  # 14 15 CLCKL
		     'white'        , 'white'        ,  # 16 17 TIMRL
		    );

#		key      $c3      $dir       $reg       $stop
my %pGroup = (	'{' => [ '}', '-forwards',  '[{}\'"]',     'end', ],
		'}' => [ '{', '-backwards', '[{}\'"]',     '1.0', ],
		'(' => [ ')', '-forwards',  '[()\'"]',     'end', ],
		')' => [ '(', '-backwards', '[()\'"]',     '1.0', ],
		'[' => [ ']', '-forwards',  '[\\[\\]\'"]', 'end', ],
		']' => [ '[', '-backwards', '[\\[\\]\'"]', '1.0', ],
	     );

# Tk::Text->search() does not accept a pre-compiled regex qr/.../
# ^# ^% ^%% ^%{ ^%} /* // */ ' " [ ] %{ %} { } {{ }} word \n$
my $regx = '(^\s*\d*\s*[#%][%{}]?\s*|^\d+\t|/[/*]|\*/|[\[\'"\]]|%?\{\{?|%?\}\}?|---|[A-Z_a-z][\w\$]*(\.[0-7](_\d+)?)?)';

my %keyWords = (		# $kw & 0x0001 iC only, 0x0002 C only, 0x0003 iC and C
	imm	=> 0x0001,	# iC type modifiers
	immC	=> 0x0001,
	bit	=> 0x0001,	# iC types
	int	=> 0x0803,	# $kw & 0x0800 allows int after FOR
	clock	=> 0x0001,
	timer	=> 0x0001,
	void	=> 0x0003,
	assign	=> 0x0001,	# iC parameter modifiers
	const	=> 0x0003,
	this	=> 0x0001,	# iC keywords
	return	=> 0x0003,
	extern	=> 0x0003,
	sizeof	=> 0x0003,
	switch	=> 0x0007,	# $kw & 0x0004 next { ... } block is C code
	if	=> 0x0107,	# $kw & 0x0100 #if %if %%if pre-processor commands
	else	=> 0x0107,	# $kw & 0x0100 #else %else %%else pre-processor commands
	auto	=> 0x0002,	# C keywords
	break	=> 0x0002,
	case	=> 0x0002,
	continue=> 0x0002,
	default	=> 0x0002,
	do	=> 0x0002,
	enum	=> 0x0002,
	for	=> 0x0002,
	goto	=> 0x0002,
	register=> 0x0002,
	typedef	=> 0x0002,
	while	=> 0x0002,
	static	=> 0x0002,	# C type modifiers
	struct	=> 0x0002,
	union	=> 0x0002,
	signed	=> 0x0002,
	unsigned=> 0x0002,
	volatile=> 0x0002,
	char	=> 0x0002,	# C types
	short	=> 0x0002,
	long	=> 0x0002,
	float	=> 0x0002,
	double	=> 0x0002,
	FORCE	=> 0x0001,	# iC built-in functions
	LATCH	=> 0x0001,
	DLATCH	=> 0x0001,
	D	=> 0x0001,
	DS	=> 0x0001,
	DS_	=> 0x0001,
	DR	=> 0x0001,
	DR_	=> 0x0001,
	DSR	=> 0x0001,
	DSR_	=> 0x0001,
	SR	=> 0x0001,
	SR_	=> 0x0001,
	SRX	=> 0x0001,
	SRR	=> 0x0001,
	SRR_	=> 0x0001,
	ST	=> 0x0001,
	SRT	=> 0x0001,
	JK	=> 0x0001,
	SH	=> 0x0001,
	SHR	=> 0x0001,
	SHR_	=> 0x0001,
	SHSR	=> 0x0001,
	SHSR_	=> 0x0001,
	RISE	=> 0x0001,
	FALL	=> 0x0001,
	CHANGE	=> 0x0001,
	CLOCK	=> 0x0001,
	TIMER	=> 0x0001,
	TIMER1	=> 0x0001,
	use	=> 0x0001,	# iC pragmas
	no	=> 0x0001,
	alias	=> 0x0001,
	strict	=> 0x0001,
	EOI	=> 0x0009,	# $kw & 0x0008 imm bit aliases - may be ALIAS in C code
	STDIN	=> 0x0009,
	LO	=> 0x0009,	# imm bit constants - ignore break - may be variable in C code
	HI	=> 0x0009,	#                   - never break anyway - may be ALIAS in C code
	T1ms	=> 0x0009,	# imm bit timer aliases - ignore break - may be ALIAS in C code
	T10ms	=> 0x0009,
	T100ms	=> 0x0009,
	T1sec	=> 0x0009,
	T10sec	=> 0x0009,
	T1min	=> 0x0009,
	FOR	=> 0x0010,	# $kw & 0x0010 "FOR" iCa keywords
	IF	=> 0x0020,	# $kw & 0x0020 "IF"
	ELSIF	=> 0x0040,	# $kw & 0x0040 "ELSIF"
	ELSE	=> 0x0080,	# $kw & 0x0080 "ELSE"
	include	=> 0x0100,	# $kw & 0x0100 cpp or immac pre-processor commands
	define	=> 0x0200,	# $kw & 0x0200 #define %define %%define generate macros
	undef	=> 0x0400,	# $kw & 0x0400 #undef  %undef  %%undef  removes macros
	line	=> 0x0100,
	error	=> 0x0100,
	pragma	=> 0x0100,
	ifdef	=> 0x0100,	# #if is marked above
	ifndef	=> 0x0100,
	elif	=> 0x0100,	# #else is marked above
	endif	=> 0x0100,
);

########################################################################
#
#	Initialization
#
########################################################################

my $named = $0; $named =~ s#.*[/\\]##;
my $LC_CTYPE = $ENV{LC_CTYPE};
if ($LC_CTYPE) {
    $LC_CTYPE =~ s/[\w_]+\.//;
} else {
    $LC_CTYPE = 'utf-8';
}
use vars qw($opt_ $opt_T $opt_q $opt_z $opt_S $opt_t $opt_m $opt_d $opt_s $opt_p $opt_i);
use vars qw($opt_D $opt_F $opt_E $opt_H $opt_W $opt_g $opt_A @opt_L $opt_u $opt_X $opt_h);
my $ofh = select(STDERR);	# save old file handle
$= = 1000;			# stop page overflow (default 60 lines)
select($ofh);			# retore old file handle

format STDERR =
Usage:
@<<<<< [ -umtTqh][ -s <host>][ -p <port>][ -i <inst>][ -D [@]IXy.z]
 $named,							'~'
       [ -F <font>][ -E <code>][ -H <num>][ -W <num>][ -g <geometry>]
       [ -A <cmd>][ -d <deb>][ <file> ...]
       [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -s host name of server host    (default '127.0.0.1')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -D IXy.z optional Debug Stop output to control moving parts in a plant
    -D @IXy.z inverted Debug Stop output 0 (non-inverted Stop is 1)
    '~'
    -F font or font size to use in Text window  (default '20')
    -E code encoding eg. ISO-8859-1 -  (locale value is @<<<<<<<<<)
							$LC_CTYPE
    -u      use edit undo facility (not recommended if using Live display)
    -H num  height of the Text window (default @<<)
					$opt_H
    -W num  width  of the Text window (default @<<) -w0 is terminal width
					$opt_W
    -g geom geometry for main window
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients if iCserver
            is started by this @<<<<< call (default 'iCbox')
				$named
                      BUILD option
    -L<lx>  link extra library(s) eg -L lm -L rt or -L lm,lrt
    file ... one or more space separated iC source files or comma
            separated groups if files. The first will be opened.
            The rest will be stored in the File menu for later.
            A comma separated group of files will be stored as a
            cascade in the File menu. The cascade group will be used
            to build one iC app from several files. If the first file
            has no .ic or .ica extension it is the run name of the app
            to be built and run. Otherwise the base name of the first
             (usually .ic file) is used as the run name.
            All other files in the comma separated list must be either
            .ic or .ica files to build the app.
            Any .ih %include or .iha %%include files in the nominated
            iC or iCa files will be automatically included in the
            cascade menu as relevant sources.
                      DEBUG options
    -d deb  extra debug options (see iC-application -h)
    -d  40  output symbol table received in Live mode
    -t      trace gate activity in target application (-d1100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -q      quiet - do not report apps connecting and disconnecting
    -h      help, ouput this Usage text only
                      AUXILIARY app
    -R <app ...> run auxiliary app followed by -z and its arguments
                 as a separate process; -R ... must be last arguments.

 Menu buttons:                   Action                      Accelerator

    [File] ---- tear-off - menu can be moved and left open
       New      empty file for editing                            Alt-n
       Open     and load the selected file                        Alt-o
       Reload   the current file (usually modified externally)    Alt-R
       file.lst switch file beteen iC-source and iC-Listing       Alt-l
       Save     the current file if modified                      Alt-s
       SaveAs   store the current file at the selected path       Alt-a
       Quit     the program                                       Alt-q
       -------- this is followed by a history of previous programs,
                which can be selected randomly

    [Build]     build the C file and then optionally the executable
                from the currently displayed iC program text.     Alt-b

    [Run Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [  -]       select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
     Edit]      clears live markings in the Text window. In this mode
                the text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are fully described in the @<<<<< man page under the
					   $named
                heading 'KEYBOARD BINDINGS'.  If called with the
                -u option, ctrl-U is the <<Undo>> binding.        Alt-e

    [ / ]       Put focus in Search Entry window if cleared.          /
                    (simulates vi)                           or   Alt-/
                Else start or continue a search of text in
                the Search Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options
       Search down      or                                       RETURN
                displays a new group of hits
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits
       Clear            or double-click Search Entry window or Ctrl-RET
                clears hits and the Search Entry window
       <>Go to line     or                                      Alt-RET
                goes to the line entered in the Search Entry window
       <>Word   match   (default - useful for finding variables)
       <>Exact  match   (search string matches anywhere in a word)
       <>Regexp match   (full Perl regular expression search)
       []Ignore case    (in any of the search modes)
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Debug]     Open a menu of options to start and stop Debug mode,
                which allows setting WatchPoints, interrupting,
                single stepping and continuing the program.

    [Help]      Display the @<<<<< man page.                      Alt-h
			    $named

Copyright (C) 2000-2023  John E. Wulff          <immediateC@gmail.com>
						    '@'
$Id: iClive 1.106 $ uses Tk-@<<<<<<<<<
						    $Tk::VERSION
.

########################################################################
#	Restore geometry
########################################################################

my $arg = $ARGV[0];
if ($arg and $arg =~ /^\d+x\d+(\+\d+\+\d+)?$/) {
    $opt_g = $arg;		# iClive restored after logout and restore
    shift @ARGV;		# first ARGV was a geometry
}

########################################################################
#	Handle -R option - count leading options up to -R
#	splice -R to end - move app and remaining arguments to @runArgs
########################################################################

my ($argIndex, $blank, $app, @runArgs);
$argIndex = $blank = 0;
@runArgs = ();
# print "0 \@ARGV = '@ARGV'\n";
foreach (@ARGV) {
    if (s/^-R(.*)$/$1/) {
	$blank = 1 if $_ eq "";		# -R <app> <args ...>
	$app = "";			# or -R<app> <args ...>
	last;
    } elsif (s/^(-[^dspiFlwgALR]+)R(.*)$/$1/) {
	$app = $2;			# -abcR<app> <args ...> or -abcR<app> <args ...>
	$argIndex++;
	last;
    }
    $argIndex++;
}
# no warnings;
# print "1 \@ARGV = '@ARGV'	\$argIndex = $argIndex	\$app = '$app' $#ARGV\n";
# use warnings;
@runArgs = splice @ARGV, $argIndex;
if (defined $app) {
    shift(@runArgs) if $blank;
    unshift(@runArgs, $app) if $app ne "";
}				# append a -z$opt_q later (-z not used in iClive)
# print "2 \@ARGV = '@ARGV'	\@runArgs = '@runArgs'\n"; exit;

########################################################################
#	Handle all remaining -switch options and non-switch options
########################################################################

use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions (
    ''    => \$opt_,			# lone - (not used)
    '<>'  => sub { push(@argv, @_); },	# Transfer file argument to @argv
    't'   => \$opt_t,
    'T'   => \$opt_T,
    'S=s' => \$opt_S,
    'm'   => \$opt_m,
    'u'   => \$opt_u,
    'X'   => \$opt_X,
    'q'   => \$opt_q,
    'z'   => \$opt_z,			# dummy option for -R; iClive needs stdin
    'd=i' => \$opt_d,
    's=s' => \$opt_s,
    'p=s' => \$opt_p,
    'i=i' => \$opt_i,
    'D=s' => \$opt_D,
    'F=s' => \$opt_F,
    'E=s' => \$opt_E,
    'H=i' => \$opt_H,
    'W=i' => \$opt_W,
    'g=s' => \$opt_g,
    'A=s' => \$opt_A,
    'L=s' => \@opt_L,
    'h'   => \$opt_h,
);
scalar @ARGV == 0 or die "*** ERROR: $named: '@ARGV' remaining after Getopt::Long Getoptions() ???\n";
print "\@argv = '@argv'	\@runArgs = '@runArgs'\n" if $opt_T;

########################################################################

exit if $opt_X;				# $named -X called in forked process if first exec fails

my $size = `stty size`;
chomp $size;
my @sizes = $size ? split ' ', $size : (35, 85);
print "size = '$size'\n" if $opt_T;
$opt_H = $sizes[0] unless $opt_H;	# if any higher than 35 on 768 pixel high screen, status bar is hidden
$opt_W = $sizes[1] if defined $opt_W and $opt_W == 0;	# adjust to terminal width
					# @sizes made the same as terminal size because on Debian systems 'man'
					# generates man pages the full width of the terminal (jw 20130829)
$opt_W = 85 unless $opt_W;		# 85 just allows all buttons to fit in the top menu bar (this wide anyway)
					# also gives a bit more room for oversize texts
print "opt_H = '$opt_H' opt_W = '$opt_W'\n" if $opt_T;
if ($opt_h) {
    write STDERR; exit;			# -h, ouput Usage only
}

if ($opt_q) {
    $opt_q = 'q';			# quiet option
} else {
    $opt_q = '';			# define $opt_q
}

$opt_A = 'iCbox' unless $opt_A;
$opt_S = 'iCserver' unless defined $opt_S;
my $u = '';
if ($opt_u) {
    use Tk::TextUndo;		# 7 times slower for live display and jerky
    $u = ' -u';			# show -u option in title when editing
}
my ($fontSize, $font_t, $boldfont_t, $italicfont_t, $bolditfont_t);
my ($font, $boldfont, $italicfont, $bolditfont, $encoding);
if (defined $opt_F) {
    if ($opt_F =~ /^\d+$/) {
	$fontSize = $opt_F;
    } else {
	$font_t = $opt_F;
	$fontSize = 20;
    }
}
unless ($font_t) {
    if ($ENV{COMSPEC}) {	# defined on Windows 98 and Windows XP
	$fontSize = 12 unless $fontSize;
	$font_t = "{Lucida Console} fontSize normal";
    } else {			# Linux - select with X program 'xfontsel'
	$fontSize = 20 unless $fontSize;
	$font_t = "-adobe-courier-medium-r-normal--fontSize-100-100-100-m-90-iso8859-1";
    }
}
if ($font_t =~ /medium-r/) {
    $boldfont_t = $italicfont_t = $bolditfont_t = $font_t;
    $boldfont_t =~ s/medium-r/bold-r/;
    $italicfont_t =~ s/medium-r/medium-o/;
    $bolditfont_t =~ s/medium-r/bold-o/;
} else {
    $boldfont_t   = "-adobe-courier-bold-r-normal--fontSize-100-100-100-m-90-iso8859-1";
    $italicfont_t = "-adobe-courier-medium-o-normal--fontSize-100-100-100-m-90-iso8859-1";
    $bolditfont_t = "-adobe-courier-bold-o-normal--fontSize-100-100-100-m-90-iso8859-1";
}
change_font(0, 0);		# set initial font size to $fontSize

@opt_L = split(/,/, join(',', @opt_L));	# allow -L lm,rt instead of -L lm -L rt

if ($Tk::VERSION >= 803) {
    $encoding = $opt_E ? ":encoding($opt_E)" : ":encoding($LC_CTYPE)";
} else {
    $encoding = '';		# no Unicode or other encoding (default is ISO-8859-1)
}

no warnings;
print "opt_F = '$opt_F' fontSize = '$fontSize'\nfont     = '$font'\nencoding     = '$encoding'\ncwd = '$cwd'\n" if $opt_T;
use warnings;

########################################################################
#
#	Handle signals
#
########################################################################

$SIG{PIPE} = 'IGNORE';		# ignore signal in syswrite() in iCmsg.pm line 103

########################################################################
#
#	Initialize global variables
#
########################################################################

my $host = defined $opt_s ? $opt_s : '127.0.0.1';
my $port = defined $opt_p ? $opt_p : 8778;
my %symbolTable = ();	# $symbolTable{$symbol} [0, 1]   = ($ftype, $index)
my @symbolNames = ();	# $symbolNames[$index] = symbol-id (does not include ALIASes or variations)
my %stepNames   = ();	# iC variables occurring in source
my %watchPoints = ();	# active Watch and Ignore points {$instName} {$index} [ $state, $value ]
my %watchList   = ();	# Listbox $dbLb data {$instName} [$i] [ $index, $symbol, $state, $value, $watchCond ]
my $lastIndex   = 0;
my $lastValue   = 0;
my $breakIndex  = 0;
my $maxSymbolLength = 4;
my @activeSymbols;	# $activeSymbols[$index][0 .. 3] = ($ts,$val,$cs,[$sec,$usec])
my $stIndex = 1;	# Symbol table entry index 0 is never used
my $conn;

my $info = '';		# info messages in status bar
my $infoDisplaying = 0;
my @infoMessages = ();

my $fileName = '';	# name of currently loaded file (should be iC, iCa or derivative)
my $fileTime = 0;	# last modified time of currently loaded file
my $readOnly = '';	# set ' (RO)' - true - if file in buffer is read-only
my $processName = '';	# full name of runnable iC control program with path
my $pathName = '';	# full path of runnable iC control program
my $extnName = '';	# extension of current iC or iCa program or derivative
my $procName = '';	# name of runnable iC control program without path
my $cascName = '';	# name of menu cascade if that is selected
my $cName = '';		# temporary name of menu cascade if that is selected
my $instName = '';	# name of runnable iC control program with instance extension
my $regName  = '';
my $runName  = '';	# name with extension of running iC control program showing window text
my %runNames = ();	# names with extensions of all iC control prograns currently running
my $makeName = '';
my $restartFlag = 0;
my $C_channel = 0;	# receiver channel from control program
my $D_channel = 0;	# sender channel to control program
my $B_channel = 0;	# sender channel for optional Debug Stop signal
my $searchText = '';
my $breakText = '';
my $break     = 0;
my $oldContents = '';
my $newContents = '';
my $disContents = '';
my $unknown = 'unknown.ic';

my $fileTypes = [
    ['iC Source Files',  ['.ic',  '.ica',  '.ih',   ], ['TEXT', ], ],
    ['iC Listing Files', ['.lst', '.lst6',          ], ['TEXT', ], ],
    ['C  Source Files',  ['.c',   '.h',             ], ['TEXT', ], ],
    ['Text Files',       ['.txt', '.text',          ],             ],
    ['Text Files',       ['',                       ], ['TEXT', ], ],
    ['All Files',        ['*',                      ],             ],
];

my %extnBits = (
    'ic'	=> 001,
    'ica'	=> 002,
    'lst'	=> 004,
    'lst6'	=> 004,
    'c'		=> 010,
    'h'		=> 020,
    'ini'	=> 040,
);

# in do_scan() Tk::Text->search() does not accept a pre-compiled regex qr/.../
# This pattern colours all leading and trailing spaces (used initially)
# my $scanPattern = '[~\s]*(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)\s*((~ )?---|=$)?';
# This pattern colours only one leading space or tab or '~' and one trailing space or tab; with numbers
my $scanPattern = '(\s?|~\s*)(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)(\s*((~ )?---|=$)|\s)?';
# This pattern colours only one leading space or tab or '~' and one trailing space or tab; leave out numbers
# NOTE the order of the regexes in the final (\s*((~ )?---|=$)|\s) - the final single white space is last or
# my $scanPattern = '(\s?|~\s*)([A-Z_a-z][\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)(\s*((~ )?---|=$)|\s)?';
my $bMsg = '';		# balloon message
my $wIdx = '';		# Index of current wordstart
my $pIdx = '';		# Index of previous wordstart

# has to be global, 'our' not portable yet
my (@hits, @groups, $gi, $gl, $centre, $lineCnt, $afterId);
my $prevText  = '';
my $prevMatch = '';
my $prevCase  = '';
my $prevStart = 0;
my $prevLast  = 0;
my $server    = 0;

########################################################################
#
#	Create main window and menus
#
#	NOTE: parameters in -command => [ ] closures are taken from the
#	      time the command was executed - not when event takes place.
#	      Use references to variables instead of value variables to
#	      pass information at run-time.
#
########################################################################

my $mainWindow = MainWindow->new();
if ($opt_g) {
    if ($opt_g =~ /^(\d+x\d+)?([+-]\d+[+-]\d+)?$/) {
	$mainWindow->geometry($opt_g);
    } else {
	warn "bad geometry string '$opt_g' - ignored\n";
	$opt_g = '';
    }
}
$mainWindow->title("$named$u");
$mainWindow->protocol('WM_DELETE_WINDOW', \&quit_program);	# Windows (X) pressed

########################################################################
#	Create and display an icon bitmap
########################################################################

my $icon = pack("b48" x 48,
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "..........................................111...",
    "................................1111111...111...",
    ".....111.....................1111111111111111...",
    "....11111..................111111111111111111...",
    "...1111111...............11111111111111111111...",
    "...1111111..............111111111111111111111...",
    "...1111111.............11111111.........11111...",
    "....11111.............1111111.............111...",
    ".....111.............111111................11...",
    "....................111111......................",
    "....................11111.......................",
    "...................11111........................",
    "...................11111........................",
    "..................11111.........................",
    "...111111.........11111.........................",
    "...111111.........1111..........................",
    "...111111........11111..........................",
    "....11111........11111..........................",
    "....11111........11111..........................",
    "....11111........11111..........................",
    "....11111........11111..........................",
    "....11111........11111..........................",
    "....11111........11111..........................",
    "....11111.........1111..........................",
    "....11111.........11111.........................",
    "....11111.........11111.........................",
    "....11111..........11111........................",
    "....11111..........11111........................",
    "....11111...........11111.......................",
    "....11111...........111111......................",
    "....11111............111111................11...",
    "....11111.............1111111.............111...",
    "....11111..............11111111.........11111...",
    "....11111...............111111111111111111111...",
    "....11111................11111111111111111111...",
    "...1111111.................11111111111111111....",
    "...1111111...................1111111111111......",
    "...1111111......................1111111.........",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
);
$mainWindow->DefineBitmap('icon' => 48, 48, $icon);
$mainWindow->iconbitmap("icon");	# could use built in bitmap like "Tk" instead

########################################################################
#	Menu bar
########################################################################
my $menuBar = $mainWindow->Frame()->pack(-side => 'top', -fill => 'x');

########################################################################
#	File menu
########################################################################
my $menuFile = $menuBar->Menubutton(-text               => 'File',
				    -relief             => 'raised',
				    -borderwidth        => 2,
				    -takefocus          => 1,
				    -highlightthickness => 1,
				    -tearoff            => 1,		# 0 - tear off
				   )->pack(-side => 'left', -padx => 2);
$menuFile->command(-label       => 'New',				# 1
		   -accelerator => 'Alt-n',
		   -command     => \&new_text);
$menuFile->command(-label       => 'Open',				# 2
		   -accelerator => 'Alt-o',
		   -command     => [ \&open_file, 1, '' ]);
$menuFile->command(-label       => 'Reload',				# 3
		   -accelerator => 'Alt-R',
		   -command     => \&reload_file);
$menuFile->command(-label       => 'Open.lst',				# 4 - is modified
		   -accelerator => 'Alt-l',
		   -command     => \&open_list);
$menuFile->command(-label       => 'Save',				# 5
		   -accelerator => 'Alt-s',
		   -command     => [ \&save_file, 0, 0 ]);
$menuFile->command(-label       => 'SaveAs',				# 6
		   -accelerator => 'Alt-a',
		   -command     => \&saveAs_file);
$menuFile->separator;				# ---------------------   7
$menuFile->command(-label       => 'Quit',				# 8
		   -accelerator => 'Alt-q',
		   -command     => \&quit_program);
$menuFile->separator;				# ---------------------   9
my $menuFileStart = 10;				# first dynamic entry:  # 10
my @dynamicFiles  = ();				# maintain local dynamic entries
my $menuFileLim   = 10;				# number of dynamic entries

my @lastFile      = ();				# save last open file

########################################################################
#	Build menu
########################################################################
my $menuBuild = $menuBar->Menubutton(-text               => 'Build',
				     -relief             => 'raised',
				     -borderwidth        => 2,
				     -takefocus          => 1,
				     -highlightthickness => 1,
				     -tearoff            => 1,		# 0 - tear off
				    )->pack(-side => 'left', -padx => 2);
$menuBuild->command(-label       => 'Build executable',			# 1
		    -accelerator => 'Alt-b',
		    -command     => [ \&build_file, 0, 0 ]);
$menuBuild->command(-label       => 'Save &Build unconditionally',	# 2
		    -accelerator => 'Alt-u',
		    -command     => [ \&build_file, 0, 1 ]);
$menuBuild->command(-label       => 'Build C file only',		# 3
		    -accelerator => 'Alt-c',
		    -command     => [ \&build_file, 0, 2 ]);
$menuBuild->separator;							# 4 - miscellaneous commands
$menuBuild->command(-label       => 'Symbol Table by name',		# 5
		    -state       => 'disabled',
		    -command     => [ \&output_symbol_table, 0, 0 ]);
$menuBuild->command(-label       => 'Symbol Table by index',		# 6
		    -state       => 'disabled',
		    -command     => [ \&output_symbol_table, 0, 1 ]);
$menuBuild->command(-label       => 'iCserver Client Tables',		#7
		    -state       => 'disabled',
		    -command     => sub { conn_send_now('T') if $conn; });
$menuBuild->command(-label       => 'Stop iCserver and all iC apps',	# 8
		    -command     => sub { conn_send_now('X') if $conn; });


########################################################################
#	Run or Stop button
########################################################################
my $menuRun  = $menuBar->Button(-text        => 'Run ',
				-relief      => 'raised',
				-borderwidth => 2,
				-width       => 4,
				-command     => \&run_file,
			       )->pack(-side => 'left', -padx => 2);

########################################################################
#	Instance button
########################################################################
my ($instanceText, $instance, $oldInstance);
my @instanceOptions = (
    [""  , ''],
    ["-0", 0 ],
    ["-1", 1 ],
    ["-2", 2 ],
    ["-3", 3 ],
    ["-4", 4 ],
    ["-5", 5 ],
    ["-6", 6 ],
    ["-7", 7 ],
    ["-8", 8 ],
    ["-9", 9 ]
);

$instanceText = $instance = '';
if (defined $opt_i and $opt_i ne '') {
    if ($opt_i =~ /^\d{1,3}$/) {	# INSTSIZE 3 defined in icc.h
	$instance = $opt_i;
	$instanceText = "-$instance";
	if (length $instance > 1) {
	    push @instanceOptions, [$instanceText, $instance];
	}
    } else {
	warn "$named: badly formed option -i $opt_i - ignored\n";
    }
}
$oldInstance = $instanceText;
print "instanceText=$instanceText, instance=$instance\n" if $opt_T;

my $menuInst  = $menuBar->Optionmenu(-command      => \&change_instance,
				     -textvariable => \$instanceText,
				     -variable     => \$instance,
				     -options      => \@instanceOptions
				    )->pack(-side => 'left', -padx => 2);

my $B_stop    = 0;		# sender value for Debug Stop signal when program stopped
my $B_cont    = 0;		# sender value for Debug Stop signal when program running
my $B_stopped = 0;		# flag delayed Debug Stop when program restarted
my $B_timer;			# timer for delayed Debug Stop
my $debugStop = '';		# IEC name of optional Debug Stop signal
if (defined $opt_D) {
    if ($opt_D =~ /^(\~)?(IX\d+)\.(\d+)$/ and $3 < 8) {
	$debugStop = "$2$instanceText";
	$B_stop = 1 << $3;	# 0x01 to 0x80 for .0 to .7
	if ($1) {		# '~'
	    $B_cont = $B_stop;
	    $B_stop = 0;
	}
	print "debugStop = $debugStop.$3 B_stop = $B_stop Bcont = $B_cont\n" if $opt_T;
    } else {
	warn "-D '$opt_D' is a bad IEC input string - ignored - no Debug Stop\n";
    }
}

########################################################################
#	Live or Edit button
########################################################################
my $liveButton = $menuBar->Button(-text        => 'Live',
				  -relief      => 'raised',
				  -borderwidth => 2,
				  -width       => 4,
				  -command     => \&scan,
				 )->pack(-side => 'left', -padx => 2);
my $scanFlag = 0;							# text is initially cleared

########################################################################
#	Search button
########################################################################
my $searchButton = $menuBar->Button(-text        => '/',
				    -relief      => 'raised',
				    -borderwidth => 2,
				    -command     => [ \&search_text, 0, undef, 0 ],	# Release-1
				   )->pack(-side => 'left', -padx => 2);
$searchButton->bind('<ButtonPress-1>',	[ \&SearchMenu, \$searchButton ]);

########################################################################
#	Search menu
########################################################################

my $searchMenu = $mainWindow->Menu();	# filled dynamically		# 0 - tear off
my $searchTimer;
my $matchType = 'w';			# default, alternatives -exact -regexp
my $ignoreCase = '-forwards';		# default place holder, alternative -nocase

$searchMenu->command(-label       => 'Search down',			# 1
		     -accelerator => 'Return',
		     -command     => [ \&search_text, 1, undef, 0 ]);
$searchMenu->command(-label       => 'Search up',			# 2
		     -accelerator => 'Shift-Ret',
		     -command     => [ \&search_text, 1, undef, 1 ]);
$searchMenu->command(-label       => 'Clear',				# 3
		     -accelerator => 'Ctrl-Ret',
		     -command     => [ \&search_text, 1, '',    0 ]);
########################################################################
#	Goto line number
########################################################################
$searchMenu->Radiobutton(-label    => 'Go to line',			# 4
			 -accelerator => 'Alt-Ret',
			 -value    => 'g',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 2 ]);
########################################################################
#	Word march	(default)
########################################################################
$searchMenu->Radiobutton(-label    => 'Word match',			# 5
			 -value    => 'w',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Exact match
########################################################################
$searchMenu->Radiobutton(-label    => 'Exact match',			# 6
			 -value    => '-exact',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Regexp match
########################################################################
$searchMenu->Radiobutton(-label    => 'Regexp match',			# 7
			 -value    => '-regexp',
			 -variable => \$matchType,
			 -command  => [ \&search_text, 1, undef, 0 ]);
########################################################################
#	Ignore case
########################################################################
$searchMenu->Checkbutton(-label    => 'Ignore case',			# 8
			 -offvalue => '-forwards',	# place holder
			 -onvalue  => '-nocase',
			 -variable => \$ignoreCase);
$searchMenu->separator;				# ---------------------   9
my $searchMenuStart  = 10;			# first dynamic entry:  #10
my @dynamicSearches  = ();			# maintain local dynamic entries
my $searchMenuLim    = 10;			# number of dynamic entries

########################################################################
#	Search entry
########################################################################
my $entrySearch = $menuBar->Entry(-width        => 20,
				  -background   => 'grey94',
				  -font         => $font,
				  -textvariable => \$searchText,
				 )->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom in button
########################################################################
$menuBar->Button(-text        => '-',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', -2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Zoom out button
########################################################################
my $zoomOut =
$menuBar->Button(-text        => '+',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => [ \&change_font, '', 2, ],
		)->pack(-side => 'left', -padx => 2);

########################################################################
#	Debug menu
########################################################################
my $debugButton =
$menuBar->Button(-text               => 'Debug',
		 -relief             => 'raised',
		 -borderwidth        => 2,
		 -takefocus          => 1,
		 -highlightthickness => 1,
		)->pack(-side => 'left', -padx => 2);
$debugButton->bind('<ButtonPress-1>',	[ \&showDebug, \$debugButton ]);
my $debugFlag = 0;		# no DEBUG mode unless manually started in LIVE mode
my $stepV     = 0;
my $nextV     = 0;
my $continueV = 0;
my $traceDebV = 0;
my $microSecV = 0;
my $menuBox;

my $debugMenu = $mainWindow->Menu(-tearoff => 0);	# NOTE next index is 0

$debugMenu->checkbutton(-label       => 'Debug',			# 0
			-accelerator => 'd',
			-state       => 'disabled',
			-variable    => \$debugFlag,
			-command     => [ \&sendDebug, 1, 'd' ]);
$debugMenu->separator;				# ---------------------   1
$debugMenu->checkbutton(-label       => 'Step',				# 2
			-accelerator => 's',
			-state       => 'disabled',
			-variable    => \$stepV,
			-command     => [ \&sendDebug, 0, 's' ]);
$debugMenu->checkbutton(-label       => 'Next',				# 3
			-accelerator => 'n',
			-state       => 'disabled',
			-variable    => \$nextV,
			-command     => [ \&sendDebug, 0, 'n' ]);
$debugMenu->checkbutton(-label       => 'Continue',			# 4
			-state       => 'disabled',
			-accelerator => 'c',
			-variable    => \$continueV,
			-command     => [ \&sendDebug, 0, 'c' ]);
$debugMenu->separator;				# ---------------------   5
$debugMenu->command    (-label       => 'Watch Points',			# 6
			-accelerator => 'w',
			-command     => [ \&ListWatchPoints ]);
$debugMenu->separator;				# ---------------------   7
$debugMenu->checkbutton(-label       => 'Trace',			# 8
			-accelerator => 't',
			-variable    => \$traceDebV,
			-command     => [ \&sendDebug, 0, 't' ]);
$debugMenu->checkbutton(-label       => 'MicroSec',			# 9
			-accelerator => 'm',
			-variable    => \$microSecV,
			-command     => [ \&sendDebug, 0, 'm' ]);

########################################################################
#	Help button
########################################################################
$menuBar->Button(-text        => 'Help',
		 -relief      => 'raised',
		 -borderwidth => 2,
		 -command     => \&fork_help,
		)->pack(-side => 'right', -padx => 2);

########################################################################
#	WatchPoint and IgnorePoint menu
########################################################################
my $watchMenu = $mainWindow->Menu(-tearoff => 0);	# NOTE next index is 0
my $watchIndex	= 0;
my $watchState	= 0;
my $watchValue	= 0;
my $watchV	= 0;
my $watchCondV	= 0;
my $ignoreV	= 0;
my $disableV	= 0;

$watchMenu->Checkbutton(-label       => 'Watch',			# 0
			-variable    => \$watchV,
			-command     => [ \&EnterWatch, 0, 1 ]);
$watchMenu->Checkbutton(-label       => ' Condition',			# 1
			-variable    => \$watchCondV,
			-command     => [ \&EnterWatch, 0, 2 ]);
$watchMenu->separator;				# ---------------------   2
$watchMenu->Checkbutton(-label       => 'Ignore',			# 3
			-variable    => \$ignoreV,
			-command     => [ \&EnterWatch, 0, 4 ]);
$watchMenu->separator;				# ---------------------   4
$watchMenu->Checkbutton(-label       => 'Disable',			# 5
			-variable    => \$disableV,
			-command     => [ \&EnterWatch, 0, 6 ]);
$watchMenu->separator;				# ---------------------   6
$watchMenu->command    (-label       => 'Cancel',			# 7
			-command     => [ \&EnterWatch, 0, 8 ]);

########################################################################
#	Watch word condition DialogBox
########################################################################

my $watchListTxt;
my $dbWval;
my @dbWbuttons = ('change','== X','!= X','< X','<= X','>  X','>=X','% X','!% X','& X','!& X','Cancel');
my $dbW = $mainWindow->DialogBox(
	-title => 'Word condition',
	-takefocus => 1,
	-buttons => [ @dbWbuttons ]);
$dbW->add('Label',
	-textvariable => \$watchListTxt,
	)->pack(-side => 'left', -fill => 'x');
my $dbX = $dbW->add('LabEntry',
	-textvariable => \$dbWval, -width => 20,
	-label => 'X',
	-labelPack => [ -side => 'left' ])->pack;
$dbW->configure(-focus => $dbX);
$dbW->attributes(-topmost => 1);
# use $answer = $dbW->Show() to display dialog box and to return text of button pressed.
# $dbWval contains value entered in LabEntry window.

########################################################################
#	Watch bit condition DialogBox
########################################################################

my @dbBbuttons = ('change',' == 1 ',' == 0 ','Cancel');
my $dbB = $mainWindow->DialogBox(
	-title => 'Bit condition',
	-takefocus => 1,
	-buttons => [ @dbBbuttons ]);
$dbB->add('Label',
	-textvariable => \$watchListTxt,
	)->pack(-side => 'left', -fill => 'x');
$dbB->attributes(-topmost => 1);
# use $answer = $dbB->Show() to display dialog box and to return text of button pressed.

########################################################################
#	DialogBox containing a Listbox of current Watch points
########################################################################

my @dbLbuttons = ('Lookup','Watch','Condition','Ignore','Enable','Disable','Delete','Close');
my $dbL = $mainWindow->DialogBox(
	-title => 'Watch and Ignore points',
	-takefocus => 1,
	-buttons => [ @dbLbuttons ]);
my $dbLb = $dbL->add('Scrolled', 'Listbox',
	-scrollbars => 'osoe',
	-selectmode => 'extended',
	-height => 8,
	-width => 48,
	-font => $font,
	-setgrid => 1,
	)->pack;
$dbL->configure(-focus => $dbLb);
$dbL->attributes(-topmost => 1);
# use $answer = $dbL->Show() to display dialog box and to return text of button pressed.

########################################################################
#	Ini data for file and search menu lists
########################################################################
my %iniMenuData = (
    files	=> [
	$menuFile->menu,	# menuRef,	file menu
	\@dynamicFiles,		# entriesArray,	maintain local dynamic entries
	$menuFileStart,		# menuPos,	start of dynamic entries
	$menuFileLim,		# entriesLim,	number of dynamic entries
	\&open_file,		# commandRef,	call back for open file
    ],
    'last open file' => [
	0,			# menuRef,	no menu
	\@lastFile,		# entriesArray,	save last open file, line # and instance
	0,
	0,			# entriesLim,	(not used)
	0,
    ],
    searches	=> [
	$searchMenu,		# menuRef,	search menu
	\@dynamicSearches,	# entriesArray,	maintain local dynamic entries
	$searchMenuStart,	# menuPos,	start of dynamic entries
	$searchMenuLim,		# entriesLim,	number of dynamic entries
	\&search_text,		# commandRef,	call back for search text
    ],
);

my %matchExtensions = (
    'w-forwards'	=> '',
    'w-nocase'		=> '	i',
    '-exact-forwards'	=> '	e',
    '-exact-nocase'	=> '	ei',
    '-regexp-forwards'	=> '	r',
    '-regexp-nocase'	=> '	ri',
    'g'			=> '	g',
);
my %matchRestores = (
    w		=> 'w -forwards',
    i		=> 'w -nocase',
    e		=> '-exact -forwards',
    ei		=> '-exact -nocase',
    r		=> '-regexp -forwards',
    ri		=> '-regexp -nocase',
    g		=> 'g -forwards',
);

########################################################################
#	Info bar
########################################################################
my $infoBar = $mainWindow->Label(-textvariable => \$info,
				 -relief       => 'ridge',
				)->pack(-side => 'bottom', -fill => 'x');

########################################################################
#	Text window
########################################################################
my $text;
if ($opt_u) {
    $text = $mainWindow->Scrolled('TextUndo',
				     -scrollbars => 'osoe',
				     -setgrid    => 2,
				     -background => 'cornsilk1',
				     -wrap       => 'none',	# horizontal scrollbar
				     -font       => $font,
				    )->pack(-fill => 'both', -expand => 1);
    $text->eventAdd('<<Undo>>' => '<Control-u>');	# extra Undo binding
} else {
    $text = $mainWindow->Scrolled('Text',
				     -scrollbars => 'osoe',
				     -setgrid    => 2,
				     -background => 'cornsilk1',
				     -wrap       => 'none',	# horizontal scrollbar
				     -font       => $font,
				    )->pack(-fill => 'both', -expand => 1);
}
unless ($opt_g) {
    $text->configure (-width  => $opt_W);
    $text->configure (-height => $opt_H);
}

my $yScrollbar = $text->Subwidget('yscrollbar');
my $xScrollbar = $text->Subwidget('xscrollbar');

####### Key and Mouse button bindings ##################################
####### Search entry bindings ##########################################
$entrySearch->bind('<KeyPress>',		[ \&set_shift_control     ]); # Set Shift/Control state
$entrySearch->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$entrySearch->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$entrySearch->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$entrySearch->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Double-1>',		[ \&search_now, '',    0  ]); # clear search
$entrySearch->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
####### File menu bindings #############################################
$entrySearch->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$entrySearch->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$entrySearch->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
$entrySearch->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
####### Run/Stop button binding ########################################
$entrySearch->bind('<Alt-Key-r>',		[ \&run_file              ]); # active in Live mode
####### Live/Edit button binding #######################################
$entrySearch->bind('<Alt-Key-e>',		[ \&scan                  ]); # active in Live mode
####### Help button binding ############################################
$entrySearch->bind('<Alt-Key-h>',		[ \&fork_help             ]); # active in Live mode
####### X-Movement bindings #### Y-Movement used by Entry #############
$entrySearch->bind('<Key-Down>',		[ \&scroll_text, 1        ]); # scroll down
$entrySearch->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$entrySearch->bind('<Key-Next>',		[ \&scroll_text, $opt_H-2 ]); # next page
$entrySearch->bind('<Key-Prior>',		[ \&scroll_text, -$opt_H+2]); # prior page
$entrySearch->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$entrySearch->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
####### Text window bindings ###########################################
$text      ->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$text      ->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$text      ->bind('<Button-1>',			[ \&report_cursor         ]); # change in cursor position
$text      ->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$text      ->bind('<Double-1>',			[ \&pick_word             ]); # select a search word in Live mode
$text      ->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$text      ->bind('<Key-F2>',			[ \&function2             ]); # write to /tmp/vim_buffer
$text      ->bind('<Shift-Key-F2>',		[ \&functionS2            ]); # read from /tmp/vim_buffer
####### Y-Scrollbar bindings ###########################################
$yScrollbar->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$yScrollbar->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$yScrollbar->bind('<Key-R>',			[ \&reload_file           ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$yScrollbar->bind('<Key-l>',			[ \&open_list             ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$yScrollbar->bind('<Key-q>',			[ \&quit_program          ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
$yScrollbar->bind('<Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Alt-Key-slash>',		[ \&new_search            ]); # simulate vi Search operator /
$yScrollbar->bind('<Key-Right>',		[ \&scroll_x_text, 1      ]); # scroll right
$yScrollbar->bind('<Key-Left>',			[ \&scroll_x_text, -1     ]); # scroll left
$yScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$yScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
$yScrollbar->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$yScrollbar->bind('<KeyRelease>',		[ \&adjust_live           ]);
$yScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$yScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$yScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear search
$yScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
$yScrollbar->bind('<Key-d>',			[ \&sendDebug, 'd'        ]); # Debug on active in Live mode
$yScrollbar->bind('<Key-s>',			[ \&sendDebug, 's'        ]); # Step
$yScrollbar->bind('<Key-n>',			[ \&sendDebug, 'n'        ]); # Next
$yScrollbar->bind('<Key-c>',			[ \&sendDebug, 'c'        ]); # Continue
$yScrollbar->bind('<Key-D>',			[ \&sendDebug, 'D'        ]); # Debug off
$yScrollbar->bind('<Key-t>',			[ \&sendDebug, 't'        ]); # activate/de-activate trace output in app
$yScrollbar->bind('<Key-m>',			[ \&sendDebug, 'm'        ]); # activate/de-activate microsecond output in app
$yScrollbar->bind('<Key-w>',			[ \&ListWatchPoints       ]); # open List Watch points DialogBox
####### X-Scrollbar bindings ###########################################
$xScrollbar->bind('<KeyPress>',			[ \&set_shift_control     ]); # Set Shift/Control state
$xScrollbar->bind('<KeyRelease>',		[ \&reset_shift_control   ]); # Reset Shift/Control state
$xScrollbar->bind('<Key-Down>',			[ \&scroll_text, 1        ]); # scroll down
$xScrollbar->bind('<Key-Up>',			[ \&scroll_text, -1       ]); # scroll up
$xScrollbar->bind('<Key-Next>',			[ \&scroll_text, $opt_H-2 ]); # next page
$xScrollbar->bind('<Key-Prior>',		[ \&scroll_text, -$opt_H+2]); # prior page
$xScrollbar->bind('<Key-Home>',			[ \&position_text, '1.0'  ]); # beginning
$xScrollbar->bind('<Key-End>',			[ \&position_text, 'end'  ]); # end
$xScrollbar->bind('<ButtonRelease>',		[ \&adjust_live           ]);
$xScrollbar->bind('<KeyPress-Return>',		[ \&search_now, undef, 0  ]); # search down
$xScrollbar->bind('<Shift-KeyPress-Return>',	[ \&search_now, undef, 1  ]); # search up
$xScrollbar->bind('<Control-KeyPress-Return>',	[ \&search_now, '',    0  ]); # clear search
$xScrollbar->bind('<Alt-KeyPress-Return>',	[ \&search_now, undef, 2  ]); # go to line
########################################################################
#	The Tk::Text Widget uses no Alt bindings - so we use them here
####### File menu bindings #############################################
$text      ->bind('<Alt-Key-n>',		[ \&new_text              ]); # not active in Live mode
$text      ->bind('<Alt-Key-o>',		[ \&open_file             ]); # not active in Live mode
$text      ->bind('<Alt-Key-R>',		[ \&reload_file           ]); # active in Live mode
$text      ->bind('<Alt-Key-l>',		[ \&open_list             ]); # active in Live mode
$text      ->bind('<Alt-Key-s>',		[ \&save_file, 0          ]); # not active in Live mode
$text      ->bind('<Alt-Key-a>',		[ \&saveAs_file           ]); # not active in Live mode
$text      ->bind('<Alt-Key-q>',		[ \&quit_program          ]); # active in Live mode
####### Build menu bindings ############################################
$text      ->bind('<Alt-Key-b>',		[ \&build_file, 0         ]); # not active in Live mode
$text      ->bind('<Alt-Key-u>',		[ \&build_file, 1         ]); # not active in Live mode
$text      ->bind('<Alt-Key-c>',		[ \&build_file, 2         ]); # not active in Live mode
####### Run/Stop button binding ########################################
$text      ->bind('<Alt-Key-r>',		[ \&run_file              ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-r>',		[ \&run_file              ]);
$yScrollbar->bind('<Key-r>',			[ \&run_file              ]);
$yScrollbar->bind('<Alt-Key-s>',		[ \&run_file              ]);
####### Live/Edit button binding #######################################
$text      ->bind('<Alt-Key-e>',		[ \&scan                  ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-e>',		[ \&scan                  ]);
$yScrollbar->bind('<Key-e>',			[ \&scan                  ]);
####### Help button binding ############################################
$text      ->bind('<Alt-Key-h>',		[ \&fork_help             ]); # active in Live mode
$yScrollbar->bind('<Alt-Key-h>',		[ \&fork_help             ]);
$yScrollbar->bind('<Key-h>',			[ \&fork_help             ]);
####### Change font size with Alt - and Alt + ##################
$text      ->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$text      ->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$yScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$yScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font
$xScrollbar->bind('<Alt-Key-plus>',		[ \&change_font, 2        ]); # increase font
$xScrollbar->bind('<Alt-Key-minus>',		[ \&change_font, -2       ]); # decrease font

########################################################################
#	Balloon widget
########################################################################
my $balloon = $mainWindow->Balloon(-state => 'balloon');
my $balloonAttached = 0;

########################################################################
#	Bug in Tk-804.027 (possibly only on MAC OsX-1.3-darwin)
#	next (commented) statement causes XS_TK__Callback_Call error
#	just forget about it ???	JW 2005/02/02
########################################################################
# $mainWindow->OnDestroy(sub { $balloon->destroy; });
$mainWindow->bind('<Configure>',		[ \&adjust_live           ]);
$dbL       ->bind('<FocusOut>',			[ \&lowerMain, $dbL       ]); # Watch window has lost focus
$dbW       ->bind('<FocusOut>',			[ \&lowerMain, $dbW       ]); # Word window has lost focus
$dbB       ->bind('<FocusOut>',			[ \&lowerMain, $dbB       ]); # Bit window has lost focus

########################################################################
#	Connect to iCserver
########################################################################
print "$named: initial connect_to_server\n" if $opt_T;
connect_to_server();

########################################################################
#	Optionally run -R option
########################################################################
if (@runArgs) {
    splice(@runArgs, 1, 0, "-s", "$host") unless $host eq "localhost" or $host eq "127.0.0.1";
    splice(@runArgs, 1, 0, "-p", "$port") unless $port eq "8778";
    splice(@runArgs, 1, 0, "-z$opt_q",);
    fork_and_exec(@runArgs);
}

########################################################################
#	Initialise file and search menu lists, open the first file.
#	NOTE:
#	must be called after register_at_server() - if not causes
#	search to misbehave with some program texts. The first $text->see()
#	positions first window with the named location at the top of
#	the window, rather than in the middle of the window - but only
#	with 'adobe ...' fonts - '9x15' works OK - STRANGE JW 25/07/2009
########################################################################
print "$named: initialise program\n" if $opt_T;
ini_program();
if ($fileName) {
    conn_send_now("$B_channel:$B_cont") if $B_channel and $B_cont;	# program running
    tagDeleteRestore_searchTag(1);		# configure initial 'searchTag'
}

########################################################################
#	Sit in an infinite loop dispatching incoming events.
########################################################################
MainLoop();
exit;

####### End of main program ############################################

########################################################################
#
#	Display information on the info bar
#	(make sure all displays to info bar go via this routine)
#	Parameter 1:	delay in milliseconds
#	Parameter 2:	colour (change if $message ne '')
#	Parameter 3:	message text
#
#	messages  are queued and displayed at <delay> ms intervals
#
########################################################################

sub info_display {
    push @infoMessages, @_;	# must always be 3 parameters
    display_callback() unless $infoDisplaying;	# wait if displaying
} # info_display

sub display_callback {
    my ($delay, $colour, $message);
    while (@infoMessages) {
	($delay, $colour, $message) = splice @infoMessages, 0, 3;	# shift 3
	if (length $message == 0) {
	    quit_program();	# called from disconnect
	}
	$infoBar->configure(-foreground => $colour) if $message ne '';
	$info = $message;	# display now
	print "display_callback: '$info'\n" if $opt_T;
	if ($delay) {
	    $infoDisplaying = 1;
	    $text->after($delay, \&display_callback);	# call self in delay ms
	    return;
	}
    }
    $infoDisplaying = 0;	# current display will stay - ready for imm change
} # display_callback

########################################################################
#
#	Tag all comments in text with tag 'cTag'	BLUE
#	Tag all C code in text with tag 'CTag'	  LIGHT GREY background
#	Tag all iCa lines in text with tag 'icaTag' LightPink background
#	Tag all iCa lines in text with tag 'sqbTag' Yellow    background
#	Tag all keywords in program text with tag 'bd'	BOLD
#	Tag all FOR control variables with tag 'cv'	BOLD raised relief
#	Tag all pre-proccessor commands with tag 'bt'	BOLD ITALICS
#	Tag all macros with tag 'it'			ITALICS
#	Tag all errors in program text with tag   'er'	BOLD RED
#
#	Collect all words in Symbol Table for     DEBUG STEP
#	Collect all outputs in Symbol Table for   DEBUG NEXT
#
#	Called in open_file() and save_file()
#	Indirectly in saveAs_file, build_file() and check_save()
#
#	return number of syntax errors (0 if none)
#
########################################################################

sub tagComments {
    my $err = 0;		# good outcome if 0 syntax errors
    my $length = 1;
    my $current = '1.0';	# start of text
    my $currEnd = '1.0';
    my $atom = '';
    my $extn = $extnName ? $extnBits{$extnName} : 000;
    $extn = 000 unless $extn;	# extnName not .ic 001 .ica 002 .lst .lst6 004 .c 010 .h 020 .ini 040
    print "tagComments: $current\n" if $opt_T;
    $text->tagDelete('cTag', 'CTag', 'icaTag', 'sqbTag', 'bd', 'er', 'cv', 'it', 'bt');	# delete all special tags
    $text->tagConfigure('cTag', -foreground => 'blue');
    $text->tagConfigure('CTag', -background => 'gray90');
    $text->tagConfigure('icaTag', -background => 'LightPink');
    $text->tagConfigure('sqbTag', -background => 'gold');
    $text->tagConfigure('bd',   -font       => $boldfont);
    $text->tagConfigure('er',   -font       => $boldfont, -background => 'red', -foreground => 'white');
    $text->tagConfigure('cv', -relief => 'raised', -borderwidth => 3, -font => $boldfont);
    $text->tagConfigure('it',  -font => $italicfont);
    $text->tagConfigure('bt',  -font => $bolditfont);
    my $cStart = '';
    my $pStart = '';
    my $state = "P";
    my $condFlag = 0;
    my $braceCount = 0;
    my $CbraceCount = 0;
    my $CStart = '';
    my $BraceCount = 0;
    my $FdF = 0;
    my $icaStart = '';
    my %FORcontrol = ();
    my $icaLoop = 0;
    my %macro = ();
    %stepNames  = ();
    my ($kw, $lv);
    my $prevKw = 0x0000;
    my $pp = '';
    my $ppC = '';
    my $ppI = '';
    my $sqbStart = '';
    my $endFlag = 0;
    my $listLine = 0;
    my ($l, $el);
    if ($extn & 030) {
	$state = "C";		# .c or .h file
	$CbraceCount = 1;
	$text->tagAdd('CTag', '1.0', 'end');
    }
    while (1) {
	my $prevEnd = $currEnd;
	my $prevAtom = $atom;
	$current = $text->search(-count => \$length,
				 -regexp,
				 -forwards,
				 '--',
				 $regx,		# search regular expression
				 $current,	# start index
				 'end',		# stop index
				);
	if ($current) {
	    $currEnd = $text->index("$current + $length chars");
	} else {
	    last if $endFlag++ >= ($state eq "p" or $state eq "Cp");
	    $currEnd = $current = 'end';
	    $length = 0;
	}
	my $space = $text->get($prevEnd, $current);	# text since end of previous search
	$atom = $text->get($current, $currEnd);		# text returned by current search
	print "t\t$prevEnd\t$current\t$currEnd\t'$prevAtom'\t'$space'\t'$atom'\n" if $opt_T;
	last if $prevAtom eq "NET" and $space eq " " and $atom eq "STATISTICS";
	my $current1 = $text->index("$current + 1 chars");	# visible char position in line for warn
	if ($atom eq '"' or $atom eq "'") {
	    my $c4 = $text->get("$current - 1 chars");
	    my $c5 = $text->get("$current - 2 chars");
	    if (($c4 eq "\\" and $c5 ne "\\") ||	# ignore \" and \' but not \\" and \\'
		($atom eq "'" and $c4 eq "-" and $c5 ne "'")) {
		$atom = '';		# also ignore -' LOGC flag in listing but not '-' and -"
	    }
	}
	########################################################################
	#  A pre-processor command starting with '#' must be either at the
	#  beginning of a line or immediately following %{ starting C code (%})
	#  %{ #include <stdio.h> %} // is allowed
	########################################################################
	if ($prevAtom =~ m/^(\s*\d*\s*)%\{\s*$/ and $space =~ m/^\s*(#|%%?)\s*$/) {
	    $atom = $space;		# %{ followed by # allowed on same line (%})
	    $length = length $atom;	# move tagging region back to start of new $atom
	    $currEnd = $current;	# repeat search without previous space
	    $current = $text->index("$currEnd - $length chars");
	    print "backtrack\n%{\t$prevEnd\t$current\t$currEnd\t'$prevAtom'\t'$space'\t'$atom'\n" if $opt_T;
	}
	########################################################################
	#  In an iC .lst file the iC keyword 'D' should only be bold if it occurs
	#  in a listing line, which starts with a line number.
	#  Other occurences of 'D' in a .lst file are the ftype indicator, which
	#  should not be bold. (Do this before C++ end analysis)
	########################################################################
	if ($space =~ m/\n/s) {
	    $listLine = 0;		# new line (one ore more)
	}
	if ($space =~ m/\n$/s and $atom =~ m/^\d+\t$/) {
	    $listLine = 1;		# 063	list line
	}
	########################################################################
	#  A C++ comment with embedded atoms requires '\n' to be found as $atom
	#  $text->search does not allow regx /.../s or /.../m (many errors)
	#  Extract '\n' out of $space and backtrack.
	########################################################################
	if (($state eq "p" or $state eq "Cp") and $space =~ m/.*?(\n)(.*)/s) {
	    $atom = $1;			# "\n"
	    $length = length $2;	# move tagging region back to start of new $atom
	    $currEnd = $text->index("$current - $length chars");
	    $current = $text->index("$currEnd - 1 chars");
	    print "backtrack\n//\t$prevEnd\t$current\t$currEnd\t'$prevAtom'\t'$space'\t'$atom'\n" if $opt_T;
	}
	if ($state eq "S") {		# string constant in iC code
	    if ($atom eq '"') {
		$sqbStart = $current if $sqbStart;	# end of string in square brackets - tag gold again
		$state = "P";
	    }
	} elsif ($state eq "H") {	# character constant in iC code
	    if ($atom eq "'") {
		$state = "P";
	    }
	} elsif ($state eq "c") {	# C style comment in iC code
	    if ($atom eq "*/") {
		$text->tagAdd('cTag', $cStart, $currEnd);
		$state = "P";		# end of C style comment in iC code found
	    } elsif ($atom eq "/*") {
		warn "$fileName$readOnly:$current1: /* found in comment\n";
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    }
	} elsif ($state eq "p") {	# C++ style comment in iC code
	    if ($atom eq "\n") {
		$text->tagAdd('cTag', $pStart, $currEnd);
		$state = "P";		# end of C++ style comment in iC code found
	    }
	} elsif ($state eq "CS") { 	# string constant in C code
	    if ($atom eq '"') {
		$sqbStart = $current if $sqbStart;	# end of string in square brackets - tag gold again
    print("\$state = $state ==> 'C'\n");
		$state = "C";
	    }
	} elsif ($state eq "CH") {	# character constant in C code
	    if ($atom eq "'") {
    print("\$state = $state ==> 'C'\n");
		$state = "C";
	    }
	} elsif ($state eq "Cc") {	# C style comment in C code
	    if ($atom eq "*/") {
		$text->tagAdd('cTag', $cStart, $currEnd);
    print("\$state = $state ==> 'C'\n");
		$state = "C";		# end of C style comment in C code found
	    } elsif ($atom eq "/*") {
		warn "$fileName$readOnly:$current1: /* found in comment\n";
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    }
	} elsif ($state eq "Cp") {	# C++ style comment in C code
	    if ($atom eq "\n") {
		$text->tagAdd('cTag', $pStart, $currEnd);
    print("\$state = $state ==> 'C'\n");
		$state = "C";		# end of C++ style comment in C code found
	    }
	} elsif ($state eq "C") {	# C code after if else switch or in literal block
	    ########################################################################
	    #  $state eq "C" C code
	    ########################################################################
	    if ($atom eq "{") {
		$CbraceCount++ if $CbraceCount > 0;
	    } elsif ($atom eq "}") {
		if ($CbraceCount > 0 and --$CbraceCount == 0) {
		    $l = 0;
		    goto EndC;
		}
		if ($CbraceCount <= 0) {
		    warn "$fileName$readOnly:$current1: } not in scope - too many closing single braces in C code ($CbraceCount)\n";
		    $text->tagAdd('er', $current, $currEnd);
		    $CbraceCount--;
		    $err++;
		}
	    } elsif ($atom =~ m/^(\s*\d*\s*)%\}\s*$/) {
		$l = length $1; $l = 0 unless $l;
		$CbraceCount--;		# "%}" end of C literal block found
	  EndC:	$text->tagAdd('CTag', $CStart, "$current + $l chars");
		$state = "P";		# end of C code found
		$CStart = '';		# back to iC background without CTag
		if ($CbraceCount != 0 or $braceCount != 0) {
		    warn "$fileName$readOnly:$current1: } single braces do not match in C code ($CbraceCount)\n";
		    $CbraceCount = 0;
		    $text->tagAdd('er', "$current + $l chars", $currEnd);
		    $err++;
		} else {
		    $text->tagAdd('bd', "$current + $l chars", $currEnd);	# bold brace at end of C code (optional)
		}
	    } elsif ($atom =~ m/^(\d*\s*)%\{\s*$/) {
		$l = length $1; $l = 0 unless $l;
		warn "$fileName$readOnly:$current1: '$atom' found in literal block\n";
		$text->tagAdd('er', "$current + $l chars", $currEnd);
		$err++;
	    } elsif ($atom =~ m/[A-Z_a-z][\w\$]*/) {	# C variable names
		if ($kw = $keyWords{$atom}) {
		    if ($kw & 0x00f0) {		# "FOR" 0x0010, "IF", 0x0020 "ELSIF" 0x0040, "ELSE" 0x0080
			if ($prevKw == 0x0080 and $kw == 0x0020) {	# allow ELSE IF
			    $text->tagAdd('bd', $current, $currEnd);	# iCa keyword in iCa code bold
			} else {
			    if ($icaStart) {
				warn "$fileName$readOnly:$current1: '$atom' follows previous iCa keyword not followed by {{\n";
				$text->tagAdd('er', $current, $currEnd);
				$err++;
			    } else {
				$text->tagAdd('bd', $current, $currEnd);	# iCa keyword in iCa code bold
			    }
			    $icaStart = $current;
			    $BraceCount++;		# start counting at the iCa keyword - not at opening braces
			    if ($kw & 0x0010) {	# "FOR"
				$FdF = 1;	# start looking for FOR loop control variable
			    }
			}
		    } elsif ($pp and $kw & 0x0700) {	# pre-processor commands tested before keywords
			if ($ppC) {		# may contain #if or #else
			    if ($BraceCount == 0) {
				$text->tagAdd('bt', $ppC, $currEnd);	# pp command in C code bold italics
				if ($kw & 0x0200) {
				    $FdF = 2;		# #define found in C code - look for macro
				} elsif ($kw & 0x0400) {
				    $FdF = 3;		# #undef found in C code - look for macro
				}
			    } else {
				warn "$fileName$readOnly:$current1: '$pp$atom' in FOR loop not handled by immac in C code\n";
				$text->tagAdd('er', $ppC, $currEnd);
				$err++;
			    }
			} elsif ($ppI) {
			    warn "$fileName$readOnly:$current1: '$pp$atom' iC or iCa pre-processor command in C code\n";
			    $text->tagAdd('er', $ppI, $currEnd);
			    $err++;
			}			# logic error in %keyWords table if neither (ignore)
			$pp = $ppC = $ppI = '';
		    } elsif ($FdF) {
			unless ($FdF == 1 and $kw == 0x803) {	# FOR followed by int is allowed
			    warn "$fileName$readOnly:$current1: $prevAtom command followed by keyword '$atom' in C code'\n";
			    $text->tagAdd('er', $current, $currEnd);
			    $err++;
			}
		    } elsif ($kw & 0x0002) {		# C variables outside of comments or strings
			$text->tagAdd('bd', $current, $currEnd);	# C keyword in C code bold
		    } elsif (!($kw & 0x0708)) {		# ignore ALIASES & preprocessor keywords not after $pp
    print("\$state = $state \$kw = $kw line = $current\n");
			warn "$fileName$readOnly:$current1: iC keyword '$atom' found in C code\n";
			$text->tagAdd('er', $current, $currEnd);	# iC keyword in C code error
			$err++;
		    }
		    $prevKw = $kw;
		} elsif ($FdF) {
		    print "$current	space = '$space'	atom = '$atom'\n" if $opt_T;
		    if ($space =~ m/^\s*\(*\s*$/) {	# only ( and white space allowed before control variable
			if ($FdF == 1) {
			    $FORcontrol{$atom} = $BraceCount;	# first non-keyword after FOR is control variable
			    $text->tagAdd('cv', $current, $currEnd);	# FOR control variable raised
			} elsif ($FdF & 2) {		# 2 or 3
			    if ($FdF == 2) {
				$macro{$atom} = 1;		# first non-keyword after #define (may be re-defined)
			    } elsif ($FdF == 3) {
				delete $macro{$atom}	# delete first non-keyword after #undef
			    }
			    $text->tagAdd('it', $current, $currEnd);	# macro in C code in italics
			}
		    } else {
			warn "$fileName$readOnly:$current1: '$prevAtom' followed by strange text '$space' before '$atom' in C code\n";
			$text->tagAdd('er', $prevEnd, $current);
			$err++;
		    }
		    $FdF = 0;
		} elsif ($lv = $FORcontrol{$atom}) {
		    if ($lv <= $BraceCount) {
			$text->tagAdd('cv', $current, $currEnd);	# FOR control variable raised in rest of loop
		    } else {
			warn "$fileName$readOnly:$current1: FOR control variable '$atom' is not in scope\n";
			$text->tagAdd('er', $current, $currEnd);
			$err++;
		    }
		} elsif ($macro{$atom}) {
		    $text->tagAdd('it', $current, $currEnd);	# macro in C code in italics
		} elsif ($icaStart and not $FORcontrol{$atom} and not $macro{$atom}) {
		    warn "$fileName$readOnly:$current1: FOR IF or ELSIF followed by non control variable or macro '$atom' in C code'\n";
		    $text->tagAdd('er', $current, $currEnd);
		    $err++;
		}
		if ($space eq " " and (
		    ($prevAtom eq "NET" and $atom eq "TOPOLOGY") or
		    ($prevAtom eq "Large" and $atom eq "AND"))) {
		    if ($CStart) {	# ******* NET TOPOLOGY    ******* Large AND or OR gates detected
			$text->tagAdd('CTag', $CStart, "$currEnd linestart");
			if ($CbraceCount != 1) {
			    warn "$fileName$readOnly:$current1: { single braces do not match in C code ($CbraceCount)\n";
			    $CbraceCount = 0;
			    $text->tagAdd('er', $current, $currEnd);
			    $err++;
			}
			$state = "P";
			$CStart = '';	# back to iC background without CTag
		    } elsif ($braceCount != 0) {
			warn "$fileName$readOnly:$current1: { single braces do not match in iC code ($braceCount)\n";
			$braceCount = 0;
			$text->tagAdd('er', $current, $currEnd);
			$err++;
		    }
		}
	    } elsif ($atom eq '"') {
		$state = "CS";		# start of string in C code found
		if ($sqbStart) {
		    $text->tagAdd('sqbTag', $sqbStart, $currEnd);	# tag up to " with gold tag
		    $sqbStart = $currEnd;
		}
	    } elsif ($atom eq "'") {
		$state = "CH";		# start of character constant in C code found
	    } elsif ($atom eq "/*") {
		$state = "Cc";		# start of C style comment in C code found
		$cStart = $current;
	    } elsif ($atom eq "//") {
		$state = "Cp";		# start of C++ style comment in C code found
		$pStart = $current;
	    } elsif ($atom eq "*/") {
		warn "$fileName$readOnly:$current1: */ found outside of comment\n";
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    } elsif ($atom eq "{{") {
		if (not $icaStart or $FdF == 1) {
		    warn "$fileName$readOnly:$current1: {{ not preceded by iCa keyword or FOR control variable\n";
		    $text->tagAdd('er', $current, $currEnd);
		    $FdF = 0;
		    $err++;
		} else {
		    $text->tagAdd('bd', $current, $currEnd);	# "{{"
		    $text->tagAdd('icaTag', $icaStart, $currEnd);
		    $icaLoop = 1;
		    $icaStart = '';
		}
		$prevKw = 0x0000;
	    } elsif ($atom eq "}}") {
		if ($icaStart) {
		    warn "$fileName$readOnly:$current1: }} follows previous iCa keyword not followed by {{\n";
		    $text->tagAdd('er', $current, $currEnd);
		    $err++;
		} elsif ($BraceCount <= 0) {
		    warn "$fileName$readOnly:$current1: }} not in scope - too many closing double braces\n";
		    $text->tagAdd('er', $current, $currEnd);
		    $BraceCount--;
		    $err++;
		} else {
		    $text->tagAdd('bd', $current, $currEnd);	# "}}"
		    $text->tagAdd('icaTag', $current, $currEnd);
		    if (--$BraceCount == 0) {
			$icaLoop = 0;
		    }
		}
	    } elsif ($atom =~ m/^(\s*\d*\s*)#\s*$/) {
		$l = length $1; $l = 0 unless $l;
		$pp = $atom;		# lead-in for C pre-processor commands #define etc
		$ppC = "$current + $l chars";
		print "ppC '$atom' found in C code\n" if $opt_T;
		goto NextAtom;		# do not clear $pp $ppC
	    }
	    if ($atom =~ m/^(\s*\d*\s*)%%?\s*$/) {
		$l = length $1; $l = 0 unless $l;
		$pp = $atom;		# lead-in for iC or iCa pre-processor commands %define %%define etc
		$ppI = "$current + $l chars";
		print "ppI '$atom' found in iC or iCa code\n" if $opt_T;
		goto NextAtom;		# do not clear $pp $ppI
	    }				# end of  $state eq "C" C code
	} elsif ($atom =~ m/[A-Z_a-z][\w\$]*(\.[0-7](_\d+)?)?/) {	# iC variable names
	    ########################################################################
	    #  $state eq "P" iC code
	    ########################################################################
	    if ($kw = $keyWords{$atom}) {	# keywords outside of comments or strings in iC
		if ($kw & 0x00f0) {		# "FOR" 0x0010, "IF", 0x0020 "ELSIF" 0x0040, "ELSE" 0x0080
		    if ($prevKw == 0x0080 and $kw == 0x0020) {	# allow ELSE IF
			$text->tagAdd('bd', $current, $currEnd);	# iCa keyword in iCa code bold
		    } else {
			if ($icaStart) {
			    warn "$fileName$readOnly:$current1: '$atom' follows previous iCa keyword not followed by {{\n";
			    $text->tagAdd('er', $current, $currEnd);
			    $err++;
			} else {
			    $text->tagAdd('bd', $current, $currEnd);	# iCa keyword in iCa code bold
			}
			$icaStart = $current;
			$BraceCount++;		# start counting at the iCa keyword - not at opening braces
			if ($kw & 0x0010) {	# "FOR"
			    $FdF = 1;	# start looking for FOR loop control variable
			}
		    }
		} elsif ($pp and $kw & 0x0700) {	# pre-processor commands tested before keywords
		    if ($ppI) {			# may contain %if or %%else
			if ($BraceCount == 0) {
			    $text->tagAdd('bt', $ppI, $currEnd);	# pp command in iC or iCa code bold italics
			    if ($kw & 0x0200) {
				$FdF = 2;	# %define or %%define found in iC or iCa code - look for macro
			    } elsif ($kw & 0x0400) {
				$FdF = 3;	# %undef or %%undef found in iC or iCa code - look for macro
			    }
			} else {
			    warn "$fileName$readOnly:$current1: '$pp$atom' in FOR loop not handled by immac in iC or iCa code\n";
			    $text->tagAdd('er', $ppI, $currEnd);
			    $err++;
			}
		    } elsif ($ppC) {
			warn "$fileName$readOnly:$current1: '$pp$atom' C pre-processor command in iC or iCa code\n";
			$text->tagAdd('er', $ppC, $currEnd);
			$err++;
		    }			# logic error in %keyWords table if neither (ignore)
		    $pp = $ppC = $ppI = '';
		} elsif ($FdF) {
		    unless ($FdF == 1 and $kw == 0x803) {	# FOR followed by int is allowed
			warn "$fileName$readOnly:$current1: $prevAtom command followed by keyword '$atom' in iC code'\n";
			$text->tagAdd('er', $current, $currEnd);
			$err++;
		    }
		} elsif ($kw & 0x0001) {
		    if (($extn & 003) or $listLine) {		# must be preceded by line number in .lst file ($extn 004)
			$text->tagAdd('bd', $current, $currEnd);	# iC keyword in iC code bold
		    }
		    if ($kw & 0x0004) {	# "if", "else" or "switch"
    print("1848 \$condFlag = $condFlag ==> 1 \$kw = $kw line = $current\n");
			$condFlag = 1;	# enter $state = "C" at next open brace "{"
		    } elsif ($kw & 0x0008) {
			markStepNames($atom);		# iC alias and constant keywords
		    }
		} elsif (!($kw & 0x0708)) {		# ignore preprocessor keywords not after $pp
		    warn "$fileName$readOnly:$current1: C keyword '$atom' found in iC code\n";
		    $text->tagAdd('er', $current, $currEnd);	# C keyword in iC code error
		    $err++;
		}
		$prevKw = $kw;
	    } else {
		if ($atom =~ m/[A-Z_a-z][\w\$]*/) {	# simple names, keywords excluded
		    if ($FdF) {
			print "$current	space = '$space'	atom = '$atom'\n" if $opt_T;
			if ($space =~ m/^\s*\(*\s*$/) {	# only ( and white space allowed before control variable
			    if ($FdF == 1) {
				$FORcontrol{$atom} = $BraceCount;	# first non-keyword after FOR is control variable
				$text->tagAdd('cv', $current, $currEnd);	# FOR control variable raised
			    } elsif ($FdF & 2) {		# 2 or 3
				if ($FdF == 2) {
				    $macro{$atom} = 1;		# first non-keyword after #define (may be re-defined)
				} elsif ($FdF == 3) {
				    delete $macro{$atom}	# delete first non-keyword after #undef
				}
				$text->tagAdd('it', $current, $currEnd);	# macro in iC code in italics
			    }
			} else {
			    warn "$fileName$readOnly:$current1: '$prevAtom' followed by strange text '$space' before '$atom' in iC code\n";
			    $text->tagAdd('er', $prevEnd, $current);
			    $err++;
			}
			$FdF = 0;
		    } elsif ($lv = $FORcontrol{$atom}) {
			if ($lv <= $BraceCount) {
			    $text->tagAdd('cv', $current, $currEnd);	# FOR control variable raised in rest of loop
			} else {
			    warn "$fileName$readOnly:$current1: FOR control variable '$atom' is not in scope\n";
			    $text->tagAdd('er', $current, $currEnd);
			    $err++;
			}
		    } elsif ($macro{$atom}) {
			$text->tagAdd('it', $current, $currEnd);		# macro in iC code in italics
		    } elsif ($icaStart) {
			warn "$fileName$readOnly:$current1: FOR IF or ELSIF followed by non control variable or macro '$atom' in iC code'\n";
			$text->tagAdd('er', $current, $currEnd);
			$err++;
		    }
		}
		if ($atom !~ m/^TX0/ and $atom ne 'iClock') {	# ignore timer variables, iClock and keywords
		  markStepNames($atom);				# except iC alias and constant keywords marked above
		}
		if ($prevAtom eq "C" and $space eq " " and $atom eq "CODE") {
		    if ($braceCount != 0) {
			warn "$fileName$readOnly:$current1: { single braces do not match in iC code ($braceCount)\n";
			$braceCount = 0;
			$text->tagAdd('er', $current, $currEnd);
			$err++;
		    }
    print("1906 \$state = $state ==> 'C' line = $current\n");
		    $state = "C";		# ******* C CODE          ************************
		    $CbraceCount = 1;
		    $CStart = "$current linestart";
		}
	    }
	} elsif ($atom eq '"') {
	    $state = "S";		# start of string in iC code found
	    if ($sqbStart) {
		$text->tagAdd('sqbTag', $sqbStart, $currEnd);	# tag up to " with gold tag
		$sqbStart = $currEnd;
	    }
	} elsif ($atom eq "'") {
	    $state = "H";		# start of character constant in iC code found
	} elsif ($atom eq "/*") {
	    $state = "c";		# start of C style comment in iC code found
	    $cStart = $current;
	} elsif ($atom eq "//") {
	    $state = "p";		# start of C++ style comment in iC code found
	    $pStart = $current;
	} elsif ($atom eq "*/") {
	    warn "$fileName$readOnly:$current1: */ found outside of comment\n";
	    $text->tagAdd('er', $current, $currEnd);
	    $err++;
	} elsif ($atom eq "{{") {
	    if (not $icaStart or $FdF == 1) {
		warn "$fileName$readOnly:$current1: {{ not preceded by iCa keyword or FOR control variable\n";
		$text->tagAdd('er', $current, $currEnd);
		$FdF = 0;
		$err++;
	    } else {
		$text->tagAdd('bd', $current, $currEnd);	# "{{"
		$text->tagAdd('icaTag', $icaStart, $currEnd);
		$icaStart = '';
		$icaLoop = 1;
	    }
	    $prevKw = 0x0000;
	} elsif ($atom eq "}}") {
	    if ($icaStart) {
		warn "$fileName$readOnly:$current1: }} follows previous iCa keyword not followed by {{\n";
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    } elsif ($BraceCount <= 0) {
		warn "$fileName$readOnly:$current1: }} not in scope - too many closing double braces\n";
		$text->tagAdd('er', $current, $currEnd);
		$BraceCount--;
		$err++;
	    } else {
		$text->tagAdd('bd', $current, $currEnd);	# "}}"
		$text->tagAdd('icaTag', $current, $currEnd);
		if (--$BraceCount == 0) {
		    $icaLoop = 0;
		}
	    }
	} elsif ($atom =~ m/^(\s*\d*\s*)%\{\s*$/) {
	    $l = length $1; $l = 0 unless $l;
	    $el = $l + 2;
    StartC: print("1963 \$state = $state ==> 'C' \$atom = $atom\n");
	    $state = "C";		# "%{" start of C literal block found (may be in function block definition)
##    StartC: $state = "C";		# "%{" start of C literal block found (may be in function block definition)
	    if ($braceCount != 0) {
		warn "$fileName$readOnly:$current1: { single braces do not match in iC code ($braceCount)\n";
		$braceCount = 0;
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    }
	    $CbraceCount = 1;
	    $text->tagAdd('bd', "$current + $l chars", $currEnd);	# bold brace at start of C code (optional)
	    $CStart = "$current + $el chars";
	} elsif ($atom =~ m/^(\d*\s*)%\}\s*$/) {
	    $l = length $1; $l = 0 unless $l;
	    warn "$fileName$readOnly:$current1: '$atom' found outside of literal block\n";
	    $text->tagAdd('er', "$current + $l chars", $currEnd);
	    $err++;
	} elsif ($atom eq "{") {
	    if ($condFlag) {
		$condFlag = $l = 0;	# start of C code after if else or switch
		$el = 1;
    print("1984 \$state = $state ==> 'C' \$atom = $atom line = $current\n");
		goto StartC;
	    }
	    if ($prevAtom ne "---" or $space ne "") {
		$braceCount++;		# single brace "{" in iC code
	    }
	} elsif ($atom eq "}") {
	    if (--$braceCount < 0) {
		warn "$fileName$readOnly:$current1: } not in scope - too many closing single braces in iC code($braceCount)\n";
		$text->tagAdd('er', $current, $currEnd);
		$err++;
	    }
	} elsif ($atom =~ m/^(\s*\d*\s*)#\s*$/) {
	    $l = length $1; $l = 0 unless $l;
	    $pp = $atom;		# lead-in for C pre-processor commands #define etc
	    $ppC = "$current + $l chars";
	    print "ppC '$atom' found in iC code\n" if $opt_T;
	    goto NextAtom;		# do not clear $pp $ppC
	}
	if ($atom =~ m/^(\s*\d*\s*)%%?\s*$/) {
	    $l = length $1; $l = 0 unless $l;
	    $pp = $atom;		# lead-in for iC or iCa pre-processor commands %define %%define etc
	    $ppI = "$current + $l chars";
	    print "ppI '$atom' found in iC code\n" if $opt_T;
	    goto NextAtom;		# do not clear $pp $ppI
	}
	if ($pp) {
	    if ($ppC) {			# incorrectly placed pre-processor lead-in or special
		$ppI = $ppC;
	    }
	    if ($atom eq '"' and $space =~ m/(\d+) /) {
		print "$fileName$readOnly:$current1: '$pp$space$atom' special preprocessor output\n" if $opt_T;
		$text->tagAdd('bd', $ppI, $current);
	    } else {
		warn "$fileName$readOnly:$current1: '$pp$space$atom' incorrect C, iC or iCa pre-processor command\n";
		if ($ppC) {		# incorrectly placed pre-processor lead-in
		    $ppI = $ppC;
		}
		$text->tagAdd('er', $ppI, $currEnd);
		$err++;
	    }
	    $pp = $ppC = $ppI = '';	# pre-processor lead-in must be followed by a pp command
	}
	########################################################################
	#  Square bracket expressions may be placed inside or outside comments
	#  as well as string or character constants in iC or C code, except in
	#  C code the square bracket expression must contain a FOR loop control
	#  variable to be marked, whereas in iC code this is not necessary.
	#
	#  Only square bracket expressions are marked
	#    1)  if the file name has the extension .ica
	#    2)  or after the occurence of a FOR or IF iCa command
	#    3)  or after the occurence of a %% iCa pre-processor command
	#    4)  for the innermost square bracket expression in a set of nested
	#        square brackets.
	########################################################################
	if ($atom eq "[" and
	    (
		$icaLoop or (
		    $state ne "C"  and	# exclude C code outside outermost FOR loop
		    $state ne "CS" and
		    $state ne "CH" and
		    $state ne "Cc" and
		    $state ne "Cp"
		)
	    )
	) {
	    $sqbStart = $current;	# nesting advances $sqbStart
	    if ($state eq "S") {
		warn "$fileName$readOnly:$current1: in iC '[' is not allowed in a string in an index expression\n";
		$text->tagAdd('er', $sqbStart, $currEnd);
		$err++;
	    }
	} elsif ($atom eq "]" and $sqbStart) {
	    if ($state eq "S") {
		my $ex = $text->get($sqbStart, $currEnd);	# error text
		warn "$fileName$readOnly:$current1: in iC '$ex' is not allowed in a string in an index expression\n";
		$text->tagAdd('er', $sqbStart, $currEnd);
		$err++;
	    } else {
		$text->tagAdd('sqbTag', $sqbStart, $currEnd);	# tag square bracket expression with gold tag
	    }
	    $sqbStart = "";		# end of innermost square bracket pair
	}
      NextAtom:
	$current = $currEnd;		# continue search after this atom
    }
    if ($CStart) {
	$text->tagAdd('CTag', $CStart, "$currEnd lineend");	# only happens if C code ends with an error
    }
    if ((($extn & 03) and					# only in .ic, .ih and .ica files but not .lst
	($braceCount or $CbraceCount or $BraceCount)) or
	(($extn & 030) and ($CbraceCount != 1))) {		# only in .c and .h files
	warn "$fileName$readOnly: single { ... } or double braces {{ ... }} do not match at end of file\n";
	$text->tagAdd('er', "end - 2 lines linestart", "end - 1 chars lineend");
	$err++;
    }
    if (not $err and %symbolTable) {
	print "tagComments: sendStepNext\n" if $opt_T;
	sendStepNext();			# adjust 'set' and 'next' bits in client
    }
    return $err;			# report number of syntax errors
} # tagComments

########################################################################
#
#	Mark an iC variable or alias keyword or constant passed to $atom
#	from tagComments() for setting up 'step' and 'next' lists
#	for 'debug' mode.
#	Parameter 1:	current atom
#
########################################################################

sub markStepNames {
    my ($atom) = @_;
    $stepNames{$atom} |= 0x1;		# iC variables - cannot check Symbol Table here
    if ($atom =~ m/^Q[XBWLH]\d+(\.[0-7])?$/) {
	$stepNames{"${atom}_0"} |= 0x2;	# iC output variables
    }
} # markStepNames

########################################################################
#
#	Send list of indexes for each variable and output in %stepNames
#	to client if it is running, has been registered and its
#	Symbol Table has been obtained.
#	Also set up all Watch/Ignore points if in Debug mode
#
########################################################################

sub sendStepNext {
    my ($symbol, $bits, $ftype, $index);
    my $stepMsg = '';
    my $nextMsg = '';
    foreach $symbol (sort keys %stepNames) {
	if (exists $symbolTable{$symbol}) {
	    ($ftype, $index) = @{ $symbolTable{$symbol} };
	    if ($index) {
		$bits = $stepNames{$symbol};
		print "$symbol	$bits	$index\n" if $opt_T;
		if ($bits & 0x2) {
		    $nextMsg .= ";$index";	# OUTPUT variable Q..._0
		} elsif ($bits & 0x1) {		# do not set both bits
		    $stepMsg .= ";$index";	# ACTIVE variable in this source
		}
	    }
	}
    }
    print "'$stepMsg'\n'$nextMsg'\n" if $opt_T;
    sendMsg( 8,  9, $stepMsg);		# send step variables (unlikely to be null)
    sendMsg(10, 11, $nextMsg);		# send next outputs even if null
    if ($debugFlag) {
	sendWatchRestore(0, 1);			# set all Watch and Ignore points
    }
} # sendStepNext

########################################################################
#
#	Send a ; separated message string to client in 1 or more sections
#	The length of each section sent is less than the TCP limit of 1400
#
########################################################################

sub sendMsg {
    my ($d, $e, $msg) = @_;
    my ($leader, $trailer, $tr1, $tr2);
    while (length $msg > 1390) {		# REPLY 1400 - 10 in tcpc.h
	$trailer = substr($msg, 1380);		# tested with 40 30 for limit of 50
	($tr1, $tr2) = split /;/, $trailer, 2;
	$leader = substr($msg, 0, 1380) . $tr1;
	$msg = ";$tr2";
	print "$D_channel:$d$leader\n" if $opt_T;
	conn_send_now("$D_channel:$d$leader");	# send intermediate message
    }
    print "$D_channel:$e$msg\n" if $opt_T;
    conn_send_now("$D_channel:$e$msg");		# send last message
} # sendMsg

########################################################################
#
#	Send a ; separated message string of Watch/Ignore points or
#	none/step/next restore values
#	The length of each section sent is less than the TCP limit of 1400
#	although it is very unlikely there will be that many Watch points
#
#	p1	0	send values for all indexes in %watchPoints
#		index	send one index value only
#	p2	0	restore none/step/next values from %stepNames
#		1	set Watch/Ignore derived from watchState
#
########################################################################

sub sendWatchRestore {
    my ($index, $set) = @_;
    my @points = ();
    my $msg = '';
    my ($ix, $stateRef, $symbol, $bits);
    if ($index) {
	push @points, $index;
    } else {
	push @points, keys %{ $watchPoints{$instName} };
    }
    foreach $ix (@points) {
	if (exists $watchPoints{$instName}{$ix}) {
	    $stateRef = \${ $watchPoints{$instName}{$ix} }[0];
	    if ($set and not $$stateRef & 0x40) {	# set Watch/Ignore if not disabled
		if ($$stateRef & 0x20) {
		    $msg .= ";$ix 0";			# Ignore point
		} elsif ($$stateRef & 0x10) {
		    $msg .= ";$ix 3";			# Watch point
		}
		$$stateRef |= 0x80 if $stateRef;	# set watchSet bit
	    } elsif ($$stateRef & 0x80) {		# restore set/next if previously watchSet
		$symbol = $symbolNames[$ix];
		$bits = $stepNames{$symbol};
		if (not $bits) {
		    $msg .= ";$ix 0";			# not an ACTIVE variable
		} elsif ($bits & 0x2) {
		    $msg .= ";$ix 2";			# OUTPUT variable Q..._0
		} elsif ($bits & 0x1) {			# do not set both bits
		    $msg .= ";$ix 1";			# ACTIVE variable in this source
		}
		$$stateRef &= ~0x80 if $stateRef;	# clear watchSet bit
	    }
	}
    }
    if ($msg) {
	print "sendWatchRestore index = $index set = $set msg = '$msg'\n" if $opt_T;
	sendMsg(12, 12, $msg);			# no need for 2 cases
    }
} # sendWatchRestore

########################################################################
#
#	Called by Button-1 Press or Key Press or Double-1 via pick_word.
#	In Live mode work on Watch or Ignore Points
#	In Edit mode highlight matching braces, parantheses and square brackets
#
#	If report_cursor is called via pick_word(2) by pressing Double-1 on
#	a brace, parenthesis or square bracket causes the insert cursor to
#	switch to the matching brace etc, which may involve moving the text.
#
#	In all other cases parameter 1 is undefined or "Tk..." from Button-1
#	Press and nothing is done except highlight the match.
#
#	Report the cursor position in the info bar
#
########################################################################

sub report_cursor {
    my ($p0) = $_[0];
no warnings;
    print "report_cursor: 1st parameter = '$p0'\n" if $opt_T;
use warnings;
    my $c1 = '';
    my $c2 = '';
    my $c3 = '';
    my $dir = '';
    my $reg = '';
    my $stop = '';
    my $length = 0;
    my $n = 0;
    my $cursor = $text->index('insert');		# '27.0'
    $cursor =~ m/(\d+)\.(\d+)/;
    my $y = $1;
    my $x = $2 + 1;
    my $current = '';
    if (not $scanFlag) {
	########################################################################
	#  In Edit mode show matching braces, parentheses and square brackets
	#  not in "strings" or 'character constants'
	########################################################################
	$text->tagDelete('pTag');
	if ($x > 0) {
	    my $c = $text->get($cursor);
	    if ($c =~ /[{}()\[\]]/) {
		$text->tagConfigure('pTag',
				    -background => 'lightblue',
				    -foreground => 'black',
				   );
		$c1 = $c;
		($c2, $dir, $reg, $stop) = @{ $pGroup{$c1} };
		$current = $cursor;
		$text->tagAdd('pTag', $current);
		while (1) {
		    $current = $text->index("$current + 1 chars") if $dir eq "-forwards";
		    $current = $text->search(-count => \$length,
					     -regexp,
					     $dir,	# -backwards or -forwards
					     '--',
					     $reg,	# search regular expression
					     $current,	# start index
					     $stop,	# stop index
					    );
		    last unless $current;
		    $c3 = $text->get($current);
		    print("$cursor '$c1 $c2' $dir $reg $stop n = $n '$current' $c3 $length\n") if $opt_T;
		    if ($c3 eq $c1) {
			$n++ if $n < 0x7f;	# nesting depth limit 127
		    } elsif ($c3 eq $c2) {
			if ($n < 0x7f and $n-- <= 0) {
			    print "$cursor '$c1 $c2' $current match found\n" if $opt_T;
			    $p0 = 0 unless $p0;
			    if ($p0 == 2) {		# Double-1 via pick_word(2)
				$text->see($current);	# see matching brace, parenthesis or bracket
				$text->markSet('insert', $current);	# move insert cursor to match
				$current =~ m/(\d+)\.(\d+)/;
				$y = $1;
				$x = $2 + 1;
			    }
			    $text->tagAdd('pTag', $current);	# colour match
			    last;			# matching brace found
			}
		    } elsif ($c3 eq '"' or $c3 eq "'") {
			my $c4 = $text->get($text->index("$current - 1 chars"));
			my $c5 = $text->get($text->index("$current - 2 chars"));
			if ($c3 eq '"') {
			    $n ^= 0x80 unless ($n & 0x100) or ($c4 eq '\\' and $c5 ne '\\');	# must be greater than nesting depth limit
			} else {
			    $n ^= 0x100 unless ($n & 0x80) or ($c4 eq '\\' and $c5 ne '\\');	# "'"
			}
		    }
		}
	    }
	}		#    info_display(0, 'black', "$cursor '$c1 $c2' $dir $reg $stop n = $n '$current' $c3");
    } elsif ($debugFlag) {
	########################################################################
	#  In Debug mode if mouse is positioned over a word, which has an active tag,
	#  open a menu to enter/delete/enable/disable a Watch- or Ignore-Point.
	########################################################################
	my ($tag, $index);
	foreach ($text->tagNames($cursor)) {
	    if ($_ =~ m/^(\d+)[~=]?$/) {
		$tag = $_;
		$index = $1;
		last;
	    }
	}
	if ($index and
	    $symbolNames[$index] ne 'iClock') {	# cannot apply Watch point to iClock
	    $watchIndex = $index;
	    if (exists $watchPoints{$instName}{$watchIndex}) {
		($watchState, $watchValue) = @{ $watchPoints{$instName}{$watchIndex} };
	    } else {
		($watchState, $watchValue) = (0, 0);
	    }
	    $watchV     = ($watchState & 0x10) ? 1 : 0;
	    $watchCondV = ($watchState & 0x0f) ? 1 : 0;
	    $ignoreV    = ($watchState & 0x20) ? 1 : 0;
	    $disableV   = ($watchState & 0x40) ? 1 : 0;
	    my ($x, $y) = $mainWindow->pointerxy;
	    $afterId = $text->after(350, sub {
		$watchMenu->post($x, $y);	# correct button states are shown
	    });
	}
    }
    info_display(0, 'black', "line $y, char $x");	# 'line 27 char 1'
} # report_cursor

########################################################################
#
#	Enter/Delete/Edit a WatchPoint or
#	Enter/Delete an IgnorePoint
#	Disable/Enable a WatchPoint or an IgnorePoint
#
#	One of $watchV, $watchCondV, $ignoreV and $disableV has been
#	modified by a menu button, although this is ignored and the button
#	parameter is used to manipulate state. Next time the Watch menu is
#	posted, the button states are evaluated from the current $watchState.
#
#	Word conditions can be applied to all gates whose ftype is ARITH, D_SH,
#	F_SW, TRAB, CH_AR, OUTW as well as TIMRL, whose value is timer count.
#	No condition can be applied for ftype CLCKL gates - ftype UDFA or F_ERR
#	gates can never be active in a running iC program.
#	Bit conditions can be applied for all remaining ftype gates.
#
#	Because the watched gate is derived from the index of an active tag,
#	ALIAS names and immC array references are never entered - always the
#	undelying symbol, which will be shown in the Search Entry window,
#	when a WatchPoint strikes.
#
########################################################################

sub EnterWatch {
    if ($scanFlag and $debugFlag) {
	my $state = $watchState;		# keep previous $watchState
	my $value = $watchValue;		# keep previous $watchValue
	my ($dummy, $button) = @_;
	my $symbol = $symbolNames[$watchIndex];
	my ($ix, $i) = (0, 0);
	foreach (sort { $a <=> $b } keys %{ $watchPoints{$instName} }) {
	    if ($watchIndex <= $_) {		# insert Watch points in ascending index order
		$ix = $_;
		last;
	    }
	    $i++;
	}
	########################################################################
	#  'Watch' button
	########################################################################
	if ($button == 1) {
	    unless (($state & 0x30) == 0x30 and $state & 0x0f) {
		$state ^= 0x10;			# enter/delete 'Watch'
	    }
	    $state &= ~0x0f unless $state & 0x10; # delete Watch condition when Watch turns off
	    $state &= ~0x20;			# turn off possible 'Ignore'
	}
	########################################################################
	#  'Condition' button
	########################################################################
	elsif ($button == 2) {
	    my $s;
	    ($s, $value) = ConditionEdit($i, $ix, $watchIndex, $symbol, $watchMenu, 'nw', 'nw');
	    return if $s < 0;
	    $state &= ~0x0f;			# clear previous condition
	    $state |= 0x10 | $s;		# turn on 'Watch' | selected condition
	    $state &= ~0x20;			# turn off possible 'Ignore'
	}
	########################################################################
	#  'Ignore' button
	########################################################################
	elsif ($button == 4) {
	    $state ^= 0x20;			# enter/delete 'Ignore'
	    $state &= ~0x10 unless $state & 0x0f; # take away Watch unless condition
	}
	########################################################################
	#  'Disable' button
	########################################################################
	elsif ($button == 6) {
	    $state ^= 0x40;			# disable/enable 'Watch' or 'Ignore'
	}
	########################################################################
	#  'Cancel' button
	########################################################################
	else {
	    return;
	}
	########################################################################
	#  Apply or remove Watch or Ignore points from running app
	########################################################################
	ApplyWatchPoint($i, $ix, $watchIndex, $symbol, $state, $value);
    }
} # EnterWatch

########################################################################
#
#	DialogBox containing a Listbox of current Watch points
#
#	Show the DialogBox containing a Listbox containing all current
#	Watch and Ignore points for the currently running proc and instance,
#	where they can be manipulated by the following buttons:
#	('Lookup','Watch','Condition','Ignore','Enable','Disable','Delete','Close');
#
########################################################################

sub ListWatchPoints {
    my ($i, $index, $symbol, $state, $value, $watchCond);
    my ($answer, @selected);
    my ($watchListText, $d, $e, $f, $ftype);
    my $watchListRef = \@{ $watchList{$instName} };
    while ($#$watchListRef >= 0) {
	########################################################################
	#  Delete all items from the Listbox
	#  Build new list from current proc and instance
	########################################################################
	$dbLb->delete(0, 'end');
	for ($i = 0; $i <= $#$watchListRef; $i++) {
	    ($index, $symbol, $state, $value, $watchCond) = @{ $watchList{$instName}[$i] };
	    $d = $state & 0x40 ? 'D' : ' ';				# 'D' Disabled
	    $e = $state & 0x20 ? 'I' : $state & 0x10 ? 'W' : '?';	# 'I' Ignore or 'W' Watch
	    $ftype = $symbolTable{$symbol}[0];
	    $f = ($ftype == 1  or	# ARITH
		  $ftype == 7  or	# D_SH
		  $ftype == 12 or	# CH_AR
		  $ftype == 13 or	# F_SW
		  $ftype == 18 or	# TRAB
		  $ftype == 19		# OUTW
		 )		? 'i' :
		 ($ftype == 21) ? 'c' :	# CLCKL
		 ($ftype == 22) ? 't' :	# TIMRL
		 ($ftype == 23) ? '?' :	# F_ERR
		 ($ftype == 0)  ? 'u' :	# UDFA
				  'b';	# GATE etc
	    $watchListText = sprintf("%-20s %s %s %s%s", $symbol, $d, $e, $f, $watchCond);
	    $dbLb->insert($i, $watchListText);	# insert into Watch point Listbox
	}
	########################################################################
	#  Show the newly built Listbox
	########################################################################
	$answer = $dbL->Show(			# Watch point list DialogBox
	    -popover    => $zoomOut,
	    -overanchor => 'sw',
	    -popanchor  => 'ne',
	    -takefocus  => 1);
	########################################################################
	#  Analyze answer in conjunction with Listbox selection
	########################################################################
	if (not $answer or			# (x)
	    $answer eq 'Close') {		# Close DialogBox
	    return;
	}
	@selected = $dbLb->curselection;	# selected Watch points
	push @selected, $dbLb->index('active') unless @selected;	# use underlined entry
	die "must have a selection or 'active' underline ???\n" unless @selected;
	print "ListWatchPoints: $answer '@selected'\n" if $opt_T;
	if ($answer eq 'Delete') {		# probably most frequent selection
	    foreach (sort {$b <=> $a} @selected) {
		DeleteWatchPoint($_);		# Delete selected Watchpoints in reverse order
	    }
	}
	elsif ($answer eq 'Lookup') {
	    $symbol = $watchList{$instName}[$selected[0]][1];	# first selection only
	    sendDebug(1, 'D') if $debugFlag;		# debug mode off
	    search_now(1, $symbol, 0);
	    return;				# Close DialogBox to allow search to continue, scroll, main exit
	} else {
	    foreach (@selected) {
		if (defined \@{ $watchList{$instName}[$_] }) {
		    my ($index, $symbol) = @{ $watchList{$instName}[$_] };
		    if (exists $watchPoints{$instName}{$index}) {
			($watchState, $watchValue) = @{ $watchPoints{$instName}{$index} };
		    } else {
			($watchState, $watchValue) = (0, 0); # should not happen for List entries
		    }
		    my $state = $watchState;	# keep previous $watchState
		    my $value = $watchValue;	# keep previous $watchValue
		    if ($answer eq 'Watch') {
			$state |= 0x10;		# add Watch
			$state &= ~0x20;		# take away Ignore
		    }
		    elsif ($answer eq 'Condition') {
			my $s;
			($s, $value) = ConditionEdit($_, $index, $index, $symbol, $dbLb, 'nw', 'nw');
			printf "answer '%s' X = %d state = 0x%02x\n", $answer, $value, $state if $opt_T;
			next if $s < 0;
			$state &= ~0x0f;		# clear previous condition
			$state |= 0x10 | $s;	# turn on 'Watch' | selected condition
			$state &= ~0x20;		# turn off possible 'Ignore'
		    }
		    elsif ($answer eq 'Ignore') {
			$state |= 0x20;		# add Ignore
			$state &= ~0x10 unless $state & 0x0f; # take away Watch unless condition
		    }
		    elsif ($answer eq 'Enable') {
			$state &= ~0x40;
		    }
		    elsif ($answer eq 'Disable') {
			$state |= 0x40;
		    } else {
			die "strange button '$answer' ???\n";
		    }
		    ########################################################################
		    #  Apply or remove Watch or Ignore points from running app
		    #  This may increase or decrease # of Listbox entries $#$watchListRef 
		    ########################################################################
		    ApplyWatchPoint($_, $index, $index, $symbol, $state, $value);
		}
	    }
	}
    }
} # ListWatchPoints

########################################################################
#
#	Condition Edit
#			my (    $i, $ix, $wix,        $symbol, $wm,        $oa,  $pa) = @_;
#  ($s, $value) = ConditionEdit($i, $ix, $watchIndex, $symbol, $watchMenu, 'nw', 'nw');	# from EnterWatch
#  ($s, $value) = ConditionEdit($_, $index, $index,   $symbol, $dbLb,      'nw', 'nw');	# from ListWatchPoints
#
########################################################################

sub ConditionEdit {
    my ($i, $ix, $wix, $symbol, $wm, $oa, $pa) = @_;
    my ($answer, $s, $ftype, $value);
    $ftype = $symbolTable{$symbol}[0];
    $watchListTxt= "$symbol:" . (($ix != $wix) ? '' :
		    $watchList{$instName}[$i][4]);	# stored $watchCond
    print "watchListTxt '$watchListTxt'\n" if $opt_T;
    $s = 0;
    if ($ftype == 0  or			# UDFA
	$ftype == 21 or			# CLCKL	returns 0 for unconditional Watch
	$ftype == 23			# F_ERR
    ) {
	info_display(0, 'red', "cannot have a Watch condition for '$symbol'");
    } elsif ($ftype == 1 or		# ARITH
	$ftype == 7  or			# D_SH
	$ftype == 12 or			# CH_AR
	$ftype == 13 or			# F_SW
	$ftype == 18 or			# TRAB
	$ftype == 19 or			# OUTW
	$ftype == 22			# TIMRL
    ) {
	$answer = $dbW->Show(		# Watch word condition DialogBox
	    -popover    => $wm,
	    -overanchor => $oa,
	    -popanchor  => $pa,
	    -takefocus  => 1);		# $dbWval returns X
	return (-1, 0) unless defined $answer;	# (x)
	foreach (@dbWbuttons) {
	    if ($answer eq $_) {
		last;
	    }
	    $s++;
	}
	return (-1, 0) if $s >= $#dbWbuttons;	# Cancel is last button
    } else {				# GATE ... OUTX
	$answer = $dbB->Show(		# Watch bit condition DialogBox
	    -popover    => $wm,
	    -overanchor => $oa,
	    -popanchor  => $pa,
	    -takefocus  => 1);
	return (-1, 0) unless defined $answer;	# (x)
	if ($answer eq $dbBbuttons[1]) {
	    $s = 1;			# == 1
	    $dbWval = 1;		# X = 1
	} elsif ($answer eq $dbBbuttons[2]) {
	    $s = 1;			# == 0 ($dbWval undef becomes 0)
	} elsif ($answer eq $dbBbuttons[3]) {
	    return (-1, 0);		# Cancel
	}
    }
    $value = convert_nr($dbWval);
    $dbWval = undef;			# clear LabEntry window
    return ($s, $value);
} # ConditionEdit

########################################################################
#
#	Lower Main Window with respect to a descendant window
#	which keeps descendant in view although it looses focus
#
########################################################################

sub lowerMain {
    my ($win) = @_;
    if ($win->ismapped) {
	print "lowerMain from $win\n" if $opt_t;
	$mainWindow->lower($win);
    }
} #lowerMain

########################################################################
#
#	Apply or remove Watch or Ignore points from running app
#	%watchPoints {$instName} {$index} [ 0 state 1 value ]
#	%watchList {$instName} [$i] [ $index, $symbol, $state, $value, $watchCond ]
#	holds information in parallel with Listbox $dbLb using the same index.
#  @dbWbuttons = ('change','== X','!= X','< X','<= X','>  X','>=X','% X','!% X','& X','!& X','Cancel');
#
########################################################################

sub ApplyWatchPoint {
    my ($i, $ix, $wix, $symbol, $state, $value) = @_;
    if ($state != $watchState or $value != $watchValue) {
	if ($state & 0x30) {		# 'Watch' or 'Ignore'
	    my ($c, $d, $e, $v, $watchCond);
	    printf("enter %s	X = %d state = 0x%02x wix = %d\n", $symbol, $value, $state, $wix) if $opt_T;
	    $watchPoints{$instName}{$wix} = [ $state, $value ];	# add or change Watch point
	    if (($c = $state & 0x0f) != 0) {			# Watch condition code
		$v = ($c >= 9) ? sprintf("0x%04x", $value)	# '&' '!&'
			       : $value;
		$c = $dbWbuttons[$c];	# Watch condition button text eg '== X'
		$c =~ s/X/$v/;		# replace X from button text by entered decimal or hex value
		if ($c =~ s/!([%&])/$1/) {
		    $d = '!(';		# bring complement operator ! forward
		    $e = ')';
		} else {
		    $d = '  ';
		    $e = '';
		}
		$watchCond = sprintf(" %s%s %s%s",
		    $d, ($state & 0x20) ? '...' : $symbol,		# Ignore has no condition
		    $c, $e);
		if ($value == 0 and $c =~ m/^%/) {			# '%' '!%'
		    info_display(0, 'red', "cannot allow modulo division by 0 for '$watchCond'");
		    $watchPoints{$instName}{$wix} = [ $watchState, $watchValue ];	# do not change Watch point
		    return;
		}
	    } else {
		$watchCond = '';
	    }
	    if ($ix == $wix) {
		splice @{ $watchList{$instName} }, $i, 1, [ $wix, $symbol, $state, $value, $watchCond ];
	    } else {
		splice @{ $watchList{$instName} }, $i, 0, [ $wix, $symbol, $state, $value, $watchCond ];
	    }
	    if ($state & 0x40) {
		sendWatchRestore($wix, 0);			# Disable was set
	    } elsif (($state & 0xf0) != ($watchState &0xf0)) {	# ignore 'Condition' changes
		sendWatchRestore($wix, 1);			# new or changed Watch/Ignore
	    }
	    markWatch($state, $wix);
	} else {
	    printf("delete %s	X = %d state = 0x%02x wix = %d\n", $symbol, $watchValue, $watchState, $wix) if $opt_T;
	    die "Deleting Watchpoint $ix != $wix ???\n" unless $ix == $wix;	# test for safety only
	    DeleteWatchPoint($i);
	}
    }
} # ApplyWatchPoint

########################################################################
#
#	Delete a Watchpoint
#
########################################################################

sub DeleteWatchPoint {
    my $i = $_[0];
    my ($index, $symbol, $state, $value) = @{ $watchList{$instName}[$i] };
    print "Delete Watch point $i $symbol $index $value\n" if $opt_T;
    splice @{ $watchList{$instName} }, $i, 1;
    sendWatchRestore($index, 0) unless $state & 0x40;	# unless disabled
    delete $watchPoints{$instName}{$index};
    markWatch(0, $index);
} # DeleteWatchPoint

########################################################################
#
#	Convert a number string obtained with $val to an integer value
#	Parameter 1:	dec, bin, oct or hex number string - dec may be signed
#	retun numerical value or 0 if parameter 1 undef or '' or 0
#
########################################################################

sub convert_nr {
    my ($val) = @_;
    return 0 unless $val;
    $val = oct($val) if $val =~ /^0/;	# handles 017 0xf 0b1111
    return int $val;			# initialize to an integer for correct AND/OR
} # convert_nr

########################################################################
#
#	Mark Watch or Ignore for normal and inverted Tags
#
########################################################################

sub markWatch {
    my ($state, $index) = @_;
    my ($tag);
    if ($text->tagRanges($index)) {
	markWatchTag($state, $index);
    }
    if ($text->tagRanges($tag = "$index~")) {
	markWatchTag($state, $tag);
    }
} # markWatch

########################################################################
#
#	Mark Watch or Ignore for one Tag
#
########################################################################

sub markWatchTag {
    my ($state, $tag) = @_;
    if ($state & 0x20) {					# Ignore
	$text->tagConfigure($tag, -underline => 0);		# do first because may have watch edit
	$text->tagConfigure($tag, -overstrike => 1);
    } elsif ($state & 0x10) {					# Watch
	$text->tagConfigure($tag, -underline => 1);
	$text->tagConfigure($tag, -overstrike => 0);
    } else {							# Neither
	$text->tagConfigure($tag, -underline => 0);
	$text->tagConfigure($tag, -overstrike => 0);
    }
    if ($state & 0x40) {
	$text->tagConfigure($tag, -fgstipple => 'gray25');	# dotted
    } elsif ($state & 0x0f) {
	$text->tagConfigure($tag, -fgstipple => 'gray75');	# wiggly
    } else {
	$text->tagConfigure($tag, -fgstipple => '');		# full
    }
} # markWatchTag

########################################################################
#
#	Set Shift/Control Key state only in Live mode
#	none			0	balloon shows value of variable
#	Shift_L			1	balloon shows index in S.T. (useful in checking for ALIASES)
#	Control_L		2	balloon shows ftype as mnemonic
#	Shift_L+Control_L	3	balloon shows ftype as number
#	NOTE: iClive window must have focus for KeyPress and KeyRelease to be recognised
#
########################################################################

sub set_shift_control {
    if ($scanFlag) {
	my $k;				# Live mode
	if (($k = $Tk::event->K) eq "Shift_L" or $k eq "Shift_R") {
	    $shift_control_state |= 01;
	} elsif ($k eq "Control_L" or $k eq "Control_R") {
	    $shift_control_state |= 02;
	} else {
	    $shift_control_state = 0;
	}	# my $n = $Tk::event->N; info_display(0, 'black', "Press   KeySym=$k, numeric=$n");
    } else {
	report_cursor();		# only in Edit mode
    }
} # set_shift_control

########################################################################
#
#	Reset Shift/Control Key state only in Live mode
#
########################################################################

sub reset_shift_control {
    if ($scanFlag) {
	my $k;				# Live mode
	if (($k = $Tk::event->K) eq "Shift_L" or $k eq "Shift_R") {
	    $shift_control_state &= ~01;
	} elsif ($k eq "Control_L" or $k eq "Control_R") {
	    $shift_control_state &= ~02;
	} else {
	    $shift_control_state = 0;
	}	# my $n = $Tk::event->N; info_display(0, 'red', "Release KeySym=$k, numeric=$n");
    }
} # reset_shift_control

########################################################################
#
#	Adjust live display to only the text in the view window.
#
#	This speeds up live display enourmously - especially on very
#	large listing texts eg. 10,000 lines, where 15 seconds were needed
#	to build the live display and live updates were then still sluggish
#	approx. 0.5 seconds near the end of the text. Worse still my 2.5 GHz
#	processor was stretched to the limit to keep the live display up to
#	date, although 99% or more of the changes did not affect the current
#	text visible in the text window. With the change live displays come
#	up in a fraction of a second no matter how large the text is. All
#	one can see when scrolling the text window is a blink in '1' variables.
#	Measured 2 ms for a typical 26 line window. CPU loading between 0 and
#	10% for an application displaying 4 shift registers changing every
#	50 ms. Associated network traffic 25K.
#
#	Since this activation may come from several binds resulting in the
#	same $start and $last lines, do_scan only once when line numbers
#	change.
#
#	$prevStart and $prevLast must be cleared when changing file or instance
#	in case the text in the window is similar.
#
#	The computation of $start and $last from $end has always yielded
#	integer values with the fractions returned by $text->yview().
#	If this were not the case, function int($start+0.5) could be used.
#	Perl seems to do this internally on the 16th precision digit ???
#	Tested empircally JW 20050404
#	Failed for very large files, so modified using int	JW 20101016
#
#	parameter 1:	$_[0], has HASH ref when callback from bind (ignore)
#	parameter 2:	$_[1], do_scan unconditionally if true
#
########################################################################

sub adjust_live {
    if ($scanFlag) {
	$shift_control_state = 0;
	my @position = $text->yview();
	my $end = $text->index('end');	# re-compute in case text has changed
	$end =~ s/(\d+).*/$1/;
	my $e = $end -1;
	my $start = int $e * $position[0] + 1.5;	# 1 line early for wrapped lines
	my $last = int $e * $position[1] + 2.5;
	my $l = $last - 2;
	$last = $end if $last > $end;
no warnings;
	print "start = $start prevStart = $prevStart last = $last prevLast = $prevLast _[1] = '$_[1]'\n" if $opt_T;
use warnings;
	if ($start != $prevStart or $last != $prevLast or $_[1]) {
	    if (@activeSymbols) {
		deleteAllTags();	# delete tags and all previous active symbols
		clear_scan();		# clear active symbols in connected iC controller process
	    }
	    do_scan("$start.0", "$last.0");
	    markBreak() if $breakIndex;
	    $prevStart = $start;
	    $prevLast  = $last;
	    printMicroSeconds("adjust live");
no warnings;
	    print "do_scan complete, $start, $last, '$_[1]'\n" if $opt_t and not $opt_q;
use warnings;
	}
	info_display(0, 'dark green', "line $start to line $l") if $searchText eq '';
    }
} # adjust_live

########################################################################
#
#	Send message to $conn now
#
########################################################################

sub conn_send_now {
    my ($msg) = @_;
    eval {
	$conn->send_now($msg);
    }; warn "eval: $@" if $@;
}  # conn_send_now

########################################################################
#
#	Connect to iCserver
#	connection is maintained until iClive shuts down or iCserver disconnects
#
#	Inhibit Nagle's algorithm
#
########################################################################

sub connect_to_server {
    my $i = 0;
    my @s;
    if ($server >= 0) {
	iCmsg->inhibit_nagle(1,		# inhibit Nagle's algorithm for real time response
	    defined $opt_d && ($opt_d & 2),	# trace recv messages
	    defined $opt_d && ($opt_d & 1));	# trace send messages
	while (1) {
	    $conn = iCmsg->connect($host, $port, \&rcvd_msg_from_server, 1); # return imme if connect fails
	    if ($conn) {
		print STDERR "$named connected to server at '$host:$port'\n" unless $opt_q;
		$mainWindow->fileevent($conn->{sock}, 'readable', sub { iCmsg->event_loop(1); });
		info_display(2000, 'blue', "Connection to '$host:$port'");
		last;
	    }
	    if ($server == 0) {
		@s = split(" ", $opt_S);
		print "\@s = '@s'\n" if $opt_T;
		splice(@s, 1, 0, "-z$opt_q", "-k", "-A", "$opt_A");	# block STDIN for chained iCserver
		splice(@s, 1, 0, "-p", "$port") unless $port eq "8778";
		print "\@s = '@s'\n" if $opt_T;
		if ($host eq "localhost" or $host eq "127.0.0.1") {
		    fork_and_exec(@s);	# start iCserver
		    $server = 1;		# remember that this iClive started iCserver
		} else {
		    warn "$named: '@s' cannot be started here - start it on '$host' (ctrl-C to stop)\n";
		    $server = 2;		# waiting for start of iCserver on a remote host
		}
	    } elsif ($server > 0) {
		if ($server == 2 or $i++ < 4) {
		    print "$named: $i: wait 2 seconds for iCserver to start\n" if $opt_T;
		    select undef, undef, undef, 2;
		} else {
		    warn "$named: waited 8 seconds for '@s' to start - give up\n";
		    $server = -1;	# something wrong with iCserver
		    exit 3;
		}
	    }				# try to connect immediately
	}
    }
} # connect_to_server

########################################################################
#
#	Register at iCserver
#
#	unless previously registered
#	register iClive instance "-$regName" at iCserver now
#
########################################################################

sub register_at_server {
    my $i = 0;
    if (not $conn) {
	connect_to_server();
    }
    if ($conn) {
	if ($instName ne $regName) {
	    unregister_from_server();
	    $regName = $instName;
	    my $ret = '';
	    my $Registrations = "N-$regName,RC$regName,SD$regName";
	    $Registrations .= ",S$debugStop" if $debugStop;	# optional Debug Stop signal
	    $Registrations .= ",Z";	# register but may not connect to application
	    print "$named: Registrations: $Registrations\n" if $opt_T;
	    conn_send_now($Registrations);
	    info_display(2000, 'blue', "Register as '-$regName'");
	    my ($tmsg, $terr) = $conn->rcv_now();
no warnings;
	    print "$named: Reply: '$tmsg' err = '$terr'\n" if $opt_T;
	    $i = 1;
	  REPEAT:
	    if ($tmsg !~ /^(\d+),(\d+)(,(\d+))?$/) {	# analyse registration reply from iCserver now
		rcvd_msg_from_server($conn, $tmsg, $terr);	# not a registration reply - delayed data
		unless ($conn) {
		    print "$named: failed to register on attempt $i\n" if $opt_T;
		    goto FAILED_TO_REGISTER;	# stop trying if registered twice
		}
		($tmsg, $terr) = $conn->rcv_now();
		print "$named: Reply: '$tmsg' err = '$terr' ($i)\n" if $opt_T;
		die "registration failed\n" if $i++ >= 100;	# ridiculous number of delayed data messages
		goto REPEAT;	# cannot use while, because $1 $2 not in scope - if OK
	    }
use warnings;
	    $C_channel = $1;	# receiver channel from control program
	    $D_channel = $2;	# sender channel to control program
	    $B_channel = $4 if $3;	# sender channel for optional Debug Stop signal
	    print "$named: registered: C_channel = $C_channel D_channel = $D_channel B_channel = $B_channel\n" if $opt_T;
	    conn_send_now("$D_channel:2");			# poll application to see if it is live
	}
    } else {
	  FAILED_TO_REGISTER: info_display(2000, 'red',
	    "Could not connect to '$host:$port' - no live listing - edit only");
    }
} # register_at_server

########################################################################
#
#	Unregister current session from iCserver
#
########################################################################

sub unregister_from_server {
    if ($regName ne '') {
	print "$named: unregister '$regName' '$D_channel:0'.\n" if $opt_T;
	conn_send_now("$D_channel:0");
	my $UnRegistrations = "n-$regName,rC$regName,sD$regName";
	$UnRegistrations .= ",s$debugStop" if $debugStop;	# optional Debug Stop signal
	$regName = '';
	print "$named: UnRegistrations: $UnRegistrations\n" if $opt_T;
	$mainWindow->title("$named$u: $fileName$readOnly");
	conn_send_now($UnRegistrations);
    }
    clear_all();
} # unregister_from_server

########################################################################
#
#	Receive message from server - adjust outputs
#	(these will only occur if $conn and read events registered)
#
########################################################################

sub rcvd_msg_from_server {
    my ($rConn, $msg, $err) = @_;
    die "named: rcvd on a strange connection '$rConn', should be '$conn'\n$msg\n" if $rConn ne $conn;
    if (defined $msg) {
	my $len = length $msg;
	print "($len)$msg< iCserver\n" if $opt_T;
	if ($len == 0) {
	    print "$named: rcvd zero length message - disconnect\n" if $opt_T;
	    sendDebug(0, 'D');			# debug mode off
	    info_display(2000, 'red', "$named: disconnected by iCserver");
	    unregister_from_server();
	    $scanFlag = 0;
	    $liveButton->configure(-text => 'Live');
	    $prevText = '';			# start a new search
	    $gl = 0;
	    tagDeleteRestore_searchTag();
	    $traceDebV = $microSecV = 0;		# stop Trace and MicroSec output in Edit mode
	    conn_send_now("$D_channel:83,$D_channel:77");	# 'S' 'M' to stop Trace and MicroSec in app
	    $debugMenu->entryconfigure(0, -state => 'disabled');	# Debug
	    $debugMenu->entryconfigure(6, -state => 'disabled');	# Watch points
	    $runName = '';
	    $menuRun->configure(-text => 'Run ');
	    $menuBuild->entryconfigure(5, -state => 'disabled');	# Symbol Table by name
	    $menuBuild->entryconfigure(6, -state => 'disabled');	# Symbol Table by index
	    $menuBuild->entryconfigure(7, -state => 'disabled');	# iCserver Client Tables
	    print "$named: rcvd_msg_from_server(0) buttons to 'Run ' 'Live'\n" if $opt_T;
	    $mainWindow->title("$named$u: $fileName$readOnly");
	    $makeName = '';
	    $conn->disconnect;			# should only happen when iCserver shuts down
	    $conn = 0;
	    $server = 0;
	    info_display(2000, 'red', "iCserver has disconnected $named from '$host:$port'");
	    info_display(2000, 'red', "");	# quit_program() with zero length message
	} else {
	    my ($msg1);
	    printMicroSeconds("received message from server");
	    print "rcvd '$msg'\n" if $opt_t and not $opt_q;
	    foreach $msg1 (split /,/, $msg) {	# break up comma separated multiple messages
		my @symbols = split /;/, $msg1;	# break up message
		my $entry = shift @symbols;		# first entry is an operation
		if ($entry =~ /$C_channel\:(\d+)/) {
		    if (($entry = $1) eq '1') {
			print "received '$C_channel:1'\n" if $opt_T;
			####################################################
			## Symbol Table block
			## Received Symbol table entries consist of two or three words.
			## Usually symbol-id and ftype are received. In this
			## case the ST-offset is the index. (computed by counting)
			## For ALIASes the index of the Gate to which the ALIAS
			## resolves is transmitted as a 3rd value.
			## The actual index of an ALIAS in the ST is never used.
			## The same applies to immC array members.
			## For bit I/O names IX0.0 etc, add a second entry IX0_0
			## For number constants 0 1 etc, add a second entry _0 _1
			## For negative constants -1 etc, add a second entry __1
			####################################################
			while ($entry = shift @symbols) {
			    my ($symbol, $ftype, $index) = split " ", $entry;
			    my ($l);
			    $symbolNames[$stIndex] = $symbol;			# original symbol-id
			    if (not defined $index) {
				$index = $stIndex;
			    }							# else ALIAS or array reference
			    print "$index\t$symbol\t$ftype\n" if $opt_T;
			    @{ $symbolTable{$symbol} } = ($ftype, $index);
			    if ($symbol =~ s/^([IQT]X\d+)\.(\d+(_\d+)?)$/$1_$2/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^-(\d+)$/__$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    elsif ($symbol =~ s/^(\d+)$/_$1/) {
				print "$index\t$symbol\t$ftype\n" if $opt_T;
				@{ $symbolTable{$symbol} } = ($ftype, $index);
			    }
			    if (($l = length $symbol) > $maxSymbolLength) {
				$maxSymbolLength = $l;
			    }
			    $stIndex++ unless ($symbol =~ /\[\s*\d+\s*\]/);	# array references are not in ST
			}
		    }
		    elsif ($entry eq '2') {
			if ($runName eq '') {	# block 2nd receive of ch:2;<name>
			    print "received '$C_channel:2'\n" if $opt_T;
			    ####################################################
			    ## Application is running
			    ## The 2nd entry is the name of the running iC program.
			    ## This name allows a check against the file name of
			    ## the displayed text. (Assume it should match)
			    ## change text on run button to 'Stop'
			    ####################################################
			    $runName = shift @symbols;
			    $runName = $pathName . $runName;
			    $runNames{$runName} = 1;				# record as running iC program
			    $mainWindow->title("$named$u: $fileName$readOnly $runName");
			    info_display(2000, 'blue', "'$runName' is running");
			    $menuRun->configure(-text => 'Stop');
			    $menuBuild->entryconfigure(7, -state => 'normal');	# iCserver Client Tables
			    print "$named: rcvd_msg_from_server received :2 'Stop' scanFlag = '$scanFlag'\n" if $opt_T;
			    $traceDebV = $microSecV = 0;			# stop Trace and MicroSec output
			    $debugMenu->entryconfigure(8, -state => 'normal');	# Trace
			    $debugMenu->entryconfigure(9, -state => 'normal');	# MicroSec
			    conn_send_now("$D_channel:83,$D_channel:77");	# 'S' 'M' to stop Trace and MicroSec in app
			    if ($scanFlag) {
				%symbolTable = ();
				print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
				conn_send_now("$D_channel:1");	# request Symbol Table
			    }
			}
		    }
		    elsif ($entry eq '3') {
			print "received '$C_channel:3'\n" if $opt_T;
no warnings;
			####################################################
			## New data values
			## Data value entries consist of ST-index and value
			####################################################
			my $normalFlag = 0;			# state currently diasabled
			my ($index, $value, $tRest, $cs, $tNew, $tOld);
			while ($entry = shift @symbols) {
			    ($index, $value) = split " ", $entry;
			    ($cs, $tOld) = @{ $activeSymbols[$index] }[2, 3];
			    unless (${$tOld}[0] and ${$tOld}[1]) {
				$tOld = [gettimeofday()];	# found uninitialised values
				if ($opt_T) {
				    my ($symbol, $ft, $ix);
				    $symbol = $symbolNames[$index];
				    if ($symbolTable{$symbol}) {
					($ft, $ix) = @{ $symbolTable{$symbol} };
					print "$symbol	($ix) ftype: $ft value: $value cs: '$cs' ### uninitialised time\n";
				    }
				}
			    }
			    $activeSymbols[$index][3] = $tNew = [gettimeofday()];
			    $tRest = 50 - int(tv_interval($tOld, $tNew) * 1000);	# ms.
			    print "index: $index value: $value rest: $tRest\n" if $opt_T;
			    $cs ^= 1 if $value;			# change colour
			    $activeSymbols[$index][1] = $value;	# for value display
			    if ($activeSymbols[$index][0] & 01) {
				if ($tRest < 10) {
				    colourTag("$index", $cs);	# normal colour
				} else {
				    colourTag("$index", $cs | 010);	# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index" ]);
				}
				if ($cs == 5) {			# hi CLOCK
				    ## turn colour off after 50 ms.
				    $text->after(50, [ \&colourTag, "$index", $cs & ~01 ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 02) {
				$cs ^= 1;				# complement colour
				if ($tRest < 10) {
				    colourTag("$index~", $cs);	# latest $cs is saved
				} else {
				    colourTag("$index~", $cs | 010);# flash glitch
				    ## delay the colour change to make it visible
				    $text->after(50, [ \&restoreTag, "$index~" ]);
				}
			    }
			    if ($activeSymbols[$index][0] & 04) {
				my $tag = "$index=";
				my @ranges = $text->tagRanges($tag);
				print "value at index $index: $activeSymbols[$index][1] '@ranges'\n" if $opt_T;
				unless ($normalFlag) {
				    $text->configure(-state => 'normal');
				    $normalFlag = 1;	# state normal until loop end
				}
				for (my $i = 0; $i < @ranges; $i += 2) {
				    my ($beg, $end) = @ranges[$i, $i+1];
				    $text->delete($beg, $end);
				    $text->insert($beg, " $value", $tag);
				}
			    }
			    printMicroSeconds("symbol table entry");
			    print "$index	$value\n" if $opt_t and not $opt_q;
			}
			$lastIndex = $index;		# index of last symbol to be updated
			$lastValue = $value;		# value of last symbol to be updated
			if ($normalFlag) {
			    $text->configure(-state => 'disabled');
			}
use warnings;
		    }
		    elsif ($entry eq '4') {
			####################################################
			## End of Symbol Table
			####################################################
			my ($index, $name, $realIndex);
			if (defined $opt_d && ($opt_d & 040)) {
			    print "$named$u: '$runName' Symbol Table received\n";
			    print "index\tname\talias index\n";
			    print "-----\t----\t-----------\n";
			    for ($index = 1; $index < $stIndex; $index++) {
				$name = $symbolNames[$index];
				$realIndex = $symbolTable{$name}[1];
				if ($realIndex == $index) {
				    print "$index\t$name\n";
				} else {
				    print "$index\t$name\t$realIndex\n";
				}
			    }
			}
			info_display(2000, 'blue', "'$runName' Symbol Table received");
			$stIndex = 1;			# ready for next reception
			printMicroSeconds("symbol table end");
			print "received '$C_channel:4'\n" if $opt_T;
			$scanFlag = 1;
			print "receive Symbol Table: sendStepNext\n" if $opt_T;
			sendStepNext();			# adjust set and next bits in client
			adjust_live(-1, -1);
		    }
		    elsif ($entry eq '5') {
			####################################################
			## Application has stopped altogether - received $C_channel:5
			####################################################
			print "received '$C_channel:5'\n" if $opt_T;
			info_display(2000, 'blue', $runName ne '' ?
			    "'$runName' was stopped" :
			    "application was stopped - not registered !?");
			clear_all();
			$runNames{$runName} = undef;				# remove as running iC program
			$runName = '';
			$mainWindow->title("$named$u: $fileName$readOnly");
			$makeName = '';
			if ($restartFlag) {
			    $restartFlag = 0;
			    run_file();	# restart after scan detects out of date build
			} else {
			    ####################################################
			    ## change text on run button to 'Run '
			    ####################################################
			    $menuRun->configure(-text => 'Run ');
			    $menuBuild->entryconfigure(5, -state => 'disabled');	# Symbol Table by name
			    $menuBuild->entryconfigure(6, -state => 'disabled');	# Symbol Table by index
			    $menuBuild->entryconfigure(7, -state => 'disabled');	# iCserver Client Tables
			    print "$named: rcvd_msg_from_server received :5 'Run '\n" if $opt_T;
			}
			if ($scanFlag) {
			    $liveButton->configure(-text => 'wait');
			    $prevText = '';					# start a new search
			    $gl = 0;
			    tagDeleteRestore_searchTag();
			    $debugMenu->entryconfigure(0, -state => 'disabled');	# Debug
			    $debugMenu->entryconfigure(6, -state => 'disabled');	# Watch points
			    print "$named: rcvd_msg_from_server received :5 'wait'\n" if $opt_T;
			}
		    }
		    elsif ($entry eq '6') {
			####################################################
			## Block 't' and 'm' in Debug menu for production code - received $C_channel:6
			####################################################
			print "received '$C_channel:6'\n" if $opt_T;
			$debugMenu->entryconfigure(8, -state => 'disabled');	# Trace
			$debugMenu->entryconfigure(9, -state => 'disabled');	# MicroSec
		    }
		    elsif ($entry eq '9') {
			####################################################
			## Conditional watch point - received $C_channel:9
			####################################################
			my ($state, $value, $condition);
			print "$named: watch lastIndex = $lastIndex lastValue = $lastValue '$watchPoints{$instName}{$lastIndex}'\n" if $opt_T;
			if (exists $watchPoints{$instName}{$lastIndex}) {
			    ($state, $value) = @{ $watchPoints{$instName}{$lastIndex} };
			    if ($state & 0x10) {	# conditions must line up with @dbWbuttons
				if (($condition = $state & 0x0f) == 0 or	# unconditional break
				    ($condition ==  1 and   $lastValue == $value)  or
				    ($condition ==  2 and   $lastValue != $value)  or
				    ($condition ==  3 and   $lastValue <  $value)  or
				    ($condition ==  4 and   $lastValue <= $value)  or
				    ($condition ==  5 and   $lastValue >  $value)  or
				    ($condition ==  6 and   $lastValue >= $value)  or
				    ($condition ==  7 and   $lastValue %  $value)  or
				    ($condition ==  8 and !($lastValue %  $value)) or
				    ($condition ==  9 and   $lastValue &  $value)  or
				    ($condition == 10 and !($lastValue &  $value))
				) {
				    goto BreakNow;
				}
			    } else {
				goto BreakError;
			    }
			} elsif (defined $lastIndex) {
			  BreakError:
			    warn "Watch point '$symbolNames[$lastIndex]' has incorrect or no entry\n";
			}
			conn_send_now("$D_channel:99");	# continue (ord('c') is 99)
		    }
		    elsif ($entry eq '8') {
			####################################################
			## Unconditional watch point - received $C_channel:8
			####################################################
		      BreakNow:
			####################################################
			## Application has stopped at a BREAK - received $C_channel:8
			####################################################
			if ($scanFlag) {
			    $entrySearch->configure(-background => 'pink');
			    $gl = 0;
			    tagDeleteRestore_searchTag();	# no searchTag showing at BREAK
			    $stepV = $nextV = $continueV = 0;	# turn buttons off
			    $breakText = $searchText = "$symbolNames[$lastIndex] = $lastValue";
			    $break = 1;				# start a new search
			    print "received '$C_channel:$entry' '$searchText'\n" if $opt_T;
			    while ($lastIndex) {
				# unless already showing move text to show watch word in window
				unless ($activeSymbols[$lastIndex] and $activeSymbols[$lastIndex][0]) {
				    $gl = 0;
				    search_now(1, undef, 0);	# search for watch word
				}				# search puts $lastIndex to @activeSymbols
				if ($activeSymbols[$lastIndex] and $activeSymbols[$lastIndex][0]) {
				    $breakIndex = $lastIndex;
				    if ($B_channel) {
					$B_timer->cancel() if defined $B_timer;
					unless ($B_stopped) {
					    $B_stopped = 1;
					    conn_send_now("$B_channel:$B_stop");	# program stopped - stop movements
					}
				    }
				    markBreak();
				} elsif ($searchText =~ s/^(Q[XBWLH]\d+(\.[0-7])?)_0\b/$1/) {
				    $lastIndex = $symbolTable{$1}[1];	# output driver GATE
				    next;			# repeat while loop a 2nd time
				}
				last;				# do while loop only once
			    }
			    $yScrollbar->focus();		# enable keyboard stepping
			    info_display(2000, 'DeepPink4', "Watch Point: $breakText");
			}	# should never get BREAK message in Edit mode - ignore
		    }
		    elsif ($entry ne '0') {	# ignore '$C_channel:0' messages
			print "received '$C_channel:$entry'\n" if $opt_T;
			goto Spurious;
		    }
		}
		elsif ($entry =~ /0:(\d+)/) {	# channel 0 message
		    if (($entry = $1) eq '1') {
			####################################################
			## Warning from iCserver. $msg is '0:1;<warning message>'
			####################################################
			$msg =~ /^0:1;(.*)/;
			print "$named: Warning: $1\n" if $opt_T;
			info_display(2000, 'red', $1);
			last;	# used whole of $msg - ignore splits on ',' and ';'
		    }
		    elsif ($entry ne '0') {	# ignore '0:0' messages
			goto Spurious;
		    }
		}
		else {
		    Spurious: warn "$named: spurious operation '$entry' ???\n";
		}
		printMicroSeconds("stored one message");
	    }
	    print "rcvd end\n" if $opt_t and not $opt_q;
	}
    } else {
	print "undefined message< iCserver\n" if $opt_T;
    }
} # rcvd_msg_from_server

########################################################################
#
#	Mark BREAK variable through its tag with a raised relief and bold text
#
########################################################################

sub markBreak {
    my ($tag);
    if ($text->tagRanges($breakIndex)) {
	$text->tagConfigure($breakIndex, -relief => 'raised', -borderwidth => 3, -font => $boldfont);
    }
    if ($text->tagRanges($tag = "$breakIndex~")) {
	$text->tagConfigure($tag, -relief => 'raised', -borderwidth => 3, -font => $boldfont);
    }
} # markBreak

########################################################################
#
#	Clear BREAK variable through its tag without relief and normal text
#
########################################################################

sub clearBreak {
    my ($tag);
    if ($breakIndex) {
	if ($text->tagRanges($breakIndex)) {
	    $text->tagConfigure($breakIndex, -relief => 'flat', -borderwidth => 0, -font => $font);
	}
	if ($text->tagRanges($tag = "$breakIndex~")) {
	    $text->tagConfigure($tag, -relief => 'flat', -borderwidth => 0, -font => $font);
	}
    }
    $breakIndex = 0;
} # clearBreak

########################################################################
#
#	Change the tag colours
#
########################################################################

sub colourTag {
    my ($tag, $cs) = @_;
    printf "colourTag:  %-4s %02o\n", $tag, $cs if $opt_T;
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
    $delayedColour{$tag} = $cs;		# save colour for end of flash
} # colourTag

########################################################################
#
#	Restore the tag colour after a flash
#
#	If the value in %delayedColour were not used, another change
#	before the 50 ms flash is finished may come in and the end of
#	flash will then restore to the second last change. Now the
#	colour is saved in &colourTag and the end of the flash will
#	restore the very latest change.
#
########################################################################

sub restoreTag {
    my ($tag) = @_;
    my $cs = $delayedColour{$tag} & 07;	# latest colour ignoring flash
    printf "restoreTag: %-4s %02o\n", $tag, $cs if $opt_T;
    $text->tagConfigure($tag,
			-background => $tagBackground[$cs],
			-foreground => $tagForeground[$cs],
		       );
} # restoreTag

########################################################################
#
#	Double-click on a word to transfer it to Search entry window
#	parameter 1:	dummy for key bindings
#
#	Unfortunately this clashes with a Tk::Text binding:
#	[2] Double-clicking with mouse button 1 selects the word under the
#	   mouse and positions the insertion cursor at the beginning of the
#	   word.
#
#	In practice pick_word() is executed first and marks the selection
#	in black (search found). Underneath the Text selection is also
#	there and can be shown and used for editing by clearing the search
#	with ctrl-Return or double clicking in the search entry window.
#
#	Double-click pick_word works well in Live mode, where the above
#	is not a problem. For this reason this feature is only active
#	in Live mode or Edit mode but not in Edit Undo (-u option).
#
#	Double-click on a brace, parenthesis or square bracket calls
#	report_sursor(2), which causes the insert cursor to switch to
#	the matching brace etc, which may involving moving the text.
#
#	You may prefer to allow this in Edit Undo mode
#	- simply comment if ($scanflag ...) { and matching } lines
#
########################################################################

sub pick_word {
    if ($scanFlag or not $opt_u) {	### comment to allow pick_word in Edit mode
	my $start_index = $text->index('insert wordstart');
	my $end_index = $text->index('insert lineend');
	my $line = $text->get($start_index, $end_index);
	$line =~ m/^(([\w.]+)|([{}()\[\]]))/;
	if (defined $2) {
	    $afterId->cancel if $afterId;	# cancel $watchMenu->post()
	    print "pick_word '$2'\n" if $opt_T;
	    $entrySearch->focus();		# initiate search entry
	    search_now(1, $1, 0);		# search for first word only
	} elsif (not $scanFlag and defined $3) {
	    print "pick_word '$3'\n" if $opt_T;
	    report_cursor(2);			# switch to matching brace etc
	}
    }					### comment to allow pick_word in Edit mode
} # pick_word

########################################################################
#  iClive D_channel DEBUG messages		Keybord accelerator	at app
#
#  'd'	activate DEBUG mode				'd'	set debugFlag
#	  turn search entry window pale green			(app is executing)
#	  un-grey STEP/NEXT/CONTINUE				send every symbol as it changes
#	  make all Watch point symbols break symbols		stops on next Watch point (if any)
#  	  							hold execution after sending changed symbol
#
#  	receive $C_channel:8 BREAK message
#	  break symbol is the last changed symbol before the BREAK message
#	  turn search entry window pink				(app execution has stopped)
#	  show break symbol in pink search entry window
#	  start search for the break symbol (moves text)
#	  highlight all occurences of the break symbol by a raised border and bold text
#
#  's'	STEP						's'	continue - stops on next active symbol
#	  make all active symbols break symbols			interrupts at next active symbol if not stopped
#
#  'n'	NEXT						'n'	continue - stops on next I/O symbol
#	  make only I/O symbols break symbols			interrupts at next I/O symbol if not stopped
#
#  'c'	CONTINUE					'c'	continue - stops on next Watch point (if any)
#	  make only Watch point symbols break symbols		runs unless stopped by Watch point, STEP or NEXT
#
#  'D'	de-activate DEBUG mode				'D'	clear debugFlag
#	  turn search entry window grey				continue fast execution exactly as before
#	  grey STEP/NEXT/CONTINUE				buffer changed symbols marked with live bit
#
######	The following are independent of DEBUG mode, but de-activated in Edit mode
#
#  't'	activate/de-activate debug output in app	't'	toggle -t flag
#
#  'm'	activate/de-activate microsecond output in app	'm'	toggle micro
#
######	Secondary menu options when in Live mode
#
#  -----------------	Tear Off to isolate this menu
#  Debug	   d	activate DEBUG mode				send all active symbol as they change
#  -----------------
#  Step		   s	make all active symbols break symbols	     \
#  Next		   n	make only I/O symbols break symbols	      > continue execution till next break
#  Continue	   c	make only Watch point symbols break symbols  /
#  -----------------
#  Watch points    w	list and manipulate all Watch and Ignore points in a Listbox Dialog
#  -----------------
#  Trace	   t				activate/de-activate trace output in app
#  MicroSec	   m				activate/de-activate microsecond output in app
#  -----------------
#
#  Active symbols are all words that occur both in the Symbol table and in the current text.
#  By scanning the text mark ACTIVE bit in xxx for
#	all iC variables in the source text for .ic files
#	all iC variables as well as generated intermediate variables for .lst files
#  By scanning the text mark ACTIVE bit and IO bit in xxx for
#	all IEC output variables for either .ic or .lst
#  TX0.x timer input variables are excluded from ACTIVE bits, but they may be
#  marked as Watch point symbols.
#
#  Left click a word	if DEBUG MODE and active symbol	enter as breakpoint
#
#  Beakpoints can only be entered while in DEBUG mode, but they are not deleted while not
#  in DEBUG mode - they simply are not active. Breakpoints can be disabled/enabled/deleted
#  at any time while in LIVE mode.
#
########################################################################

sub sendDebug {					# 'd' 's' 'n' 'c' 'D' 't' 'm'
    my ($k, $accelerator) = @_;
    print "sendDebug($k, $accelerator, \$debugFlag = $debugFlag)\n" if $opt_t;
    my ($acc);
    if ($scanFlag or $accelerator =~ m/^[tm]/) {		# only in Live mode except 't' or 'm'
	$k = 1 if $k;				# Key press
	if ($accelerator eq 'd') {
	    $accelerator = $debugMenu->entrycget(0, -accelerator);
	    print "sendDebug($k, $accelerator from entrycget)\n" if $opt_t;
	    search_now(1, '', 0);		# clear search
	}
	if ($accelerator eq 'D') {
	    $debugMenu->entryconfigure(0, -accelerator => 'd');
	    $debugMenu->entryconfigure(2, -state => 'disabled');	# Step
	    $debugMenu->entryconfigure(3, -state => 'disabled');	# Next
	    $debugMenu->entryconfigure(4, -state => 'disabled');	# Continue
	    $breakText = $searchText = '';			# clear search entry window
	    $entrySearch->configure(-background => 'grey94');	# indicates non-debug mode
	    $stepV = $nextV = $continueV = 0;
	    $debugFlag = 0;
	    sendWatchRestore(0, 0);		# restore set/next to all Watch and Ignore points
	    adjust_live(-1, -1) if $k;		# remove Watch and Ignore marks
	} elsif ($accelerator eq 't') {
	    $accelerator = 'S' if ($traceDebV ^= $k) == 0;
	} elsif ($accelerator eq 'm') {
	    $accelerator = 'M' if ($microSecV ^= $k) == 0;
	}
	if ($debugFlag or $accelerator =~ m/^[dDtSmM]/) {
	    $acc = ord($accelerator);	# ASCII code of $accelerator for C interptretation
	    print "sendDebug '$accelerator' $D_channel:$acc\n" if $opt_T;
	    conn_send_now("$D_channel:$acc");
	    if ($accelerator !~ m/^[dtSmM]/) {	# 'd' sets background with 'c'
		if ($B_channel and $B_stopped) {
		    $B_timer = $mainWindow->after(50,		# delay by 50 ms to complete all
			sub {					# further Watch points and single steps
			    $B_stopped = 0;
			    conn_send_now("$B_channel:$B_cont");	# program running for >= 50 ms
			}
		    );
		}
		clearBreak();
		unless ($accelerator eq 'D') {			# 'D' set 'grey94' above
		    $breakText = $searchText = '';		# clear search entry window
		    $entrySearch->configure(-background => 'palegreen');
		}
	    }
	}
	if ($accelerator eq 'd') {
	    $debugMenu->entryconfigure(0, -accelerator => 'D');
	    $debugMenu->entryconfigure(2, -state => 'normal');	# Step
	    $debugMenu->entryconfigure(3, -state => 'normal');	# Next
	    $debugMenu->entryconfigure(4, -state => 'normal');	# Continue
	    $continueV = 1;			# initial debug state is Continue
	    $debugFlag = 1;
	    sendDebug(1, 'c');
	    sendWatchRestore(0, 1);		# set all Watch and Ignore points
	    adjust_live(-1, -1);		# apply Watch and Ignore marks
	} elsif ($debugFlag) {
	    if ($accelerator eq 's') {
		$stepV = 1;
		$nextV = $continueV = 0;
	    } elsif ($accelerator eq 'n') {
		$nextV = 1;
		$stepV = $continueV = 0;
	    } elsif ($accelerator eq 'c') {
		$continueV = 1;
		$stepV = $nextV = 0;
	    }
	}
	$yScrollbar->focus();			# enable keyboard stepping
    }
} # sendDebug

########################################################################
#
#	Pop up debug menu as a standalone transient toplevel $menuBox
#	as it shows when displayed as a tearoff
#
########################################################################

sub showDebug {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	if (not Tk::Exists($menuBox)) {
	    my $xWin = $mainWindow->rootx;
	    my $yWin = $mainWindow->rooty;
	    print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	    $menuBox = Tk::Menu::tearOffMenu($debugMenu, $xWin +645, $yWin + 32); # EUREKA
	    $menuBox->protocol('WM_DELETE_WINDOW', sub { $menuBox->withdraw; sendDebug(0, 'D'); });
	} else {
	    $menuBox->deiconify();
	    $menuBox->raise();
	}
    }
    sendDebug(1, 'd');				# start with Debug mode on - toggle later
    print "Pop up debug menu '$buttonText' '$buttonState'\n" if $opt_T;
} # showDebug

########################################################################
#
#	Pop up search menu from search button after 200 ms
#
########################################################################

sub SearchMenu {
    my ($dummy, $buttonRef) = @_;
    my $buttonState = $$buttonRef->cget(-state);
    my $buttonText  = $$buttonRef->cget(-text);
    if ($buttonState ne 'disabled') {
	my $xWin = $mainWindow->rootx;
	my $yWin = $mainWindow->rooty;
	print "button '$buttonText' xWin = '$xWin' yWin = '$yWin'\n" if $opt_T;
	$searchTimer = $mainWindow->after(200,
	    sub { $searchMenu->post($xWin + 276, $yWin +  32); });
    }
    print "Pop up search menu '$buttonText' '$buttonState'\n" if $opt_T;
} # SearchMenu

########################################################################
#
#	Cancel search menu from search button before 200 ms are up
#
########################################################################

sub SearchCancel {
    $searchMenu->unpost();
    $searchTimer->cancel() if defined $searchTimer;
    print "Cancel search\n" if $opt_T;
} # SearchCancel

########################################################################
#
#	Search for a regular expression or exact match
#
#	when called as a callback from
#		eg: bind('<KeyPress-Return>', [ \&search_text, undef, 0 ])
#	the first parameter $_[0] is Tk::Entry=HASH(0x...)
#	provide a dummy true (1) first parameter when called directly.
#	Use first parameter as buttonFlag.
#
#		parameter 1:	buttonFlag - false (0) when [/] release else true
#		parameter 2:	newSearchText	(searchText tab search option)
#		    "		undef	use $searchText from Entry widget
#		    "		''	clear the search
#		parameter 3:	0  Search down	(default)
#		    "		1  Search up	(save searchText when clearing)
#		    "		2  Go to line
#		    "		|4 Special search down - suppress search statistics
#
#	search_text() is mostly called from a pop up, which does not close,
#	until search_text() has completed execution. If the search action
#	involves scrolling, the text covered by the pop up before scrolling
#	and not covered after scrolling is left blank.
#
#	To fix this, postpone the search and scrolling action until after
#	search_text() has completed execution, by posting the callback
#	search_now(). No actual delay is necessary.
#
#	When called from build_file() to search for /^*** /, which finds Error or
#	Warning lines, suppress search statistics to retain display from build
#
########################################################################

sub search_text {
    my ($buttonFlag, $newSearchText, $direction) = @_;
no warnings;
    print "search_text: \$buttonFlag = '$buttonFlag' \$newSearchText = '$newSearchText' direction = '$direction'\n" if $opt_T;
use warnings;
    unless ($buttonFlag) {
	SearchCancel();				# do this first - no delays yet
	if (not defined $searchText or $searchText eq '') {
	    $entrySearch->focus();		# initiate search entry (simulates vi)
	    return;
	}
    }
    $text->after(0, [ \&search_now, @_ ]);	# allow pop up to go away
} # search_text

sub search_now {
    my ($buttonFlag, $newSearchText, $direction) = @_;
    my ($option, $current, $hl, $length);
    my $tmpText;
    my $breakFlag = index($searchText, " = ") > 0 && ! $newSearchText;
no warnings;
    print "\$newSearchText = '$newSearchText' \$searchText = '$searchText' \$breakFlag = '$breakFlag'\n" if $opt_T;
use warnings;
    my $suppress = $direction;		# extract additional parameter 3 info
    $direction &= 0x03;			# remove suppress bit
    if (defined $newSearchText) {
	($searchText, $option) = split(/\t/, $newSearchText);
	($matchType, $ignoreCase) = $option ? split(" ", $matchRestores{$option}) : ('w', '-forwards');	# default Word search
    } else {
	$searchText =~ s/ = \d+$//;	# remove " = value" concatenated at a watch break
    }
    $searchText = '' if not defined $searchText;
    $text->tagDelete('gotoTag');
    while ($direction == 2 or $matchType eq 'g') {	# really if() {.. last; ..return;}
	########################################################################
	##	Go to line $searchText (do exact match search if not numeric)
	########################################################################
	if ($searchText eq '') {
	    $searchText = $current = "1.0";
	} elsif ($searchText =~ s/^(\d+\.(\d+|end)|end).*$/$1/) {
	    $current = "$1";
	} elsif ($searchText =~ s/^(\d+).*$/$1/) {
	    $current = "$1.0";
	} else {
	    $matchType = '-exact';	# try exact match - most likely
	    last;
	}
	print "goto: '$searchText' '$current' '$matchType' $direction\n" if $opt_T;
	$text->see($current);
	## mark the whole line - until next search - visible in Edit and Live mode
	$text->tagConfigure('gotoTag',
			    -background => 'yellow1',
			   );
	$text->tagAdd('gotoTag', "$current linestart", "$current lineend");
	$text->markSet('insert', $current);
	$text->tagLower('gotoTag');	# put any search results in foreground
	$text->tagLower('CTag');	# but visible in C code
	adjust_live();
	report_cursor();
	$tmpText = "$searchText$matchExtensions{'g'}";
	check_menu($tmpText, 'searches');
	($prevText, $prevMatch) = ($searchText, 'g');	# $prevCase not modified
	return;
    }
    if ($break) {
	$prevText = '';			# start a new search after a watch point BREAK
	$break = 0;
    }
    if ($prevText ne $searchText or $prevMatch ne $matchType or $prevCase ne $ignoreCase) {
	########################################################################
	#	Start of a new search
	########################################################################
	print "pattern: \$searchText '$searchText' \$matchType '$matchType' \$ignoreCase '$ignoreCase' \$prevText '$prevText' \$prevMatch '$prevMatch' \$prevCase '$prevCase'\n" if $opt_T;
	@hits = ();
	@groups = ();
	$gl = 0;
	tagDeleteRestore_searchTag() if $prevText;
	($prevText, $prevMatch, $prevCase) = ($searchText, $matchType, $ignoreCase);
	if ($matchType eq 'w') {
	    if ($searchText =~ m/^(\w+|[IQT][XBWLH]\d+\.[0-7](_\d+)?)$/) {
		$matchType = '-regexp';
		$searchText = "\\b$searchText\\b";
		$searchText =~ s/\./\\./;
	    } else {
		$matchType = '-exact';
	    }
	}
	print "searchText '$searchText' matchType '$matchType' ignoreCase '$ignoreCase'\n" if $opt_T;
	$current = '1.0';
	$length = '0';

	########################################################################
	#	Actual searches storing results in @hits
	#	for every hit add black 'searchTag' unless searching watch word
	########################################################################
	while (1) {
	    eval {
		$current = $text->search(-count => \$length,	# number of characters matched
					 $matchType,	# -exact -regexp
					 $ignoreCase,	# -forwards (filler) -nocase, (never search backwards)
					 '--',		# forces next argument to be pattern
					 $searchText,	# search pattern
					 $current,	# start index - moves with every iteration
					 'end',		# stop index
					);
	    };
	    if ($@) {
		chop $@;
		$@ =~ s# at /usr.*##;
		info_display(0, 'red', "ERROR: $@");	# error in search
		last;
	    }
	    last unless $current and $length;		# end of pattern search or 0 length match (clear)
	    my $comment = 0;
	    if ($scanFlag) {
		foreach ($text->tagNames($current)) {	# in Live mode block hits in comments
		    if ($_ eq "cTag") {
			$comment = 1;
			last;
		    }
		}
	    }
	    unless ($comment) {
		if ($opt_T) {
		    my @lineinfo = $text->dlineinfo($current);
		    my $word = $text->get($current, "$current + $length chars");
		    print "word: $word $length '@lineinfo'\n";
		}
		unless ($breakFlag) {
		    $text->tagAdd('searchTag', $current, "$current + $length chars");
		}
		$current =~ /(\d+)\.(\d+)/;		# y and x coordinates of current hit
		push @hits, [ $current, $1, $2, $length, ];
	    }
	    $current = $text->index("$current + $length chars");	# point bejond hit
	}
	($searchText, $matchType) = ($prevText, $prevMatch);	# otherwise radio button skips
	if (($hl = scalar @hits) > 0) {
	    if ($searchText ne '^\*\*\* ') {		# regular expression to find errors in listing
		$tmpText = "$matchType$ignoreCase";
		$tmpText = "$searchText$matchExtensions{$tmpText}";
		check_menu($tmpText, 'searches');
	    }
	    ########################################################################
	    #	Analyse hits and group them into display groups.
	    #   Pseudo_code for new algorithm (August 2009).
	    #
	    #	The previous 2 algorithms were much longer.
	    #	They actually missed showing some hits under some circumstances.
	    ########################################################################
	    # re-compute window details in case text and/or window has changed
	    $text->yview('moveto', 0);		# window to top left of text so bbox works
	    my ($x, $y, $w, $lineHeight) = $text->bbox("1.0");
	    print "bbox('1.0') x = $x, y = $y, w = $w, lineHeight = $lineHeight\n" if $opt_T;
	    my $h = $text->height;		# current height of display window in pixels
	    my $height = int($h/$lineHeight);	# current height of display window in lines
	    my $endm = $text->index('end');
	    $endm =~ m/(\d+)\.(\d+)/;
	    $lineCnt = $1 - 1;			# current length of text in lines
	    my $groupFirst = undef;
	    my $prevGroupHeight = 0;
	    my ($groupHeight, $groupTop, $aRef);
	    while (($aRef = shift @hits)) {
		($current, $y, $x, $length) = @$aRef;
		if (defined $groupFirst) {
		    if (($groupHeight = $y - $groupFirst) >= $height) {
			$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
			$groupTop = 0 if $groupTop < 0;
			push @groups, $groupTop / $lineCnt;
			$groupFirst = $y;	# start of new group
			$prevGroupHeight = 0;
		    } else {
			$prevGroupHeight = $groupHeight;
		    }
		} else {
		    $groupFirst = $y;		# first item in search
		}
	    }
	    if (defined $groupFirst) {
		$groupTop = int ($groupFirst + ($prevGroupHeight / 2) - ($height / 2));
		$groupTop = 0 if $groupTop < 0;
		push @groups, $groupTop / $lineCnt;
	    }

	    $gi = -1;				# see index
	    $gl = scalar @groups;
	    my $plural = $gl > 1 ? 's' : '';
	    info_display(1000, 'dark green', "/$searchText/ found $hl times in $gl group$plural") unless $suppress & 0x04;
	    $text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	}
	$entrySearch->focus();
    }
    my $pos = index($breakText, $searchText . " = ");
    print "\$searchText = '$searchText' \$breakText = '$breakText' \$pos = $pos\n" if $opt_T;
    if ($pos == 0) {
	$searchText = $breakText;			# restore Search Entry window at BREAK
    }
    ########################################################################
    #	Use @groups to scroll over the groups forwards or backwards.
    #	Initial group index is $gi = -1. Used to determine scroll start for
    #	immediate backward scroll.
    #	Even for a single group, re-position group every time RETURN is pressed,
    #	because the hits could have been moved by manual scrolling.
    ########################################################################
    if ($gl > 0) {
	my $infoFlag = ($gi < 0 or $gl < 2) ? 0 : 1;	# allows search statistics info to stay
	if (not $direction) {
	    $gi++;			# forward scroll
	    if ($gi >= $gl) {
		$gi = 0;
		if ($infoFlag) {
		    info_display(1000, 'dark red', "search hit BOTTOM, continuing at TOP");
		    $infoFlag = 0;
		}
	    }
	} else {
	    $gi--;			# backward scroll
	    if ($gi < 0) {
		if ($infoFlag and $gi == -1) {	# -2 is first time backwards
		    info_display(1000, 'dark red', "search hit TOP, continuing at BOTTOM");
		    $infoFlag = 0;
		}
		$gi = $gl - 1;
	    }
	}
	if ($infoFlag) {
	    info_display(0, 'black', " ");	# clears display_info to 1 space ("" quit_program)
	}
	$text->yview('moveto', $groups[$gi]);	# move forward or backward to next group
	print("moveto line @{[$lineCnt*$groups[$gi]+1]}\n") if $opt_T;
	adjust_live();
    } elsif ($gl == 0 and not $@) {	# do not overwrite search eval error message
	if ($searchText ne '') {
	    print "\$searchText = '$searchText' \$breakText = '$breakText' not found\n" if $opt_T;
	    info_display(0, 'red', "/$searchText/ not found");	# report every time
	} else {
	    info_display(0, 'dark red', "search cleared");
	    if ($scanFlag) {
		$yScrollbar->focus();
	    } else {
		$text->focus();
	    }
	}
    }
} # search_now

########################################################################
#
#	Clear_all
#
########################################################################

sub clear_all {
    deleteAllTags();	# also clears @activeSymbols
    %symbolTable = ();	# clear symbol table so balloons dont show
    clear_scan(1);	# detach balloon
} # clear_all

########################################################################
#
#	Delete all tags for previous active symbols
#
########################################################################

sub deleteAllTags {
    $text->configure(-state => 'normal');
    $text->focus();
    foreach my $index (0 .. $#activeSymbols) {
	my $ts = $activeSymbols[$index][0];
	if ($ts) {
	    if ($opt_T) {
		print(" $index")    if $ts & 01;	# normal
		print(" $index~")   if $ts & 02;	# inverted
		print(" $index=")   if $ts & 04;	# value
		print(" deleted\n");
	    }
	    if ($ts & 01) {
		$text->tagDelete("$index");
	    }
	    if ($ts & 02) {
		$text->tagDelete("$index~");
	    }
	    if ($ts & 04) {
		my $tag = "$index=";
		my @ranges = $text->tagRanges($tag);
		for (my $i = 0; $i < @ranges; $i += 2) {
		    $text->delete(@ranges[$i, $i+1]);
		}
		$text->tagDelete($tag);
	    }
	}
    }
    @activeSymbols = ();	# delete all previous active symbols
    if ($readOnly) {
	$text->configure(-state => 'disabled');	# read-only file
    }
} # deleteAllTags

########################################################################
#
#	Live/Edit - switch between clear_scan and do_scan
#
########################################################################

sub scan {
    deleteAllTags();		# also clears @activeSymbols
    if ($scanFlag) {
	reset_scan();		# return to Edit mode
    } elsif ($conn) {
	$scanFlag = 1;
	$liveButton->configure(-text => 'wait');
	print "$named: scan 'wait'\n" if $opt_T;
	if ($runName ne '') {
	    print "$named: Request Symbol Table '$D_channel:1'.\n" if $opt_T;
	    conn_send_now("$D_channel:1");	# request Symbol Table
	}
    } else {
	print "not connected ???\n" if $opt_T;
	register_now();
    }
} # scan

########################################################################
#
#	Reset $scanFlag and then clear_scan()
#		parameter 1:	1  skips clear active symbols in application
#
#    if ($opt_u) {
#	########################################################################
#	# in 'Live' mode 'variable =' displays are seen as edits which can be undone
#	# in 'Edit' mode unless the undo stack is cleared
#	########################################################################
#	$text->editReset;	# clears the undo and redo stacks for Tk::TextUndo
#    }
#    This code does not work for Tk::TextUndo ??? not implemented for Tk::Text
#    $text->editReset does not clear the undo stack
#
########################################################################

sub reset_scan {
    if ($scanFlag) {
	sendDebug(0, 'D');			# debug mode off
	$scanFlag = 0;
	$liveButton->configure(-text => 'Live');
	$prevText = '';				# start a new search
	$gl = 0;
	tagDeleteRestore_searchTag();
	$debugMenu->entryconfigure(0, -state => 'disabled');	# Debug
	$debugMenu->entryconfigure(6, -state => 'disabled');	# Watch points
	clear_scan(@_);
    }
} # reset_scan

########################################################################
#
#	Clear scan and detach balloon processing. Prepare for scan.
#	Clear active symbols for faster processing of connected controller
#		parameter 1:	1  skips clear active symbols in application
#
########################################################################

sub clear_scan {
    if ($balloonAttached) {
	$balloon->detach($text);
	$balloonAttached = 0;
    }
    unless (@_) {		# skip if parameter 1 set
	info_display(0, 'black', " ") if $searchText eq '';	# clears display_info unless search
	if ($conn) {
	    ####################################################################
	    ## clear active symbols in connected iC controller process
	    ## reset last D_channel value in iCserver
	    ####################################################################
	    if ($runName ne '') {
		print "clear_scan() sends '$D_channel:5,$D_channel:0'\n" if $opt_T;
		conn_send_now("$D_channel:5,$D_channel:0");
	    }
	}
    }
} # clear_scan

########################################################################
#
#	Common subroutine to ask a Yes/No/Cancel question and provide an answer
#
########################################################################

sub askYesNo {
    my ($Title, $Text, $Textvariable) = @_;
    my $dialog = $text->Dialog (-title   => $Title,
				-bitmap  => 'question',
				-text    => $Text,
				-buttons => [qw(Yes No Cancel)],
			       );
    my $dialogBar = $dialog->Label(-textvariable => $Textvariable,
				   -relief       => 'ridge',
				  )->pack(-side => 'bottom', -fill => 'x');
    my $answer = $dialog->Show(
	    -popover    => $mainWindow,
	    -overanchor => 'c',
	    -popanchor  => 'nw',
	    -takefocus  => 1);
    return $answer;
} # askYesNo

########################################################################
#
#	Scan text for symbols in %symbolTable, adding a tag for each
#	symbol found and another for the inverted symbol, if required.
#
#	The colouring for each symbol found is initially set to logic 0.
#	Any active symbols which are not 0 are updated immediately by
#	the iC control program. Further updates occur, every time the
#	state of an active symbol changes.
#
#	Attach balloon processing while display is live.
#	Balloon processing is detached for a newly loaded file and when
#	the scan is cleared to allow clean editing.
#
#	Called from adjust_live()
#
########################################################################

sub do_scan {
    my ($current, $last) = @_;
    my ($length, $word, $i, $iw, $tag, $cs, $ts, $ftype, $index, $t, $comment);
    print "do_scan: instName = '$instName' regName = '$regName' makeName = '$makeName'\n" if $opt_T;
    if (defined $instName and $instName ne '') {
	if ($instName ne $regName) {
	    register_now();	# register at new process
	    return;
	}
	if (defined $makeName and $makeName ne '') {
	    my $answer = askYesNo('Modified build', 'Start up to date build?', \$makeName);
	    if ($answer eq 'Cancel') {
		return 0;			# cancel operation
	    } elsif ($answer eq 'Yes') {
		print "do_scan: stop '$instName' start '$makeName'\n" if $opt_T;
		stop_file();			# $runName = ''
		$restartFlag = 1;		# restart after receiving stopped message
		return 0;
	    }
	}
	$text->configure(-state => 'normal');
	$current = '1.0' unless defined $current;
	$last    = 'end' unless defined $last;
	$length = '0';
	while (1) {
	    $current = $text->search(-count => \$length,
				     '-regexp',
				     '--',
				     $scanPattern,
				     $current,
				     $last);
	    last if (!$current);
	    my $currEnd = $text->index("$current + $length chars");
	    $iw = $i = $text->get($current, $currEnd);
	    ########################################################################
	    # Match simple variables, IEC-1131 and derivatives as well as immC array members
	    ########################################################################
	    $i =~ s/(-)?([~\t ]*)(-\s*\d+|\w[\w\$]*(\s*\.\s*[0-7](_\d+)?|(\s*\[\s*\d+\s*\]))?)([~\t ]*)/$2$7/;
	    $word = defined $1 ? "$1$3" : $3;	# word for the symbol table
no warnings;
	    $tag = "'$word' length=$length, iw='$iw' i='$i' 1='$1' 2='$2' 3='$3' 5='$5' 6='$6'\n" if $opt_T;
use warnings;
	    $word =~ s/\s//g;			# delete any white space
	    if (defined $word and $symbolTable{$word}) {
		($ftype, $index) = @{ $symbolTable{$word} };
		if (defined $index and $ftype) {
		    print $tag if $opt_T;
		    $tag = $index;		# word is in the symbol table
		    $cs = $colourSelect[$ftype]; # initial colour with ALIAS inv
		    @{ $activeSymbols[$index] }[1 .. 3] = (0, $cs & ~01, [gettimeofday()]);
		    $comment = 0;
		    foreach ($text->tagNames($current)) {
			if ($_ eq "cTag") {
			    $comment = 1;
			    last;
			}
		    }
		    if (not $comment) {
			########################################################################
			# live display outside of comments
			# only comments are tagged with 'cTag' and possibly 'sel'
			########################################################################
			while ($i =~ m/~/g) {
			    $cs ^= 1;		# complement initial colour selection
			}
			$tag .= '~' if ($ts = $cs & 01); # adjust tag name if inverted
			$ts++;			# convert to a mask 0 => 01, 1 => 02
			print "$tag	$word	'$iw'\n" if $opt_T;
			unless (($t = $activeSymbols[$index][0]) and ($t & $ts)) {
			    ## using $t | $ts causes warning of uninitialised value in (|)
			    $activeSymbols[$index][0] |= $ts; # 01|02 leaves 03 for both
			    colourTag($tag, $cs);	# initial tag colour
			}
			$current =~ m/(\d+)\.(\d+)/;
			if ($extnName eq "lst" or $2 >= 6) {
			    $text->tagAdd($tag, $current, $currEnd);
			}
		    }
		    elsif (($cs == 2 or $cs == 6) and	# ARITH or TIMRL
			    $iw =~ /[\w.]+(\s*\[\s*\d+\s*\])?\s*=$/) {
			########################################################################
			# only live display in a comment is 'symbol =' at end of a comment line
			########################################################################
			print "$tag	$word	'$iw' ftype = $ftype\n" if $opt_T;
			unless ($activeSymbols[$index][0] and $activeSymbols[$index][0] & 04) {
			    $activeSymbols[$index][0] |= 05; # for analog value display
			    colourTag($tag, $cs);	# ARITH or TIMRL tag
			}
			$text->tagAdd($tag, $current, $currEnd);
			$tag = "$index=";
			colourTag($tag, $cs);		# ARITH or TIMRL tag
			$text->insert("$currEnd lineend", " 0", $tag);	# default display value 0
		    }
		}
		## ELSE - there may be spurious words in symbolTable with undefined data
		##        as explained in "Programming Perl 3rd ed. page 254" - IGNORE
	    }
	    $current = $currEnd;		# continue search after this atom
	}

	####################################################################
	## Send list of active symbols to the iC control process. Only the
	## state (logic or arithmetic) for the symbols in this list need to
	## be updated for this display, since the others are not displayed.
	## It is immaterial for the control program in which logic
	## sense the symbol is displayed, except for inverted ALIASes.
	####################################################################

	my $msg = '';
	foreach $index (0 .. $#activeSymbols) {
	    if ($activeSymbols[$index][0]) {
		print "$index\n" if $opt_T;
		$msg .= ";$index";
	    }
	}
	sendMsg(3, 4, $msg);			# send ; separated list in 1 or more sections
	conn_send_now("$D_channel:0");		# reset last value in iCserver

	####################################################################
	## Restore Watch and Ignore point markings
	####################################################################

	if ($debugFlag) {
	    foreach $index (keys %{ $watchPoints{$instName} }) {
		my $state = ${$watchPoints{$instName}{$index}}[0];
		printf("%s	index %3d state = 0x%02x\n", $symbolNames[$index], $index, $state) if $opt_T;
		markWatch($state, $index);
	    }
	}

	####################################################################
	## Attach balloon processing
	####################################################################

	if ($runName ne '' and not $balloonAttached) {
	    $balloon->attach($text,
	       -balloonmsg      => \$bMsg,
	       -balloonposition => 'mouse', # not used since postcommand returns real position
	       -postcommand     => sub {
		    my ($word, $stem, $ftype, $index, $val, $wlen, $wlen_1);
		    ## Have a word under mouse - change the message:
		    $stem = $text->get($wIdx, "$wIdx lineend");
		    ## Skip if word starts with a non-word char
		    return 0 if not $stem or $stem =~ /^\W/;	# first character is not \w
		    print "$stem\n" if $opt_T;
		    ## Try bit I/O like IX0.0 QX10.7 or TX0.0_14 first
		    if ($stem =~ /^([IQT]X\d+\s*\.\s*[0-7](_\d+)?)/) {
			$word = $1;		# bit I/O variable found
			$wlen = length $word;
		    }
		    elsif ($stem =~ /^(\w[\w\$]*(\s*\[\s*\d+\s*\])?)/) {
			$word = $1;		# number or variable found
			$wlen = length $word;
			if ($word =~ /\d+/) {
			    $stem = $text->get("$wIdx linestart", "$wIdx + $wlen chars");
			    if ($stem =~ /((-\s*)\d+)\s*$/) {
				$word = $1;	# negative number
				$wlen = length $word;
				$wlen_1 = length $2;
				$wIdx = $text->index("$wIdx - $wlen_1 chars");
				$word =~ s/\s//g;	# delete possible white space around '-'
			    }
			}
		    } else {
			return 0;		# unlikely with \W test above
		    }
		    $word =~ s/\s//g;		# delete possible white space around '.' and '[]'
		    print "	word = $word\n" if $opt_T;
		    if (not defined ($index = $symbolTable{$word}[1])) {
			return 0;		# not found in S.T.
		    }
		    $wlen_1 = $wlen - 1;
		    $ftype = $symbolTable{$word}[0];
		    $val = $activeSymbols[$index][1]; $val = 0 unless $val;
		    print "	wlen = $wlen, val = $val, index = $index, ftype = $ftype, shift_control_state = $shift_control_state\n" if $opt_T;
		    $val ^= 1 if $colourSelect[$ftype] & 01; # inv ALIAS
		    ########################################################################
		    #	Shift/Control Key state
		    #	none			0	balloon shows value of variable
		    #	Shift_L			1	balloon shows index in S.T. (useful in checking for ALIASES)
		    #	Control_L		2	balloon shows ftype as mnemonic
		    #	Shift_L+Control_L	3	balloon shows ftype as number
		    #	NOTE: iClive window must have focus for KeyPress and KeyRelease to be recognised
		    ########################################################################
		    if ($shift_control_state == 0) {
			$bMsg = "$val";
		    } elsif ($shift_control_state == 1) {
			$bMsg = "index=$index";
		    } elsif ($shift_control_state == 2) {
			$bMsg = "ftype=$full_ftype[$ftype]";
		    } elsif ($shift_control_state == 3) {
			$bMsg = "ftype=$ftype";
		    }
		    $text->tag('add', 'sel', $wIdx, "$wIdx + $wlen chars");
		    ## a good place to put the balloon is below the last char in the word
		    my $i = $text->index("$wIdx + $wlen_1 chars");
		    my @p = $text->bbox($i);
no warnings;
		    my $x = $text->rootx + $p[0] + $p[2] - 4;
		    my $y = $text->rooty + $p[1] + $p[3] + 2;
use warnings;
		    return "$x,$y";
		},	# end of -postcommand
	       -motioncommand   => sub {
		    my $x = $text->pointerx - $text->rootx;
		    my $y = $text->pointery - $text->rooty;
		    $wIdx = $text->index("\@$x,$y wordstart");
		    if ($wIdx eq $pIdx) {
			## Same word as previous word - dont cancel the balloon.
			return 0;
		    } else {
			## New word under mouse
			## cancel it so a new balloon will be posted.
			$text->SelectionClear;
			$pIdx = $wIdx;		# save as previous word
			return 1;
		    }
		},	# end of -motioncommand
	    );		# end of attach() call
	    $balloonAttached = 1;
	}

	####################################################################
	## change text on scan button to 'View' (RO) or 'Edit'
	####################################################################
	$text->tagRaise('searchTag') if $gl;	# put any search results in foreground
	if ($readOnly) {
	    $liveButton->configure(-text => 'View');
	} else {
	    $liveButton->configure(-text => 'Edit');
	}
	$debugMenu->entryconfigure(0, -state => 'normal');	# Debug     enabled
	$debugMenu->entryconfigure(6, -state => 'normal');	# Watch points enabled
	$menuBuild->entryconfigure(5, -state => 'normal');	# Symbol Table by name
	$menuBuild->entryconfigure(6, -state => 'normal');	# Symbol Table by index
	$text->configure(-state => 'disabled');
	$yScrollbar->focus();
	$text->tagDelete('pTag');
	$scanFlag = 1;		# scan successful
    } else {
	info_display(2000, 'red', "no current runnable proces");
    }
} # do_scan

########################################################################
#
#	Optionally Delete and Restore 'searchTag'
#
#	Deleting 'searchTag' is the easiest way to restore original
#	text format of all regions tagged with 'searchText'.
#
#	This routine makes sure that 'searchTag' is always active, which
#	avoids TK::Error when 'searchTag' is raised and not present.
#
#	parameter 1:	false	delete and create tag again
#			true	create tag only
#
########################################################################

sub tagDeleteRestore_searchTag {
    unless ($_[0]) {
	$text->tagDelete('searchTag');
    }
    $text->tagConfigure('searchTag',
			-background => 'black',	# same as 'less' colouring
			-foreground => 'white',	# stands out amongst live colours
		       );			# cannot see live status though except overhang
} # tagDeleteRestore_searchTag

########################################################################
#
#	Register_now
#
########################################################################

sub register_now {
    $scanFlag = 1;
    $liveButton->configure(-text => 'wait');
    print "$named: register_now 'wait'\n" if $opt_T;
    register_at_server();
    # will call do_scan() if connect was successful via Request S.T and :2 reply
} # register_now

########################################################################
#
#	Get contents from text
#	If text has line numbers (not .lst) and text has changed, restore
#	it and update line numbers to take care of changes in the text
#
########################################################################

sub getContents {
    my ($line, $r);
    my $wholeContents = $text->get("1.0", "end - 1 chars");	# whole text with or without line numbers
    if ($extnName eq "lst") {
	return $wholeContents;					# whole text for listing
    }
    if ($wholeContents ne $disContents) {
	my @arrayContents = split "\n", $wholeContents;		# text with line numbers has changed
	$text->tagDelete('cTag', 'bd', 'er', 'cv', 'it', 'bt');	# delete really slow if not done
	$text->delete("1.0", "end");			# clear the text area
	$newContents = '';
	$disContents = '';
	my $disLine = 0;
	foreach $line (@arrayContents) {
	    $line =~ s/^ +\d+\t//;				# remove line number
	    $newContents .= "$line\n";			# contents without line numbers
	    $disContents .= sprintf(" %4d\t%s\n", ++$disLine, $line);
	}
	$text->insert("end", $disContents);			# restore text with new line numbers
	if ($r = tagComments()) {
	    info_display(2000, 'red', "WARNING: $r syntax errors in $fileName$readOnly");
	}
    }
    return $newContents;		# $newContents does not change if $disContents has not changed
} # getContents

########################################################################
#
#	Check if a file has been modified and needs to be saved
#	parameter 1:	0 or undef: Save contents if Button'Yes'
#			1:          SaveAs contents if Button'Yes'
#
#	IF contents has changed
#	    IF Button 'Yes' is pressed
#		Save $fileName or SaveAs if parameter 1 is true
#		changes entry box text to $fileName if Save successful
#		return 1 if successful else 0
#	    ELSIF Button 'No' is pressed
#		return -1
#	    ELSIF Button 'Cancel' is pressed
#		return 0
#	ELSE
#	    return 1
#
########################################################################

sub check_save {
    my $par1 = $_[0];
    my $contents = getContents();				# whole text
    if ($contents ne $oldContents) {
	if ($opt_T) {
	    my $l1 = length $contents;
	    my $l2 = length $oldContents;
	    print "length contents = $l1, length oldContents = $l2\n";
	}
	my $As = $par1 ? 'As' : '';
	my $answer = askYesNo("Modified file", "Save$As modified file?", \$fileName);
	if ($answer eq 'Yes') {
	    if ($par1) {
		return saveAs_file();	# Yes - save modified file under new name
	    } else {
		return save_file(0, 1);	# Yes - save modified $fileName
	    }
	} elsif ($answer eq 'No') {
	    return -1;			# No - abort saving
	} elsif ($answer eq 'Cancel') {
	    return 0;			# Cancel operation
	}
    } else {
	return 1;			# contents have not changed
    }
} # check_save

########################################################################
#
#	New text clears the text area
#
########################################################################

sub new_text {
    deleteAllTags();	# also clears @activeSymbols
    reset_scan();	# Live => Edit mode
    if (check_save()) {
	if ($readOnly) {
	    $text->configure(-state => 'normal');	# allow clearing new file
	    $readOnly = '';				# can modify text
	}
	$text->tagDelete('cTag', 'CTag', 'icaTag', 'bd', 'er', 'cv', 'it', 'bt');	# delete all special tags
	$text->delete("1.0", "end");
	$newContents = $disContents = $oldContents = '';
	$fileName = $unknown;
	$mainWindow->title("$named$u: $fileName$readOnly $runName");
	info_display(2000, 'black', "New text window opened");
    }
} # new_text

########################################################################
#
#	Reload the currently loaded iC $fileName because it was
#	(possibly) altered externally, usually by vi if a source file
#	or iCmake if a generated file.
#	If file has been modified SaveAs instead of Save file if answer
#	to check_save is Yes.
#
########################################################################

sub reload_file {
    my $fileRname = $fileName;
    if (check_save(1)) {		# SaveAs
	$fileName = $fileRname;
	open_file(0, $fileName);
    }
} # reload_file

########################################################################
#
#	Open the list file (file.lst) for the currently loaded iC $fileName
#	Alternatively open the corresponding file.ic
#
#	For iCa $fileName open the iC file and then the list file and then
#	the iCa file again
#
########################################################################

sub open_list {
    if ($fileName =~ /^(([\w\.\$]*[\\\/])*([\w\.\$]+))\.(ic|ica|lst6?|c|h|ini)$/) {
	if ($4 eq "ic") {
	    open_file(1, "$1.lst");
	} elsif ($4 eq "ica") {
	    open_file(1, "$1.ic");
	} elsif (-w "$1.ica") {		# now at .lst
	    open_file(0, "$1.ica");
	} else {
	    open_file(0, "$1.ic");	# $1.lst not saved, since generated and RO
	}
    } else {
	info_display(2000, 'red', "ERROR: no file matching '$fileName$readOnly'");
    }
} # open_list

########################################################################
#
#	Opens a file if possible; then loads the contents
#		parameter 1:	0 or undef: load unconditionally (discard changes)
#				1:          save first if text is altered
#		parameter 2:	$fName
#				'' use getOpenFile from Tk::FBox (default)
#	$fileName is assigned new $fName if successfully opened
#	this is done, rather than returning new name because open_file is often
#	called from a call-back, where the return value cannot be used
#
#	$fName must be 2nd parameter to line up with search_text(), which
#	has a dummy 1st parameter and whose 2nd parameter searchText is also
#	supplied from a menu via a closure set up in check_menu()
#	both are called via check_menu()
#
#	If a file is read-only, $readOnly is set, which executes
#		$text->configure(-state => 'disabled');
#	when going to Edit mode - also stops save but not saveAs
#
########################################################################

sub open_file {
    my ($conditional, $fName) = @_;	# optional parameters
    $conditional = 0 unless $conditional;	# stops trace errors
    print "open_file: \$conditional = '$conditional' \$fName = '$fName'\n" if $opt_T;
    if ($conditional == 3 and $cName) {
	$cascName = $cName;		# cascade menu selected
    } elsif ($conditional == 2) {
	$cascName = '';			# non-cascade menu selected
    }					# else do not change $cascName, $procName, $processName
    my $ci = 0;
    my $no = 0;
    if ($scanFlag) {
	deleteAllTags();		# required here to clear = values in text
	reset_scan(1);			# $text -state now 'normal' for reading file
	$scanFlag = 1;			# restore $scanFlag
    }
    if (not $conditional or check_save() or ($cascName !~ m/$processName/)) {
	unless (defined $fName and $fName ne '') {
	    $fName = $mainWindow->getOpenFile(-filetypes => $fileTypes);
	    unless (defined $fName and $fName ne '') {
		print "open_file: $conditional no file selected\n" if $opt_T;
		info_display(2000, 'red', "no file selected");
		return;			# global $fileName is not altered
	    }
	    $fName =~ s#^C:/cygwin## or $fName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	    $fName =~ s#^$cwd/##;
	}
	if (not $conditional or $fName ne $fileName or ($cascName !~ m/$processName/)) {
	    print "open_file: $conditional $fName\n" if $opt_T;
	    my $rName = $runName;
	    $rName =~ s/-\d+//;		# check without instance number
	    if (not $runNames{$runName} and $rName and $fName !~ /^$rName/) {
		# new file not running and old file is running and not derived from new file
		info_display(2000, 'red', "'$runName' is still running - should be stopped unless compatible with '$fName'");
		my $answer = askYesNo('Still running', 'Stop executable?', \$runName);
		if ($answer eq 'Yes') {
		    print "open_file: open '$fName' stop '$runName'\n" if $opt_T;
		    conn_send_now('X') if $conn;
		    stop_file();				# $runName = ''
		} else {
		    if ($answer eq 'No') {
			print "open_file: open '$fName' leave '$runName' running in background\n" if $opt_T;
			info_display(2000, 'blue', "'$runName' is still running in background");
		    } else {					# 'Cancel'
			info_display(2000, 'blue', "'$fName' was not loaded - '$runName' is still running");
			return 0;				# cancel operation
		    }
		}
	    }
	    if ($readOnly) {					# applies to previously opened file
		$text->configure(-state => 'normal');		# allow overwriting with new file
	    }
	    $fileName = $fName;					# alter global $fileName
	    ########################################################################
	    #  Set global $processName, $pathName, $procName and $extName here using
	    #  $cascName if it is set.
	    #  They are used in run_file() and build_file()
	    #  Only other change is in saveAs_file() when $fileName is changed.
	    ########################################################################
	    my $m = $fileName =~ m/^((([\w\.\$]*[\\\/])*)([\w\.\$]+))\.(\w+)$/;
	    ($processName, $pathName, $procName, $extnName) = ($1, $2, $4, $5);	# used globally
	    if ($cascName =~ m/^(([\w\.\$]*[\\\/])*([\w\.\$]+))$/) {
		($processName, $pathName, $procName) = ($1, $2, $3);
	    }
	    if ($processName eq $procName) {
		$processName = "./$procName";		# in case . is not in $PATH
		$pathName    = "";
	    }
	    $mainWindow->title("$named$u: $fileName$readOnly $runName");
	    $text->tagDelete('cTag', 'bd', 'er', 'cv', 'it', 'bt');	# delete really slow if not done
	    $text->delete("1.0", "end");			# clear the text area
	    $newContents = $disContents = '';
	    stat($fName);
	    if (-f _ and -r _ and open(FH, "<$encoding", $fName)) {	# :encoding($opt_E) calls stat()
		my $baseName = $procName;			# for diplay switching
		$readOnly = (-w $fileName) ? '' : ' (RO)';	# set new read-only flag correctly; new stat() because of encoding()
		print "$fileName is read-only\n" if $readOnly and $opt_T;
		my $disLine = 0;
		while (<FH>) {
		    $newContents .= $_;
		    if ($extnName ne "lst") {
			$disContents .= sprintf(" %4d\t%s", ++$disLine, $_);
		    }
		}
		close(FH);
		## read last modified time from new stat now in case it changed since last stat
		$fileTime = (stat($fileName))[9]; $fileTime = 0 unless defined $fileTime;
		if ($extnName ne "lst") {
		    $text->insert("end", $disContents);
		} else {
		    $text->insert("end", $newContents);
		}
		my $length = length $newContents;
		$oldContents = $newContents;
		my $r;
		if ($r = tagComments()) {
		    info_display(2000, 'red', "WARNING: $r syntax errors in $fileName$readOnly - not registered");
		    $no = 1;		# do not register this file
		} else {
		    info_display(2000, 'black', "File $fileName$readOnly, $length bytes loaded");
		}
		if ($m and $extnName =~ m/^(i[ch]a?|lst6?|c|h|ini)$/) { if
		($extnName eq "ic") { $menuFile->entryconfigure(4, -label =>
		"$baseName.lst"); } elsif ($extnName eq "ica") {
		$menuFile->entryconfigure(4, -label => "$baseName.ic"); } elsif
		(-w "$baseName.ica") { $menuFile->entryconfigure(4, -label =>
		"$baseName.ica"); } else { $menuFile->entryconfigure(4, -label
		=> "$baseName.ic"); }
		    if ($extnName =~ m/^ica?$/) {
			check_menu($fileName, 'files');		# save files with known extensions in file menu
		    }
		    unless ($no) {
			$instName = "$procName$instanceText";	# previous executable was stopped or is compatible
			$ci = change_instance();
			adjust_live(-1, -1);
		    }
		}
		$prevText = '';					# start a new search
		$gl = 0;
		tagDeleteRestore_searchTag();
		if ($readOnly) {
		    $text->configure(-state => 'disabled');	# read-only file
		}
		return if $ci;					# global $fileName and application has altered
	    } else {
		# file does not exixt yet - open a new text window
		$readOnly = $oldContents = '';			# can modify new text
		info_display(2000, 'black', "File $fileName does not exist yet - new text window opened");
		if ($extnName =~ m/^ica?$/) {
		    print "open not existing file - check menu\n" if $opt_T;
		    check_menu($fileName, 'files');		# save files with known extensions in file menu
		}
	    }
	    adjust_live();
	}
    }
    return;
} # open_file

########################################################################
#
#	Saves the file previously loaded or last saved
#		parameter 1:	(ignore)
#		parameter 2:	0 or '' overwrite if contents has changed (default)
#				1 overwrite file unconditionally (new destination)
#
########################################################################

sub save_file {
    my $r;
    my $ret = 1;		# good return
    if ($r = tagComments()) {		# comments and/or keywords may have changed
	info_display(2000, 'red', "ERROR: $r syntax errors in file");
	my $answer = askYesNo('Syntax errors in file', 'Really save this file?', \$fileName);
	if ($answer ne 'Yes') {
	    info_display(2000, 'red', "ERROR: $r syntax errors in file - not saved");
	    return 0;		# No or Cancel - report error
	}
    }
    if (defined $fileName and $fileName ne $unknown and $fileName ne '') {
	my ($unconditional) = $_[1];	# optional 2nd parameter
	my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	########################################################################
	## allow non existing file to be written by setting to $fileTime if undef
	########################################################################
	if ($ftime != $fileTime) {
	    info_display(2000, 'red', "'$fileName$readOnly' modified in background");
	    my $answer = askYesNo('Modified since reading file', 'Save to modified file?', \$fileName);
	    if ($answer ne 'Yes') {
		info_display(2000, 'red', "'$fileName$readOnly' modified in background - not written");
		return 0;	# No or Cancel - report error
	    }
	    $unconditional = 1;	# definitely write to modified file
	}
	deleteAllTags();	# also clears @activeSymbols
	reset_scan(1);		# take away all live text
	my $contents = getContents();				# whole text without line numbers
	if ($unconditional or $contents ne $oldContents) {
	    ########################################################################
	    ## test read-only. then rename to backup if $fileName exists
	    ## stat was done above
	    ########################################################################
	    if (-f _ and not -w _) {
		info_display(2000, 'red', "ERROR: Could not save read-only file '$fileName$readOnly'");
		$ret = 0;	# error return
	    }
	    elsif (-f _ and not rename $fileName, "$fileName.bak") {	# is writable
		info_display(2000, 'red', "ERROR: Could not rename backup to '$fileName.bak'");
		$ret = 0;	# error return
	    }
	    elsif (open(FH, ">$encoding", $fileName)) {
		$oldContents = $contents;
		my $length = length $oldContents;
		print FH $oldContents;
		close(FH);
		if ($readOnly) {
		    $text->configure(-state => 'normal');	# new writable file
		    $readOnly = '';				# can modify text
		}
		## read last modified time from new stat now as it changed since last stat and :encoding()
		$fileTime = (stat($fileName))[9]; $fileTime = 0 unless defined $fileTime;
		$mainWindow->title("$named$u: $fileName$readOnly $runName");
		if (-f "$fileName.bak") {
		    info_display(2000, 'black', "File $fileName$readOnly, $length bytes saved (backup $fileName.bak)");
		} else {
		    info_display(2000, 'black', "File $fileName$readOnly, $length bytes saved");
		}
		if ($fileName =~m/^\w+\.ica?$/) {
		    check_menu($fileName, 'files');		# save files with extensions .ic or .ica in file menu
		}
	    } else {
		info_display(2000, 'red', "ERROR: Could not open '$fileName$readOnly' for writing");
		$ret = 0;	# error return
	    }
	} else {
	    info_display(2000, 'blue', "File '$fileName$readOnly' has not changed - not written");
	}
    } else {
	$ret = saveAs_file();
    }
    return $ret;
} # save_file

########################################################################
#
#	Save file to suggested $fileName or to another selected Name
#		return:		1  file successfully saved, instance is reset
#				0  failure - $fileName not changed
#	$fileName is assigned new Name if successfully saved
#
########################################################################

sub saveAs_file {
    my $ret = 1;
    my $oldName = $fileName;
    $fileName = $mainWindow->getSaveFile(-filetypes => $fileTypes,
					 -initialfile => $fileName);
    if (defined $fileName and $fileName ne '') {
	if ($fileName ne $oldName) {
	    my $ftime = (stat($fileName))[9]; $ftime = $fileTime unless defined $ftime;
	    ## allow non existing file to be written by setting to $fileTime if undef
	    $fileTime = $ftime;
	}
	$fileName =~ s#^C:/cygwin## or $fileName =~ s#^([A-Z]):#/cygdrive/\l$1#;
	$fileName =~ s#^$cwd/##;
	print "saveAs_file: $fileName\n" if $opt_T;
	if (save_file(0, $fileName ne $oldName) == 0) {
	    ## could not save $fileName
	    $fileName = $oldName;	# restore fileName
	    $mainWindow->title("$named$u: $fileName$readOnly $runName");
	    $ret = 0;
	} elsif ($fileName ne $oldName) {
	    ########################################################################
	    #  Set global $processName, $pathName, $procName and $extName here using
	    #  $cascName if it is set.
	    #  They are used in run_file() and build_file()
	    #  Only other change is in saveAs_file() when $fileName is changed.
	    ########################################################################
	    my $m = $fileName =~ m/^((([\w\.\$]*[\\\/])*)([\w\.\$]+))\.(\w+)$/;
	    ($processName, $pathName, $procName, $extnName) = ($1, $2, $4, $5);	# used globally
	    my $baseName = $procName;	# for display switching
	    $cascName = '';			# new file name
	    if ($processName eq $procName) {
		$processName = "./$procName";	# in case . is not in $PATH
		$pathName    = "";
	    }
	    $mainWindow->title("$named$u: $fileName$readOnly $runName");
	    if ($m and $extnName =~ m/^(i[ch]a?|lst6?|c|h|ini)$/) {
		if ($extnName eq "ic") {
		    $menuFile->entryconfigure(4, -label => "$baseName.lst");
		} elsif ($extnName eq "ica") {
		    $menuFile->entryconfigure(4, -label => "$baseName.ic");
		} elsif (-w "$baseName.ica") {
		    $menuFile->entryconfigure(4, -label => "$baseName.ica");
		} else {
		    $menuFile->entryconfigure(4, -label => "$baseName.ic");
		}
		my $no = 0;
		unless ($no) {
		    $instName = "$procName$instanceText";	# previous executable was stopped or is compatible
		    change_instance();
		    adjust_live(-1, -1);
		}
	    }
	    $prevText = '';					# start a new search
	    $gl = 0;
	    tagDeleteRestore_searchTag();
	}
    } else {
	info_display(2000, 'red', "no file saved");
	$fileName = $oldName;	# restore fileName
	$ret = 0;
    }
    return $ret;
} # saveAs_file

########################################################################
#
#	Build a target file generated from $fileName (C file or executable)
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate a new target file if target is older than $fileName
#	or unconditional build was specified.
#
#	2nd parameter:	0   Build executable
#			1   Save & Build unconditionally
#			2   Build C file only
#
########################################################################

sub build_file {
    my $par2 = $_[1];
    my $saved = 0;
    if ($fileName !~ /(^[\w\.\\\/]+)\.ica?/) {
	info_display(2000, 'blue', "WARNING: cannot build '$fileName$readOnly' (must end in .ic or .ica)");
    } else {
	my $baseName = $1;
	my $buildName = "$fileName$readOnly";	# $fileName will change in open_file() if error
	my $targetName = $par2 == 2 ? "$baseName.c" : $cascName ? $procName : $baseName;
	deleteAllTags();		# also clears @activeSymbols
	reset_scan(1);			# must be done before save_file, because live expands text
	if ($par2 == 1) {
	    $saved = save_file(0, 1);	# save unconditionally
	} else {
	    $saved = check_save();
	    info_display(2000, 'dark green', "'$targetName' was not saved - no new build") if $saved < 0;
	}
	if ($saved > 0) {
	    my $ftime = (stat($fileName))[9]; $ftime = 0 unless defined $ftime;
	    my $mtime = (stat($targetName))[9]; $mtime = 0 unless defined $mtime;
	    my $ret = 0;
	    if ($par2 == 1 or $mtime < $ftime) {
		## system() requires signal CHLD to notify completion
		$SIG{CHLD} = 'DEFAULT';
		my @args = ("iCmake", "-fsd200");
		if ($par2 != 2) {		# link with static (debug) library - generate // x =
		    my $lib;
		    foreach $lib (@opt_L) {
			push(@args, '-L', $lib);	# add BUILD library options
		    }
		} else {			# $par2 == 2 - Build C file only
		    push(@args, '-b');		# iCmake -b to suppress making executable
		}
		my $i = 0;
		if ($cascName) {
		    push(@args, '-o', $processName);
		    foreach my $file (@{ $iniNames{$cascName} }) {
			if ($file =~ m/\.ica?$/) {
			    push(@args, $file);
			    $i++;
			}
		    }
		} else {
		    push(@args, "-A", $fileName);
		    $i++;
		}
		push(@args, "2>&1");
		unless ($i) {
		    print STDERR "Error: nothing to build with @args\n";
		    info_display(2000, 'red', "nothing to build with @args");
		    return;
		}
		print STDERR "\$ @args\n" unless $opt_q;
		my @errText = qx(@args);	# execute iCmake ...
		$ret = $? >> 8;
		my $len = @errText;
		my $gr = grep /^\*\*\* /, @errText;
		print "ret = $ret, len = $len, *** = $gr\n" if $opt_T;
		print STDERR @errText;
		$SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
		if ($ret or $gr) {
		    select undef, undef, undef, 2;	# sleep for 2 seconds
		    ########################################################################
		    #  show errors in generated .ic file (immac) or .lst file (immcc)
		    #  iCmake += 20 for immac errors : += 1 for immcc errors
		    ########################################################################
		    my $listName = $ret >= 20 ? "$baseName.ic" : "$baseName.lst";
		    open_file(0, $listName);	# load the generated file (iC is up to date)
		    $searchText = '^\*\*\* ';	# regular expression to find errors in listing
		    $prevText = '';		# start a new search
		    $gl = 0;
		    tagDeleteRestore_searchTag();
		    $matchType = '-regexp';	# NOTE: $fileName has changed
		    search_now(1, undef, 4);	# carry out the search, setting markers but no info display
		}
		if ($ret) {
		    info_display(2000, 'red',
			"ERROR: '$targetName' cannot be built from '$buildName' (return = $ret)");
		    warn "ERROR: '$targetName' cannot be built from '$buildName' (return = $ret)\n";
		} else {
		    if ($runName ne '') {
			$makeName = $targetName;# running process is not current build
		    }
		    my $build_warnings;
		    if ($gr) {
			$build_warnings = "built with $gr Warnings - can be run";
			warn "WARNING: '$targetName' $build_warnings\n";
			$build_warnings .= " after pressing Alt-l";
		    } else {
			$build_warnings = "sucessfully built";
		    }
		    info_display(2000, 'dark green', "'$targetName' $build_warnings");
		}
	    } elsif ($ftime == 0) {
		info_display(2000, 'red', "'$targetName' norhing to build");
	    } else {
		info_display(2000, 'blue', "'$targetName' is up to date");
	    }
	} # ELSE operation was cancelled by check_save() or file could not be saved
    }
} # build_file

########################################################################
#
#	Start a new search with / or ALT-/ to simulate vi
#
########################################################################

sub new_search {
    print "new_search\n" if $opt_T;
    $searchText = '';		# clears search entry window
    search_text(0, '', 0);	# puts focus in search entry window
} # new_search

########################################################################
#
#	Scroll text left or right with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_x_text {
    my ($dummy, $increment) = @_;
    print "scroll_x increment = '$increment'\n" if $opt_T;
    $text->xview('scroll', $increment, 'units');
    adjust_live();
} # scroll_x_text

########################################################################
#
#	Scroll text up or down with keys
#	even if other windows have the focus
#
########################################################################

sub scroll_text {
    my ($dummy, $increment) = @_;
    print "scroll increment = '$increment'\n" if $opt_T;
    $text->yview('scroll', $increment, 'units');
    adjust_live();
} # scroll_text

########################################################################
#
#	Position text Home or End
#
########################################################################

sub position_text {
    my ($dummy, $position) = @_;
    print "scroll position = '$position'\n" if $opt_T;
    $text->see($position);
    adjust_live();
} # position_text

########################################################################
#
#	Increase or decrease font size
#
#	change normal text font (includes underline text)
#	change 'bd' and 'er' tagged words which are bold
#	do not change miscellanous button text fonts
#
########################################################################

sub change_font {
    my ($dummy, $increment) = @_;
    $fontSize += $increment;			# initial or new fontSize
    if ($fontSize < 8 || $fontSize > 22) {
	$fontSize -= $increment;		# keep fontSize within limits
    } else {
	print "font increment = '$increment' size = '$fontSize'\n" if $opt_T;
	$font       = $font_t;
	$boldfont   = $boldfont_t;
	$italicfont = $italicfont_t;
	$bolditfont = $bolditfont_t;
	$font       =~ s/fontSize/$fontSize/;	# no change if -F was a specified font
	$boldfont   =~ s/fontSize/$fontSize/;
	$italicfont =~ s/fontSize/$fontSize/;
	$bolditfont =~ s/fontSize/$fontSize/;
	if ($increment) {
	    $text->configure(-font => $font);	# re-configure only for changed fonts
	    $text->tagConfigure('bd',  -font => $boldfont);
	    $text->tagConfigure('er',  -font => $boldfont, -background => 'red');
	    $text->tagConfigure('cv', -relief => 'raised', -borderwidth => 3, -font => $boldfont);
	    $text->tagConfigure('it',  -font => $italicfont);
	    $text->tagConfigure('bt',  -font => $bolditfont);
	    info_display(0, 'black', "font size $fontSize");
	}
    }
} # change_font

########################################################################
#
#	Fork a new process - ignore CHLD signal
#	Parameters: call + arguments
#
########################################################################

sub fork_and_exec {
    ## ignore CHLD signal of processes forked
    $SIG{CHLD} = 'IGNORE';		# process can stop without becoming a zombie
    my $pid;
    FORK: {
	if ($pid = fork) {
	    ## parent process
	    select undef, undef, undef, 0.2;	# wait for control program to be activated as child process
	} elsif (defined $pid) {	# $pid is zero if defined
	    print STDERR "\$ @_ &\n" unless $opt_q;
	    ## dispatch child process
	    exec @_;			# does not return unless exec failure
	    warn "forked child process exited - failure exec '@_'\n";
	    exec ("$named", '-X');	# cleanly exit overlay child process
	} elsif ($! =~ /No more process/) {
	    ## EAGAIN, recoverable fork error
	    select undef, undef, undef, 5;
	    redo FORK;
	} else {
	    ## weird fork error
	    die "Can't fork: $!\n";
	}
    }
} # fork_and_exec

########################################################################
#
#	Fork to the help process
#
########################################################################

sub fork_help {
    fork_and_exec('iCman', '-n', $named);
} # fork_help

########################################################################
#
#	Stop or run the executable file generated from $fileName
#	check if $fileName is an iC source (*.ic) and needs saving
#	generate name of executable file from $fileName
#	run executable if it exists, is executable and newer than source
#
########################################################################

sub run_file {
    my $m;
    if ($runName ne '') {
	## running - stop application
	stop_file();
    } elsif ($extnName ne 'ic' or check_save()) {
	deleteAllTags();		# also clears @activeSymbols
	clear_scan(1);
	print "run_file: $processName from $fileName\n" if $opt_T;
	my $ftime = (stat($fileName))[9];
	my $mtime = (stat($processName))[9];
	if (not -f _) {
	    info_display(2000, 'red', "ERROR: no file named '$processName' (Build it first)");
	} elsif (not -x _) {
	    info_display(2000, 'red', "ERROR: '$processName' not executable ??");
	} elsif ($mtime < $ftime) {
	    info_display(2000, 'blue', "WARNING: '$processName' is older than '$fileName$readOnly' (Build again)");
	} else {
	    $instName = "$procName$instanceText";
	    print "$named: register_at_server before fork_and_exec '$processName'\n" if $opt_T;
	    register_at_server();	# in case newly started
	    ## generate the call
	    $makeName = '';	# up to date build is running (unless deliberate No save)
	    my @call = ($processName);
	    splice @call, 1, 0, "-s", $opt_s if defined $opt_s;
	    splice @call, 1, 0, "-p", $opt_p if defined $opt_p;
	    splice @call, 1, 0, "-tq" if defined $opt_t or $traceDebV;
	    splice @call, 1, 0, "-d$opt_d" if defined $opt_d;
	    splice @call, 1, 0, "-m" if defined $opt_m or $microSecV;
	    splice @call, 1, 0, "-i$instance" if (defined $instance and $instance ne '');
	    splice @call, 1, 0, "-d1000";	# do not trace non-active timers TX0.n
	    splice @call, 1, 0, "-q" if $opt_q;	# allow user to control and stop app (no -z)
	    print "@call\n" if $opt_T;
	    ## fork and exec the call
	    fork_and_exec(@call);	# if application starts it will send back <ch>:2;<name>
	}
    } # ELSE operation was cancelled by check_save()
} # run_file

########################################################################
#
#	Stop the control program if connected
#
########################################################################

sub stop_file {
    info_display(2000, 'blue', "'$runName' stopping");
    if ($scanFlag) {
	sendDebug(0, 'D');			# debug mode off
	conn_send_now("$D_channel:5");		# GET_END - clear S.T.
	$liveButton->configure(-text => 'wait');	# was 'Edit'
	print "$named: stop_file 'wait'\n" if $opt_T;
    }				# leave scanButton as 'Edit' if not $scanFlag
    $server = 0;
    conn_send_now("$D_channel:6,$D_channel:0");	# STOP_PROGRAM
    # receives "$C_channel:5" from application when it quits - sets 'Run ' then
} # stop_file

########################################################################
#
#	Change instance selection
#
########################################################################

sub change_instance {
    if ($instName ne $regName or $oldInstance ne $instanceText) {
	print "$named: change_instance from '$oldInstance' to '$instanceText'\n" if $opt_T;
	$instName = "$procName$instanceText";
	print "$named: from regName '$regName' to instName '$instName'\n" if $opt_T;
	if ($scanFlag) {
	    sendDebug(0, 'D');			# debug mode off
	    $liveButton->configure(-text => 'wait');
	    print "$named: change_instance scan to 'wait'\n" if $opt_T;
	}
	register_at_server();
	####################################################
	## change text on run button to 'Run '
	####################################################
	$menuRun->configure(-text => 'Run ');
	$menuBuild->entryconfigure(5, -state => 'disabled');	# Symbol Table by name
	$menuBuild->entryconfigure(6, -state => 'disabled');	# Symbol Table by index
	$menuBuild->entryconfigure(7, -state => 'disabled');	# iCserver Client Tables
	$runName = '';		# if :2 is received will change back to <name>
	$mainWindow->title("$named$u: $fileName$readOnly");
	print "$named: change_instance 'Run '\n" if $opt_T;
	$oldInstance = $instanceText;
	return 1;
    }
    return 0;
} # change_instance

########################################################################
#
#	Auxiliary subroutine for splitFiles() to push $fileName and $procName
#	This routine avoids pushing duplicate names.
#
########################################################################

sub pushNamesProcs {
    my ($fName, $pName) = @_;
    foreach my $file (@{ $iniNames{$pName} }) {
	goto fileFound if $file eq $fName;	# don't push $fName twice
    }
    push @{ $iniNames{$pName} }, $fName;
  fileFound:
    foreach my $proc (@{ $iniProcs{$fName} }) {
	goto procFound if $proc eq $pName;	# don't push $pName twice
    }
    push @{ $iniProcs{$fName} }, $pName;
  procFound:;
    return $fName;
} # pushNamesProcs

########################################################################
#
#	splitFiles() breaks up comma separated lists of process and filenames
#	and builds the hashes %$iniNames and %iniProcs used later to
#	populate the file menu and check file dependencies.
#
########################################################################

sub splitFiles {
no warnings;
    my ($fileList) = @_;
    my ($pName, $fName);
    my $fileName = '';
    my ($word, $rest) = split /,/, $fileList, 2;
    if ($word =~ m/^([\/\w]+)(\.ica?)?$/) {
	$pName = $1;
	if ($2) {
	    $fileName = $word;		# word ends in .ic or .ica
	} elsif (not $rest) {
	    my $firstName = ${ $iniNames{$pName} }[0];
	    if ($firstName) {
		$fileName = $firstName;
	    } else {
		$fileName = "$pName.ic";
	    }
	}
	if ($fileName) {
	    $fileName = pushNamesProcs($fileName, $pName);
	}
	if ($rest) {
	    foreach $fName (split /,/, $rest) {
		if ($fName =~ m/^\w+\.i[ch]a?$/) {
		    pushNamesProcs($fName, $pName);
		} else {
		    print STDERR "Error: '$fName' not an iC or iCa filename\n";
		    $fileName = $fName;
		}
	    }
	}
	if ($opt_T) {
	    print "splitFiles: iniNames\n";
	    foreach my $pN (keys %iniNames) {
		print "    $pN: @{ $iniNames{$pN} }\n";
	    }
	    print "splitFiles: iniProcs\n";
	    foreach my $fN (keys %iniProcs) {
		print "    $fN: @{ $iniProcs{$fN} }\n";
	    }
	}
	unless ($fileName) {
	    $fileName = ${ $iniNames{$pName} }[0]	# first file name in iniNames for this proc
	}
    } elsif ($word) {
	print STDERR "Error: '$word' not an iC or iCa filename - no menu entry\n";
    }
    return ($fileName, $pName);
use warnings;
} # splitFiles

########################################################################
#
#	check_menu (newEntry, menuKey[, delete])
#	Enter a new value into a particular menu
#	    iniMenuData{menuKey} ==> [
#		menuRef,	# [0]
#		entriesArray,	# [1]
#		menuPos,	# [2]
#		entriesLim,	# [3]
#		commandRef,	# [4]
#	    ]
#	'newEntry' is appended to (or moved to the bottom of) the 'menuKey' menu
#	when 'delete' is set, 'newEntry' in the menu is deleted and not replaced
#
#	Maintain local arrays @dynamicFiles and @dynamicSearches to map a regular
#	expression index pattern to a positional number, which can be used to
#	index menu entries with a numerical index. Entries in these local arrays
#	are always pushed on the end for new entries, shifted from the front to
#	delete the oldest entry, or spliced out to delete a previous entry from
#	the middle. A linear search in these arrays must be used to locate old
#	entries. A hash is not suitable, because several entries change their
#	numerical index every time an old entry is spliced out of the middle or
#	shifted from the front.  But since the number of entries (entriesLim) is
#	limited, this is not a serious drawback. These arrays, which are accessed
#	from 'iniMenuData' via 'entriesArray' parallels the arrays used internally
#	by the Tk menu system can be used to count and locate the numerical index
#	of dynamic menu entries.
#
########################################################################

sub check_menu {
    my ($newEntry, $menuKey, $delete) = @_;
    my $menuData = $iniMenuData{$menuKey};
    my ($menuRef, $entriesArray, $menuPos, $entriesLim, $commandRef) = @$menuData;
    my ($firstName, $baseName, $pName);

    if ($menuKey eq 'files') {
	########################################################################
	#  Reconstitute $newEntry
	########################################################################
	if ($cascName) {
	    $newEntry = $baseName = $cascName;
	} else {
	    ($firstName, $pName) = splitFiles($newEntry);
	    if ($firstName) {
		if ($firstName =~ m/^(\w+)\.ica?$/) {
		    $baseName = $1;		# base name
		    if ($pName eq $baseName and scalar @{ $iniNames{$pName} } == 1) {
			$newEntry = $firstName;	# non-cascade menu entry
			if (scalar @{ $iniProcs{$newEntry} } > 1 and not -w $pName) {
			    $delete = 1;	# delete iC file used in another cascade group and not built
			}
			$baseName = '';
		    } else {
			$newEntry = $pName;
		    }
		}
	    } else {
		return;			# no menu entry for this file
	    }
	}
    }
    my ($e, $g);
    my $n = 0;
    foreach $e (@$entriesArray) {
	if ($e) {
	    if ($e eq $newEntry) {		# find newEntry in entriesArray
		$g = splice(@$entriesArray, $n, 1);	# remove from middle of entriesArray
		die "entry '$g' in entriesArray does not match call parameter '$newEntry', stopped" if $g ne $newEntry;
		my $label = $menuRef->entrycget($menuPos+$n, '-label');	# check algorithm
		die "entry '$g' in entriesArray does not match menu entry '$label', stopped" if $g ne $label;
		print "check_menu: [$menuKey] '$g' removed from position $n of menu\n" if $opt_T;
		$menuRef->delete($menuPos+$n) if $menuRef;	# delete old entry from menu
		last;				# avoids indexing with a pattern, which fails
	    } elsif ($menuKey eq 'files' and $baseName eq $newEntry and "$baseName.ic" eq $e and exists $iniProcs{$e}) {
		# delete duplicate source file - continue scan of @$entriesArray
		$g = splice(@$entriesArray, $n, 1);	# remove from middle of entriesArray
		die "entry '$g' in entriesArray does not match call parameter '$e', stopped" if $g ne $e;
		my $label = $menuRef->entrycget($menuPos+$n, '-label');	# check algorithm
		die "entry '$g' in entriesArray does not match menu entry '$label', stopped" if $g ne $label;
		print "check_menu: [$menuKey] '$g' removed from position $n of menu\n" if $opt_T;
		$menuRef->delete($menuPos+$n) if $menuRef;	# delete old entry from menu
	    }
	}
	$n++;
    }
    if ($delete) {
	print "check_menu: [$menuKey] '$newEntry' deleted\n" if $opt_T;
    } else {
	print "check_menu: [$menuKey] '$newEntry' added\n" if $opt_T;
	push(@$entriesArray, $newEntry);	# add to end of entriesArray unless deleted
	if ($menuRef and $commandRef) {		# menu for 'file' and 'searches' not 'last open file'
	    if ($baseName) {
		my $cascade = $menuRef->cascade(-label   => "$newEntry",
					        -tearoff => 0,
						-postcommand => sub {
						    $cName = $newEntry;
						});
		foreach my $fName (@{ $iniNames{$newEntry} }) {
		    $cascade->command(-label   => "$fName",	# open(file(3, $fName) uses i$cascName = $cName
				      -command => [ $commandRef, 3, $fName ]);	# open_file(3, $fName) only
		}
	    } else {				# also $menuKey ne 'files'
		$menuRef->command(-label   => "$newEntry",	# open(file(2, newEntry) resets $cascName = ''
				  -command => [ $commandRef, 2, $newEntry, 0 ]); # 0 down for search_text_text()
	    }
	    if (scalar @$entriesArray > $entriesLim) {
		$e = shift(@$entriesArray);	# remove first entry in entriesArray
		print "check_menu: [$menuKey] '$e' removed from front of menu\n" if $opt_T;
		$menuRef->delete($menuPos);	# remove first dynamic menu entry
	    }
	}
    }
} # check_menu

########################################################################
#
#	Initialise the program by reading ~/.iC/iClive.ini if it exists
#	and initialising file list and search list in menus
#	IF there are no file arguments, open the last open file
#	ELSE	open the first file in the argument list
#		add any others to the file menu list
#
#	structure of ~/.iC/iClive.ini
#	[files]
#		sort5.ic		# build sort5 with iCmake -sA sort5.ic
#		sort sort6.ic timer.ic	# build sort with iCmake -o sort -l sort6.ic timer.ic
#		sort7.ic sort7.lst	# when viewing listing file, add it to the group
#		/tmp/trial.ic
#	[last open file]
#		sort5.ic		# last open file
#		27.4			# line #
#		1			# instance
#	[searches]
#		Timer			# default match type is w (Word)
#					# searches \bTimer\b - ignores Timer_1
#		timer		i	# match type -nocase (<tab>i)
#					# matches timer and Timer - ignores Timer_1
#		pip		e	# match type -exact  (<tab>e)
#					# matches pip pip_1 - even Apip1
#		Pip		ei	# match type -exact  (<tab>ei)
#					# matches Pip pip pip_1 - even Apip1
#		[files]		e	# a curious -exact match
#		QX[\d+]\.[\d+]	r	# match type -regexp (<tab>r)
#		qx[\d+]\.[\d+]	ri	# match type -regexp (<tab>ri)
#		75		g	# goto line 75       (<tab>g)
#
#	since tabs cannot be entered in the search entry box (skips to Text window)
#	use <tab> followed by search option in the search menu list
#	also precede each ini item by <tab>, since [files] may be a
#	legitimate search expression (watch Goedel here)
#
########################################################################

sub ini_program {
    my ($menuData, $menuKey, $entry, $initialFile, $position, $home, $fName, $pName);
    ## restore file and search menu lists from ~/.iC/iClive.ini
    if (($home = $ENV{HOME}) ne '' and
	(-d "$home/.iC") and
	open(INI, "$home/.iC/$named.ini")) {
	while (<INI>) {
	    chomp;
	    if (/^\[([\w ]+)\]$/) {
		$menuKey = $1;			# key found
		$menuData = $iniMenuData{$menuKey};
		print "ini_program: menuKey [$menuKey] found\n" if $opt_T;
	    } elsif ($menuData and s/^\t(.*)$/$1/) {	# ini starts with <tab>
		$entry = $_;
		check_menu($entry, $menuKey);	# insert dynamic entries from ini file
	    }
	}
	close(INI);
    }	# ignore if ~/.iC/iClive.ini cannot be opened or found
    $entry = '';
    $initialFile = shift @argv;			# ARGV may be empty
    unless ($initialFile and $initialFile ne '') {
	($initialFile, $position, $entry) = @lastFile;
	if (not defined $entry and defined $position and $position =~ /^\d+$/) {
	    $entry = $position;
	}
	if (defined $position and $position !~ /^\d+\.\d+$/) {
	    $position = undef;
	}
	if (defined $initialFile and not defined $opt_i) {
	    $instance = $entry;
	    if (defined $instance and $instance ne '') {
		$instanceText = "-$instance";
		if ($instance !~ /^[0-9]$/) {
		    push @instanceOptions, [$instanceText, $instance];
		    $menuInst->configure(-options => \@instanceOptions);
		}
	    }
	}
    }
no warnings;
    print "initialFile = '$initialFile' position = '$position' instance '$entry'\n" if $opt_T;
use warnings;
    check_menu($initialFile, 'files');		# initial command line argument
    foreach $fName (@argv) {
	check_menu($fName, 'files');		# remaining command line arguments
    }
    ########################################################################
    #  When all arguments have been processed, scan all source files in
    #  %iniProcs for %include "xxx.ih" in .ic files
    #  and %%include "yyy.iha" in .ica files.
    #  Push any xxx.ih or yyy.iha to all $iniNames{$procs} for all
    #  $procs = $iniProcs{$fileName} just scanned and push
    #  same array $iniProcs{$fileName} for each include file name found.
    ################ma########################################################
    foreach $fName (keys %iniProcs) {
	if (-f $fName and
	    open(INI, $fName)) {
	    while (<INI>) {
		chomp;
		if (m/^\s*%%?include\s+"([\w.\/\\]+)"/) {
		    foreach $pName (@{ $iniProcs{$fName} }) {
			pushNamesProcs($1, $pName);
		    }
		}
	    }
	    close(INI);
	}
    }
    ########################################################################
    #  Open initial file if it exists - else delete name from the file menu
    #                                  in check_menu() in open_file()
    ########################################################################
    ($fName, $pName) = splitFiles($initialFile);
    if ($fName) {
	if (("$pName.ic" eq $fName or "$pName.ica" eq $fName) and scalar @{ $iniNames{$pName} } == 1) {
	    $cascName = '';			# pretend simple menu option selected
	} else {
	    $cascName = $pName;			# pretend first cascade menu option selected
	}
	open_file(0, $fName);			# calls check_menu() for $initialFile
    }
    if (defined $position and $position ne '' and $position ne "1.0") {
	$text->see($position);			# Tk has segmentation fault if $position eq ''
	## grey out the whole line - until mouse moves
	$text->tagAdd('sel', "$position linestart", "$position lineend");
    } else {
	$position = "1.0";
    }
    $text->markSet('insert', $position);
    if ($opt_T) {
	print "ini_program: iniNames\n";
	foreach $pName (keys %iniNames) {
	    print "    $pName: @{ $iniNames{$pName} }\n";
	}
	print "ini_program: iniProcs\n";
	foreach $fName (keys %iniProcs) {
	    print "    $fName: @{ $iniProcs{$fName} }\n";
	}
    }
} # ini_program

########################################################################
#
#	Quit program after checking if file needs saving.
#	If debug mode is set clear all watch points and exit debug mode.
#	Save file list and search menu list for next start.
#
#	Care has been taken, that the hash indices $fileName, $position
#	and $instance can never be the same - they have different signatures
#		$fileName	\w+\.(ic|lst|c|h)
#		$position	\d+\.\d+
#		$instance	\d+
#	It is of course possible to fudge a filename like "0", which clashes
#	with instance 0. But "0" should be the executable built from "0.ic".
#
########################################################################

sub quit_program {
    my ($menuKey, $entriesArray, $entry, $home);
    my ($firstName, $baseName, $fName);
    deleteAllTags();	# also clears @activeSymbols
    clear_scan();
    if (check_save()) {
	reset_scan();		# also turn debug mode off and clear set/next/watch points
	@lastFile = ();		# in case not fully shifted in ini_program due to $opt_i
	if (defined $fileName and $fileName ne $unknown and $fileName ne '') {
	    my $m;
	    if ($cascName) {
		$fileName = $cascName;
	    } else {
		$m = $fileName =~ m/^((([\w\.\$]*[\\\/])*)([\w\.\$]+))\.(\w+)$/;
		($processName, $pathName, $procName, $extnName) = ($1, $2, $4, $5);
	    }
	    if ($m and $extnName !~ m/ica?$/) {
		if (-w "$processName.ica") {
		    $fileName = "$processName.ica";
		} elsif (-w "$processName.ic") {
		    $fileName = "$processName.ic";
		} else {
		    goto noLastFile;
		}
		push(@lastFile, ($fileName, "1:0"));
	      noLastFile:;
	    } else {
		push(@lastFile, ($fileName, $cascName ? "1.0" : $text->index('insert')));
		if (defined $instance and $instance ne '') {
		    push(@lastFile, $instance);
		}
	    }
	}
	## save file and search menu lists to ~/.iC/iClive.ini
	if (($home = $ENV{HOME}) ne '' and
	    (-d "$home/.iC" or mkdir "$home/.iC") and
	    open(INI, ">$home/.iC/$named.ini")) {
	    foreach $menuKey (sort keys %iniMenuData) {
		print INI "[$menuKey]\n";
		print "INI: [$menuKey]\n" if $opt_T;
		$entriesArray = @{ $iniMenuData{$menuKey} }[1];	# entriesArray
		foreach $entry (@$entriesArray) {
		    if (defined $entry and $entry ne '') {
			if ($menuKey ne 'searches' and ($firstName = ${ $iniNames{$entry} }[0])) {
			    if ($firstName and $firstName =~ m/(\w+)\.i[ch]a?/) {
				$baseName = $1;		# base name
				if ($entry eq $baseName and scalar @{ $iniNames{$entry} } == 1) {
				    print INI "\t$firstName\n";
				    print "INI:	$firstName\n" if $opt_T;
				} else {
				    foreach $fName (@{ $iniNames{$entry} }) {
					$entry .= ",$fName";
				    }
				    print INI "\t$entry\n";
				    print "INI:	$entry\n" if $opt_T;
				}
			    } else {
				print STDERR "Error: \n";
			    }
			} else {
			    print INI "\t$entry\n";
			    print "INI:	$entry\n" if $opt_T;
			}
		    }
		}
	    }
	    close(INI);
	} else {
	    warn "ERROR: Can't open ~/.iC/$named.ini: $!\n";
	}
	print "$named: quit\n" if $opt_T;
	if ($server == 1) {
	    print "quit_program() sends 'X$named'\n" if $opt_T;
	    conn_send_now("X$named") if $conn;	# iClive started iCserver - stop it
	} elsif ($runName ne '') {
	    print "quit_program() sends '$D_channel:7,$D_channel:0'\n" if $opt_T;
	    conn_send_now("$D_channel:7,$D_channel:0");
	    ####################################################
	    ## causes application to send C_channel:2;<name>
	    ## is available in iCserver for next iClive start
	    ####################################################
	}
	print "quit_program() \$maindWindow->destroy()\n" if $opt_T;
	$dbW->Exit() if Exists $dbW;		# if any of these windows Show causes
	$dbB->Exit() if Exists $dbB;		# Tk::error "WM_DELETE_WINDOW" window manager protocol
	$dbL->Exit() if Exists $dbL;		# when $mainWindow is destroyed
	$mainWindow->destroy();
	print "quit_program() exit\n" if $opt_T;
	conn_send_now("") if $conn;		# disconnect app at iCserver
	exit;
    }
    ## continue if check_save() was cancelled
} # quit_program

########################################################################
#
#	Compute and print elapsed microseconds (activated by $opt_m)
#
########################################################################

sub printMicroSeconds {
    if ($opt_m) {
	my ($string) = @_;
	my ($sec, $usec);
	my $t1 = [gettimeofday()];
	$sec =  $t1->[0] - $t0->[0];
	$usec = $t1->[1] - $t0->[1];
	if ($usec < 0) {
	    $sec--;
	    $usec += 1000000;
	}
	if ($opt_t and not $opt_q) {
	    printf "D%3d.%03d,%03d: %s:", $sec, int($usec/1000), $usec%1000, $string;
	} else {
	    printf "D%3d.%03d,%03d %s\n", $sec, int($usec/1000), $usec%1000, $string;
	}
    } elsif ($opt_t and not $opt_q) {
	print "D: ";
    }
    $t0 = [gettimeofday()];
} # printMicroSeconds

########################################################################
#
#	Output Symbol Table for debugging purposes
#	called by extra Build menu items activated by $opt_T
#	or keyboard T command here or at app.
#
#	parameter 1	(ignore)
#	parameter 2	sorting order: 0 by name	1 by index
#
########################################################################

sub output_symbol_table {
    my $par2 = $_[1];
    if ($runName ne '') {
	my ($symbol, $index, $previndex);
	$previndex = -1;
	if ($par2 == 0) {
	    print "\nSymbol Table '$runName' by name\n";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    printf "%2s %-*s %4s\n", "ft", $maxSymbolLength, " name", "ix ";
	    print "-- ", "-" x $maxSymbolLength, " ----\n";
	    foreach $symbol (sort keys %symbolTable) {
		printf "%2s %-*s %4d\n",
		    $abbrevSelect[$symbolTable{$symbol}[0]],
		    $maxSymbolLength, $symbol,
		    $symbolTable{$symbol}[1];
	    }
	}
	elsif ($par2 == 1) {
	    print "\nSymbol Table '$runName' by index\n";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength, "\n";
	    printf "%4s %2s %-*s %2s %-*s .. ...\n", "ix ",
		"ft", $maxSymbolLength, " name",
		"ft", $maxSymbolLength, " name";
	    print "---- -- ", "-" x $maxSymbolLength, " -- ", "-" x $maxSymbolLength;
	    foreach $symbol (sort {
				$symbolTable{$a}[1] <=> $symbolTable{$b}[1]
				||
				$a cmp $b
			    } keys %symbolTable)
	    {
		$index = $symbolTable{$symbol}[1];
		if ($index != $previndex) {
		    printf "\n%4d %2s %-*s", $index,
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		    $previndex = $index;
		} else {
		    printf " %2s %-*s",
			$abbrevSelect[$symbolTable{$symbol}[0]],
			$maxSymbolLength, $symbol;
		}
	    }
	    print "\n";
	}
    } else {
	info_display(2000, 'red', "No Symbol Table - not connected to a running control program");
    }
} # output_symbol_table

########################################################################
#
#	Write to the temporary buffer /tmp/vim_buffer for transfer
#	between text windows with function key <F2>
#
#	This function allows transferring selections of whole lines
#	between 'iClive' and 'vim' if 'map <S-F2> :r /tmp/vim_buffer<CR>'
#	for reading  /tmp/vim_buffer is part of .exrc
#
#	If no lines are selected the whole text is written
#
#	John Wulff's 'Super-Stutter-Sequences' map both <S-F2> and <F2>
#	plus many interesting :ab abbreviations for fast program entry
#
########################################################################

sub function2 {
    if (open(FH, ">$encoding", "/tmp/vim_buffer")) {
	my ($sel, $line, $lineCount);
	if ($text->tagRanges('sel')) {
	    $sel = $text->getSelected;			# get selection only
	} else {
	    $sel = $text->get("1.0", "end - 1 chars");	# no selection - get whole text
	}
	my @arrayContents = split "\n", $sel;
	if ($extnName eq "lst") {
	    print FH "$sel";				# output selection without line numbers
	    $lineCount = scalar @arrayContents;
	} else {
	    $lineCount = 0;				# selection with line numbers
	    foreach $line (@arrayContents) {
		$line =~ s/^ +\d+\t//;			# remove line number
		print FH "$line\n";			# output selection line without line numbers
		$lineCount++;
	    }
	}
	info_display(0, 'black', "$lineCount lines written to /tmp/vim_buffer");
	print "function2: lineCount = $lineCount\n" if $opt_T;
	close(FH);
    } else {
	info_display(0, 'red', "cannot open /tmp/vim_buffer for writing");
    }
} # function2

########################################################################
#
#	Read from the temporary buffer /tmp/vim_buffer for transfer
#	between text windows with function key <Shift-F2>
#
#	This function allows transferring selections of whole lines
#	between 'vim' and 'iClive' if 'map <F2> :w! /tmp/vim_buffer<CR>'
#	for writing /tmp/vim_buffer is part of .exrc
#
########################################################################

sub functionS2 {
    if (open(FH, "<$encoding", "/tmp/vim_buffer")) {
	local $/ = undef;				# no input separator
	my $sel = <FH>;					# slurp whole /tmp/vim_buffer
	my @arrayContents = split "\n", $sel;
	my $lineCount = scalar @arrayContents;
	$text->insert("insert linestart + 1 lines", $sel);
	info_display(0, 'black', "$lineCount lines read from /tmp/vim_buffer");
	print "functionS2: lineCount = $lineCount\n" if $opt_T;
	close(FH);
    } else {
	info_display(0, 'red', "cannot open /tmp/vim_buffer for reading");
    }
} # functionS2
__END__
############ POD to generate man page ##################################

=encoding utf8

=head1 NAME

iClive - an editor and live debugger for immediate-C apps

=head1 SYNOPSIS

 iClive [ -umtTqh][ -s <host>][ -p <port>][ -i <inst>][ -D [~]IXy.z]
        [ -F <font>][ -E <code>][ -H <num>][ -W <num>][ -g <geometry>]
        [ -A <cmd>][ -d <deb>][ <file> ...]
        [ -R <aux_app>[ <aux_app_argument> ...]] # must be last arguments
    -s host name of server host    (default '127.0.0.1')
    -p port service port of server (default '8778')
    -i inst initial instance selection (default ''; 1 to 3 numeric chars)
    -D IXy.z optional Debug Stop output to control moving parts in a plant
    -D ~IXy.z inverted Debug Stop output 0 (non-inverted Stop is 1)
    -F font or font size to use in Text window  (default '20')
    -E code encoding eg. ISO-8859-1                  (default 'UTF-8')
    -u      use edit undo facility (not recommended if using Live display)
    -H num  height of the Text window (default 35)
    -W num  width  of the Text window (default 85) -w0 is terminal width
    -g geom geometry for main window
    -S server +options+equivalences  (default 'iCserver -k -A iCbox')
    -A cmd  use <cmd> to autovivify I/O clients (default 'iCbox')
            if iCsever is started by this iClive call
                      BUILD option
    -L<lx>  link extra library(s) eg -L lm -L rt or -L lm,lrt
    file ... one or more space separated iC source files or comma
            separated groups if files. The first will be opened.
            The rest will be stored in the File menu for later.
            A comma separated group of files will be stored as a
            cascade in the File menu. The cascade group will be used
            to build one iC app from several files. If the first file
            has no .ic or .ica extension it is the run name of the app
            to be built and run. Otherwise the base name of the first
             (usually .ic file) is used as the run name.
            All other files in the comma separated list must be either
            .ic or .ica files to build the app.
            Any .ih %include or .iha %%include files in the nominated
            iC or iCa files will be automatically included in the
            cascade menu as relevant sources.
                      DEBUG options
    -d deb  extra debug options (see iC-application -h)
    -d  40  output symbol table received in Live mode
    -t      trace gate activity in target application (-d1100)
    -m      output elapsed time in seconds and microseconds
    -T      trace output static debug messages
    -q      quiet - do not report apps connecting and disconnecting
    -h      help, ouput this Usage text only
                      AUXILIARY app
    -R <app ...> run auxiliary app followed by -z and its arguments
                 as a separate process; -R ... must be last arguments.

 Menu buttons:                   Action                      Accelerator

    [File] ---- tear-off - menu can be moved and left open
       New      empty file for editing                            Alt-n
       Open     and load the selected file                        Alt-o
       Reload   the current file (usually modified externally)    Alt-R
       file.lst switch file beteen iC-source and iC-Listing       Alt-l
       Save     the current file if modified                      Alt-s
       SaveAs   store the current file at the selected path       Alt-a
       Quit     the program                                       Alt-q
       -------- this is followed by a history of previous programs,
                which can be selected randomly

    [Build]     build the C file and then optionally the executable
                from the currently displayed iC program text.     Alt-b

    [Run Stop]  run or stop the executable application built from the
                currently displayed iC program text.              Alt-r

    [  -]       select no instance or -0 to -9 or extra instance passed
                with -i option. Run and Live use the selected instance.

    [Live       scan the text and generate live markings for all words,
                which represent variables in the currently running
                application - which should be built from the text
                to make a meaningful display. Text is 'read only'
                in this mode.                                     Alt-e
     Edit]      clears live markings in the Text window. In this mode
                the text may be edited with the facilities of Tk::Text,
                which is a full featured editor. The edit facilities
                are described in the Tk::Text man page or below under
                the heading 'KEYBOARD BINDINGS'.  If called with the
                -u option, ctrl-U is the <<Undo>> binding.        Alt-e

    [ / ]       Put focus in Search Entry window if cleared.          /
                    (simulates vi)                           or   Alt-/
                Else start or continue a search of text in
                the Search Entry window. All hits will be marked.
            Holding this button down briefly will open a menu of
            extra search options
       Search down      or                                       RETURN
                displays a new group of hits
       Search up        or                                    Shift-RET
                reverses the direction of displaying hits
       Clear            or double-click Search Entry window or Ctrl-RET
                clears hits and the Search Entry window
       <>Go to line     or                                      Alt-RET
                goes to the line entered in the Search Entry window
       <>Word   match   (default - useful for finding variables)
       <>Exact  match   (search string matches anywhere in a word)
       <>Regexp match   (full Perl regular expression search)
       []Ignore case    (in any of the search modes)
       -------- this is followed by a history of previous search
                strings, which can be selected for a repeat search.

    [ - ]       Zoom Out   decrease font size                     Alt -
    [ + ]       Zoom In    increase font size                     Alt +

    [Debug]     Open a menu of options to start and stop Debug mode,
                which allows setting WatchPoints, interrupting,
                single stepping and continuing the program.

    [Help]      Display this man page.                            Alt-h

=head1 DESCRIPTION

B<iClive> is an Integrated Development Environment (IDE) for editing
and debugging iC programs. Most of the buttons in the menu bar are
explained above.

B<iClive> is a client of B<iCserver>, like all running iC applications
and IO's. On startup B<iClive> will start B<iCserver -A iCbox>, unless
iCserver is already running. This will automatically autovivify the
correct B<iCbox> when an application is started with the B<Run>
button. An alternative command to autovivify may be entered with
the B<-A> option: eg B<-A iClift> or B<-A 'iCbox -H'> If B<iClive>
started B<iCserver>, it will also stop B<iCserver> when it is stopped,
which automatically stops all running applications and IO's.

B<iClive> can execute in two major modes: B<Edit> mode and B<Live> mode.
The program starts in B<Edit> mode, which – as the name implies –
provides full text edit functions for any text in the main window.
This functionality is provided by the Tk::Text widget of the Perl/Tk
tool kit, on which B<iClive> is based.  The edit functions provided by
Tk::Text are very similar to the basic functions of Notepad or WinWord
under Windows or Kate or LibreOffice Writer under Linux.  A detailed
description can be found under the Heading ‘KEYBOARD BINDINGS’
in the B<iClive> man page, which is shown with the Help button.

The text in the B<Edit> window is assumed to be an iC or iCa program or
listing with some optional embedded C code.  When opening a new file
or saving a modified text, the following formatting is done:

  * Line numbers are shown in a column on the left. While editing
    line numbers may be temporarily incorrect, but they are re-
    computed whenever the text is saved. When editing care must be
    taken to not put any new text before or just after a line number.
    Apart from that any editing, including moving or deleting
    blocks of text with their line numbers or adding blocks of
    text without line numbers is corrected on saving the text.
    iC listings (extension .lst) do not show extra line numbers.
    They have correct line numbers for the program text already.
    Apart from that listings are Read-Only and cannot be edited.

  * Any C or C++ style comments in iC and C code are coloured blue.

  * Any embedded C code in a literal block bounded by %{ C code %}
    braces as well as C code blocks initiated by the iC operators if
    else or switch and bounded by matching simple braces are marked
    pale grey. Also C code in generated .lst listing files and
    generated .c C files are also marked pale grey.

  * All iC keywords and built-in function block names in iC code
    and C keywords in C code are made bold.  C keywords not also iC
    keywords in iC code are errors and coloured red and vice versa.

  * All C pre-processor commands #include, #define etc in C code, as
    well as all iC and iCa commands %define and %%define etc in iC or
    iCa code are made bold italics.  Macro names defined with #define,
    %define or %%define are displayed in italics throughout the code.

  * The following colouring is done to make iCa code more readable:

    * FOR and IF ELSE statements up to and including the opening
      double brace {{ as well as the closing double brace }} are
      coloured with pink background.

    * The first non-keyword after FOR, which is the loop control
      variable, is marked bold with a raised relief.  Every occurrence
      of a FOR loop control variable is marked similarly in the scope
      of the loop.  FOR loop control variables thus raised should
      only occur in inner FOR  and IF control statements marked pink
      or index expressions marked gold.

    * Every inner pair of matching square brackets enclosing an index
      expression is coloured gold eg [I+1].  Outer pairs of nested
      square brackets, which will be transferred unchanged to the
      iC or C code are left untouched eg immC bit array[[SIZE]].
      Also string constants in parentheses in an index expression
      eg [I ? " & " : " &\n"] are not tagged gold, since the text
      in the strings is iC code.

    * There should be no iC variables and hence no index expressions
      – indeed no variable which is not a FOR loop control variable
      or a macro - in FOR and IF control statements with a pink
      background.  If they do occur they are a syntax error and will
      be marked in red.

    * A side effect of this colouring strategy is that the square
      bracketed index elements if immediate arrays in plain iC code
      are also coloured gold eg var = array[0].  These markings only
      highlight immediate array elements and are not index expression
      like in iCa code.

  * In analysing the program text for this formatting quite a number
    of syntax errors are detected.  The error elements are marked
    bright red and appropriate warnings are output to STDERR.  At the
    end of the analysis the number of syntax errors is reported in
    the status bar at the bottom of the IDE Window.  This helps to
    avoid simple syntax errors when writing iCa code.

  * The above colouring and syntax checking is done when opening or
    saving a file. When syntax errors are detected, files are not
    registered or saved.

  * All these measures help to visually disentangle iC code, which
    is made up of four intirely different languages - iC, C,
    C pre-processor and iCa.

An extension Tk::TextUndo may be used to provide an UNDO facility
while editing. This extension used to be problematic for the 'live
display' - it was 7 times slower in making arithmetic updates and it
caused the window to jump to the last updated text for value changes
in the control application. This made the 'live display' hard to
interpret. This does not happen with Tk::Text and does not seem to be
a problem anymore.  Nevertheless Tk::Text remains the default until
more extensive tests have been done.  If you want to activate the
UNDO facility use iClive -u option (recommended only for editing)
Also see CAVEAT below.

When B<Live> mode is started, B<iClive> requests the symbol table of a
running application, whose name matches the source being edited. The
symbol table contains all possible B<Active> words in that program
and hence in the source.  B<iClive> returns a list of B<Active> words
visible in the current window.  These are words for which B<iClive>
wants live updates of the state of the nodes in the running program,
which then provides updates to B<iClive> as soon as possible after
any change of a node in that list.

In B<Live> mode all words in the text which exactly match any B<Active>
word in the list are tagged with a colour depending on the current
state of the node.  Logical nodes are B<green/black> for B<LO (0)>
and B<yellow/red> for B<HI (1)>.  Logical B<Active> words in the list
which are preceded by B<~>, which means logical inversion, show the
inverse state of the node. This quickly shows the correct logical
relationships in AND or OR expressions.  Also logical B<Active>
words which are followed by B<~> are inverted. This shows the correct
relationships in the expanded logical expressions in listing files.
Arithmetic nodes are B<blue>, clocks B<brown> and timers B<cadet blue>.
Clocks and timers as well as data nodes which change for less than
50 ms flash B<white> briefly (50 ms) every time they fire.

When the mouse cursor sits on an B<Active> word in B<Live> mode the
value of the node is displayed in a balloon window. This is a quick
way for displaying the current value of arithmetic nodes which is
always available. Also the current timer count is displeyed for timer
nodes.

When the mouse cursor sits on an B<Active> word in B<Live> mode and the
focus is in the Search Entry window (click in it or type '/') and
the left Shift-Key is pressed the balloon will display the 'index'
of the variable in the Symbol Table. This is useful to check if an
Alias or an immC array member has the same 'index' and is thus the same
variable as a normal variable with a different name. The same 'index'
is used in VCD files for GTKWave.  Simlarly when the left Control-Key
is pressed the balloon will display the 'ftype' of the variable.

Pressing the B<Debug> button opens a semi-permanent menu with debug
options.  B<Debug> mode is turned on immediately.

While B<Debug> mode is on, pressing Mouse Button-1 while positioned
over an B<Active> variable in the program text will open a menu to
enter/delete/disable a B<WatchPoint> or an B<IgnorePoint>.

  A WatchPoint is the equivalent of a breakpoint in a data driven
  environment. It triggers when an Active node variable changes (the
  default condition) or its condition, which may be set in a cascaded
  dialog, turns true.  Unconditional WatchPoints are marked in the
  code by underlining the variable name with a thick line. Conditional
  WatchPoints are underlined with a wavy line.

  An IgnorePoint is an Active node variable which will not stop
  during single step operations 'Step' or 'Next'.  This allows certain
  sections of the iC code to execute normally without stopping while
  single stepping.  The Timer variables TX0.3 - TX0.7 are marked as
  IgnorePoints initially to avoid single stepping to be interrupted
  regularly by Timer ticks.  IgnorePoints are marked in the code by
  crossing the variable name with an overstrike.

  Disabled WatchPoints or IgnorePoints are marked with a thinly
  dotted line.

The following buttons control debug actions:

  Debug     Turn Debug mode on and off. When turned off the Search
            Entry window is gray. It turns pale green when the program
            is running and Debug mode is on.  At the next change of
            any WatchPoint the program will stop and the Search Entry
            window will turn pink.  With Debug mode on the following
            three buttons, which control debug actions, are activated:

  Step      run the program until the next change of any Active variable
            in the current source. Since intermediate variables
            generated by the compiler are only contained in iC listing
            files, single stepping on changes of intermediate variables
            will only work with listing files, where the changes can
            also be seen. (Switch between .ic and .lst with Alt-l).

  Next      run the program until the next change of any output variable
            (Q...) in the current source.

            Step or Next can be pressed at any time while the program
            is running and Debug mode is on to interrupt the program.

  Continue  run the program until a WatchPoint is reached and its
            condition is satisfied. If there are no WatchPoints the
            program will run without stopping. This is the initial
            mode when Debug mode is turned on.

In all three cases, pressing any of the buttons will run the program
again and turn the Search Entry window pale green. At the next
change appropriate for the button pressed the program will stop and
turn the Search Entry window pink.  The name of the variable, whose
change made the program stop, and its value will be displayed in the
Search Entry window.  This is the B<Break> variable.  All instances
of the B<Break> variable will be highlighted in the current window
by raising the text and making it bold. If there are more instances
of the B<Break> variable outside of the current window, these can be
found by initiating a search with the [/] button or the Return key.

There are three further buttons in the Debug menu:

  WatchPoints list all Watch and Ignore points. Selected points may
            be deleted, disabled, enabled or have their conditions
            changed from this list. The 'Lookup' button starts a full
            search for all instances of a selected Watch or Ignore
            point in the program. ('Lookup' turns Debug mode off).

  Trace     toggles a trace output of every action of the data driven
            execution of the iC code in the terminal window iClive
            was called from. It is roughly equivalent to the machine
            language output of an instruction driven debugger.
            This output is particularly useful with single stepping.
            It shows all the detailed actions of counting Logic nodes,
            Arithmetic actions, as well as Clock and Timer actions
            leading up to a Break.

  MicroSec  show the time in microseconds between significant events
            during the execution of the program.

For B<Live> mode to be effective, the displayed text must be either
the source of the running iC application or a text derived from that
source, such as the iC listing.  Whenever a new iC text or another
instance is selected, B<iClive> will automatically attach itself to the
selected application (provided it is running).  B<iClive> shows the
statements of the source and the colours will show what the current
state of all logical and arithmetic variables in the statements is.
It is easy to inspect such a live listing and relate states with the
logic of the application.

In B<Live> mode an B<Active> word in a comment followed by an equal sign
at the very end of the line will show the changing value of the word.

    eg.  // offset =
    will be displayed as
         // offset = 15
    this construct is usually commented with //

This is the best way to display the state of arithmetic variables, but
it does require typing appropriate comments in the source code, which
is easy to do quickly in Edit mode.

=head1 SEARCH FACILITY

A powerful search facility to find whole words, exact parts of a
string or Perl type regular expressions has been implemented on top
of Text::Tk.  Activate the search by typing '/' or pressing the [/]
button briefly.  Enter or paste a word into the Search Entry window and
type RETURN or press the [/] button again.  Searches may be for a whole
Word match, an Exact match or for a full Perl-type regular expression
labelled Regex match.  Searches are normally case sensitive, but a
case-insensitive search may be selected. Once a search has been carried
out, all the hits are highlighted (black with white text). A first
group of hits is displayed in the Text window. The text is moved to
display as many hits as possible. When the user has analysed the first
group of hits, typing RETURN will display the next group of hits in the
text and so on until the end of the text is reached. Another RETURN
will start by displaying the first group at the top again. Typing
SHIFT-RETURN will reverse the direction of displaying the groups.

Holding down the search button [/] will open a menu with the different
search options 'Go to line', 'Word match', 'Exact match' or 'Regexp
match'. The 'Ignore case' button applies to the 3 search modes.
This is followed by a history of previous searches - most recent at
the end, which can be selected for a repeat search. This search menu
can be detached with the tear line ---------.

In 'Live' mode searches are restricted to text outside of comments,
which means searches will only return actual variables and keywords
in program text.

In 'Live' and 'Edit' mode but not in 'Edit Undo' mode (-u option),
double-clicking with mouse button 1 transfers the word under the
mouse to the Search Entry window and immediately starts a search
for that word. This is the quickest and best way to start a search.
The search can be continued by clicking on the [/] button or pressing
RETURN.

This quick search action in 'Edit' mode masks the selection of the text
under the mouse (Text Binding [2]).  Since selection of text can be
accomplished easily by swiping a word or stepping over the word with
the Shift-Left key it was felt the quick search action is more often
called for. The quick search action is not active for 'Edit Undo' mode.

Double-clicking with mouse button 1 with the cursor in the Search Entry
window or by typing ctrl-RETURN will clear the search completely.

In 'Edit' mode single-clicking with mouse button 1 or moving the
insert cursor with the keyboard over a brace, parenthesis or square
bracket will simply highlight matching braces, parentheses or square
brackets.  Double-clicking with the cursor on a brace, parenthesis or
square bracket character will move the insert cursor to the matching
braces etc.

The position of the displayed text may be manipulated by the scroll
bars or the usual up/down/prior/next/home/end keys.  A useful
feature is the use of the middle mouse button to fast scroll in all
4 directions through the text.

Tk::Text will open a dialog box when clicking the right mouse button
in the text window. The features provided are self explanatory. It
also has a search feature, which did not seem to be available when
I started. The really useful feature there is the search/replace
facility. Another useful feature is changing the wrap mode.

=head1 KEYBOARD BINDINGS

Tk automatically creates class bindings for texts that give them
the following default behavior in 'Edit' mode.  In the descriptions
below, 'word' refers to a contiguous group of letters, digits, or '_'
characters, or any single character other than these. (from Tk::Text)

[1] Clicking mouse button 1 positions the insertion cursor just before
   the character underneath the mouse cursor, sets the input focus to
   this widget, and clears any selection in the widget.  Dragging with
   mouse button 1 strokes out a selection between the insertion cursor
   and the character under the mouse.

[2] Double-clicking with mouse button 1 selects the word under the
   mouse and positions the insertion cursor at the beginning of the
   word.  Dragging after a double click will stroke out a selection
   consisting of whole words. (Overloaded by quick search except in
   'Edit Undo' mode).

[3] Triple-clicking with mouse button 1 selects the line under the
   mouse and positions the insertion cursor at the beginning of the
   line.  Dragging after a triple click will stroke out a selection
   consisting of whole lines. (Also overloaded by quick search except
   in 'Edit Undo' mode).

[4] The ends of the selection can be adjusted by dragging with mouse
   button 1 while the Shift key is down;  this will adjust the end
   of the selection that was nearest to the mouse cursor when button
   1 was pressed.  If the button is double-clicked before dragging
   then the selection will be adjusted in units of whole words; if
   it is triple-clicked then the selection will be adjusted in units
   of whole lines.

[5] Clicking mouse button 1 with the Control key down will reposition
   the insertion cursor without affecting the selection.

[6] If any normal printing characters are typed, they are inserted
   at the point of the insertion cursor.

[7] The view in the widget can be adjusted by dragging with mouse
   button 2.  If mouse button 2 is clicked without moving the mouse,
   the selection is copied into the text at the position of the
   mouse cursor.  The Insert key also inserts the selection, but at
   the position of the insertion cursor.

[8] If the mouse is dragged out of the widget while button 1 is
   pressed, the entry will automatically scroll to make more text
   visible (if there is more text offscreen on the side where the
   mouse left the window).

[9] The Left and Right keys move the insertion cursor one character
   to the left or right;  they also clear any selection in
   the text.  If Left or Right is typed with the Shift key down,
   then the insertion cursor moves and the selection is extended
   to include the new character.  Control-Left and Control-Right
   move the insertion cursor by words, and Control-Shift-Left and
   Control-Shift-Right move the insertion cursor by words and also
   extend the selection.  Control-b and Control-f behave the same as
   Left and Right, respectively.  Meta-b and Meta-f behave the same
   as Control-Left and Control-Right, respectively.

[10]
   The Up and Down keys move the insertion cursor one line up or
   down and clear any selection in the text.  If Up or Right is
   typed with the Shift key down, then the insertion cursor moves
   and the selection is extended to include the new character.
   Control-Up and Control-Down move the insertion cursor by paragraphs
   (groups of lines separated by blank lines), and Control-Shift-Up
   and Control-Shift-Down move the insertion cursor by paragraphs
   and also extend the selection.  Control-p and Control-n behave
   the same as Up and Down, respectively.

[11]
   The Next and Prior keys move the insertion cursor forward or
   backwards by one screenful and clear any selection in the text.
   If the Shift key is held down while Next or Prior is typed,
   then the selection is extended to include the new character.
   Control-v moves the view down one screenful without moving the
   insertion cursor or adjusting the selection.

[12]
   Control-Next and Control-Prior scroll the view right or left by one
   page without moving the insertion cursor or affecting the selection.

[13]
   Home and Control-a move the insertion cursor to the beginning of
   its line and clear any selection in the widget.  Shift-Home moves
   the insertion cursor to the beginning of the line and also extends
   the selection to that point.

[14]
   End and Control-e move the insertion cursor to the end of the line
   and clear any selection in the widget.  Shift-End moves the cursor
   to the end of the line and extends the selection to that point.

[15]
   Control-Home and Meta-< move the insertion cursor to the
   beginning of the text and clear any selection in the widget.
   Control-Shift-Home moves the insertion cursor to the beginning of
   the text and also extends the selection to that point.

[16]
   Control-End and Meta-> move the insertion cursor to the end of
   the text and clear any selection in the widget.  Control-Shift-End
   moves the cursor to the end of the text and extends the selection
   to that point.

[17]
   The Select key and Control-Space set the selection anchor to
   the position of the insertion cursor.  They don't affect the
   current selection.  Shift-Select and Control-Shift-Space adjust
   the selection to the current position of the insertion cursor,
   selecting from the anchor to the insertion cursor if there was
   not any selection previously.

[18]
   Control-/ selects the entire contents of the widget.

[19]
   Control-\ clears any selection in the widget.

[20]
   The F16 key (labelled Copy on many Sun workstations) or Meta-w
   copies the selection in the widget to the clipboard, if there is
   a selection.

[21]
   The F20 key (labelled Cut on many Sun workstations) or Control-w
   copies the selection in the widget to the clipboard and deletes
   the selection.  If there is no selection in the widget then these
   keys have no effect.

[22]
   The F18 key (labelled Paste on many Sun workstations) or Control-y
   inserts the contents of the clipboard at the position of the
   insertion cursor.

[23]
   The Delete key deletes the selection, if there is one in the widget.
   If there is no selection, it deletes the character to the right
   of the insertion cursor.

[24]
   Backspace and Control-h delete the selection, if there is one in
   the widget.  If there is no selection, they delete the character
   to the left of the insertion cursor.

[25]
   Control-d deletes the character to the right of the insertion
   cursor.

[26]
   Meta-d deletes the word to the right of the insertion cursor.

[27]
   Control-k deletes from the insertion cursor to the end of its
   line; if the insertion cursor is already at the end of a line,
   then Control-k deletes the newline character.

[28]
   Control-o opens a new line by inserting a newline character in
   front of the insertion cursor without moving the insertion cursor.

[29]
   Meta-backspace and Meta-Delete delete the word to the left of the
   insertion cursor.

[30]
   Control-x deletes whatever is selected in the text widget.

[31]
   Control-t reverses the order of the two characters to the right
   of the insertion cursor.

[32]
   Control-z (and Control-underscore on UNIX when tk_strictMotif is
   true)  undoes  the last edit action if the -undo option is true.
   Does nothing otherwise.

[33]
   Control-Z (or Control-y on Windows) reapplies the last undone edit
   action if the -undo option is true. Does nothing otherwise.
   (see below)

CAVEAT: These two Undo actions, if iClive -u is called, were found
to be rather tricky.  Control-u as well as control-z undoes changes
and both re-apply undone changes with the other. I found it very
disturbing, that when you try to undo more than the last change, the
whole window is cleared (undoes the load !!). Theoretically the text
was in the state of the file originally loaded when this 'load undo'
was executed. Control-z (or contrl-u) will bring it back. A better
option is to do a File/Reload.  Control-Z does not seem to work!!

The following extra Bindings have been defined for iClive:

[iC1]
   Alt-n   provide a New empty file
   Alt-o   Open a file
   Alt-R   Reload the current file (usually modified externally)
   Alt-l   switch beteen iC-source and iC-Listing
   Alt-s   Save current file
   Alt-a   saveAs current file under a new name
   Alt-h   Help for iClive
   Alt-q   Quit iClive

   Alt-b   Build executable from current iC-file
   Alt-u   Unconditionally save and build
   Alt-c   build C-file only from current iC-file

   Alt-r   Run/stop the current executable
   Alt-e   switch between Edit/live mode

   Alt +   Dynamically increase font size
   Alt -   Dynamically decrease font size

Because of line numbering the method of copying blocks
of text with ctrl+C and pasting it with ctrl+V is not
easy in iClive. The following are useful alternatives in
'Edit' mode:

[iC2]
   <F2>    Write to the temporary buffer /tmp/vim_buffer for
           transfer between text windows with function key <F2>.
           If no lines  are selected the whole text is written.
           Line numbers are removed from the text written to the
           clipboard /tmp/vim_buffer.
           This function allows transferring selections of whole
           lines between iClive and VIM if
               map <S-F2> :r /tmp/vim_buffer<CR>
           for reading  /tmp/vim_buffer is part of .exrc for VIM.
    <S-F2> Read from the temporary buffer /tmp/vim_buffer for
           transfer between text windows with function key <S-F2>.
           This function allows transferring selections of whole
           lines between VIM and iClive if
               map <F2> :w! /tmp/vim_buffer<CR>
           for writing /tmp/vim_buffer is part of .exrc for VIM.
The clipboard buffer /tmp/vim_buffer is best owned by the
user 'root' with:
    sudo chown root:root /tmp/vim_buffer
and made read and writable for everybody with:
    sudo chmod 666 /tmp/vim_buffer

If the widget is read-only, as it is in 'Live' mode, then its view can
still be adjusted and text can still be selected, but no insertion
cursor will be displayed and no text modifications will take place.
In 'Live' mode the focus is normally on the y-Scrollbar or on the
search-Entry window.  The following Bindings have been programmed for
'Live' mode.

[iC3]
   The Left and Right keys scroll the whole text left and right one
   character at a time.

[iC4]
   The Up and Down keys scroll the text up and down one line at a time.

[iC5]
   The Next and Prior keys scroll the text up and down one page at
   a time.

[iC6]
   The Home and End keys move the text to the beginning or end.

These scroll modes are also available in 'Edit' mode, by putting
the focus in the 'search-Entry' window by clicking in it. To
continue editing click in the text window again.

[iC7]
   The view in the widget can be adjusted by dragging with mouse
   button 3. (same in both modes)

[iC8]
   In 'Live' mode the following Accelerators work without
   the Alt-Key pressed:
    l   switch beteen iC-source and iC-Listing
    h   Help for iClive
    q   Quit iClive
    s   Stop the current executable (loses 'Live' mode)
    r   also stops executable       (Alt-r to 'Run' again)
    e   switch to 'Edit' mode       (Alt-e to 'Live' mode)
    /   clear search entry (vi)     (Alt-/ in entry window)
   All these accelerators (except s) also work with the
   Alt-Key pressed in both 'Edit' and 'Live' mode.

=head1 MODULE Time::HiRes

For measuring reaction times the Module Time::HiRes is used.  This
activates the -m option and flash display of short events.  Make sure
you have installed Time::HiRes (provided in this distribution)

=head1 AUTHOR

John E. Wulff

=head1 BUGS

Email bug reports to B<immediateC@gmail.com> with L<iC Project> in the
subject field.

=head1 SEE ALSO

L<immcc(1)>, L<iCbox(1)>, L<iCserver(1)>, L<iCmake(1)>, L<iCman(1)>

=head1 COPYRIGHT

COPYRIGHT (C) 2000-2023  John E. Wulff

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.

For more information about this program, or for information on how
to contact the author, see the README file.
